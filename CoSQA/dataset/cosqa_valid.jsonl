{"url": "cosqa-train-8333", "docstring_tokens": ["Determine", "whether", "or", "not", "obj", "is", "iterable", "but", "not", "a", "string", "(", "eg", "a", "list", "set", "tuple", "etc", ")", "."], "code": "def is_iterable_but_not_string(obj):\n    \"\"\"\n    Determine whether or not obj is iterable but not a string (eg, a list, set, tuple etc).\n    \"\"\"\n    return hasattr(obj, '__iter__') and not isinstance(obj, str) and not isinstance(obj, bytes)", "code_tokens": ["def", "is_iterable_but_not_string", "(", "obj", ")", ":", "return", "hasattr", "(", "obj", ",", "'__iter__'", ")", "and", "not", "isinstance", "(", "obj", ",", "str", ")", "and", "not", "isinstance", "(", "obj", ",", "bytes", ")"], "idx": 1640}
{"url": "cosqa-train-9660", "docstring_tokens": ["Make", "file", "user", "readable", "if", "it", "is", "not", "a", "link", "."], "code": "def make_file_readable (filename):\n    \"\"\"Make file user readable if it is not a link.\"\"\"\n    if not os.path.islink(filename):\n        util.set_mode(filename, stat.S_IRUSR)", "code_tokens": ["def", "make_file_readable", "(", "filename", ")", ":", "if", "not", "os", ".", "path", ".", "islink", "(", "filename", ")", ":", "util", ".", "set_mode", "(", "filename", ",", "stat", ".", "S_IRUSR", ")"], "idx": 4294}
{"url": "cosqa-train-16056", "docstring_tokens": ["Manufacture", "decorator", "that", "filters", "return", "value", "with", "given", "function", "."], "code": "def apply(filter):\n    \"\"\"Manufacture decorator that filters return value with given function.\n\n    ``filter``:\n      Callable that takes a single parameter.\n    \"\"\"\n    def decorator(callable):\n        return lambda *args, **kwargs: filter(callable(*args, **kwargs))\n    return decorator", "code_tokens": ["def", "apply", "(", "filter", ")", ":", "def", "decorator", "(", "callable", ")", ":", "return", "lambda", "*", "args", ",", "*", "*", "kwargs", ":", "filter", "(", "callable", "(", "*", "args", ",", "*", "*", "kwargs", ")", ")", "return", "decorator"], "idx": 5176}
{"url": "cosqa-train-7554", "docstring_tokens": ["use", "before", "any", "custom", "printing", "when", "using", "the", "progress", "iter", "to", "ensure", "your", "print", "statement", "starts", "on", "a", "new", "line", "instead", "of", "at", "the", "end", "of", "a", "progress", "line"], "code": "def ensure_newline(self):\n        \"\"\"\n        use before any custom printing when using the progress iter to ensure\n        your print statement starts on a new line instead of at the end of a\n        progress line\n        \"\"\"\n        DECTCEM_SHOW = '\\033[?25h'  # show cursor\n        AT_END = DECTCEM_SHOW + '\\n'\n        if not self._cursor_at_newline:\n            self.write(AT_END)\n            self._cursor_at_newline = True", "code_tokens": ["def", "ensure_newline", "(", "self", ")", ":", "DECTCEM_SHOW", "=", "'\\033[?25h'", "#", "show", "cursor", "AT_END", "=", "DECTCEM_SHOW", "+", "'\\n'", "if", "not", "self", ".", "_cursor_at_newline", ":", "self", ".", "write", "(", "AT_END", ")", "self", ".", "_cursor_at_newline", "=", "True"], "idx": 3812}
{"url": "cosqa-train-10709", "docstring_tokens": ["variance", "of", "the", "values", "must", "have", "2", "or", "more", "entries", "."], "code": "def variance(arr):\n  \"\"\"variance of the values, must have 2 or more entries.\n\n  :param arr: list of numbers\n  :type arr: number[] a number array\n  :return: variance\n  :rtype: float\n\n  \"\"\"\n  avg = average(arr)\n  return sum([(float(x)-avg)**2 for x in arr])/float(len(arr)-1)", "code_tokens": ["def", "variance", "(", "arr", ")", ":", "avg", "=", "average", "(", "arr", ")", "return", "sum", "(", "[", "(", "float", "(", "x", ")", "-", "avg", ")", "**", "2", "for", "x", "in", "arr", "]", ")", "/", "float", "(", "len", "(", "arr", ")", "-", "1", ")"], "idx": 2108}
{"url": "cosqa-train-11657", "docstring_tokens": ["r", "Checks", "if", "l", "is", "a", "2D", "numpy", "array", "of", "bools"], "code": "def is_bool_matrix(l):\n    r\"\"\"Checks if l is a 2D numpy array of bools\n\n    \"\"\"\n    if isinstance(l, np.ndarray):\n        if l.ndim == 2 and (l.dtype == bool):\n            return True\n    return False", "code_tokens": ["def", "is_bool_matrix", "(", "l", ")", ":", "if", "isinstance", "(", "l", ",", "np", ".", "ndarray", ")", ":", "if", "l", ".", "ndim", "==", "2", "and", "(", "l", ".", "dtype", "==", "bool", ")", ":", "return", "True", "return", "False"], "idx": 1574}
{"url": "cosqa-train-12916", "docstring_tokens": ["Checks", "whether", "a", "variable", "is", "a", "numpy", "integer", "array", "."], "code": "def is_integer_array(val):\n    \"\"\"\n    Checks whether a variable is a numpy integer array.\n\n    Parameters\n    ----------\n    val\n        The variable to check.\n\n    Returns\n    -------\n    bool\n        True if the variable is a numpy integer array. Otherwise False.\n\n    \"\"\"\n    return is_np_array(val) and issubclass(val.dtype.type, np.integer)", "code_tokens": ["def", "is_integer_array", "(", "val", ")", ":", "return", "is_np_array", "(", "val", ")", "and", "issubclass", "(", "val", ".", "dtype", ".", "type", ",", "np", ".", "integer", ")"], "idx": 2675}
{"url": "cosqa-train-12355", "docstring_tokens": ["Recursivly", "delete", "a", "directory"], "code": "def rrmdir(directory):\n    \"\"\"\n    Recursivly delete a directory\n\n    :param directory: directory to remove\n    \"\"\"\n    for root, dirs, files in os.walk(directory, topdown=False):\n        for name in files:\n            os.remove(os.path.join(root, name))\n        for name in dirs:\n            os.rmdir(os.path.join(root, name))\n    os.rmdir(directory)", "code_tokens": ["def", "rrmdir", "(", "directory", ")", ":", "for", "root", ",", "dirs", ",", "files", "in", "os", ".", "walk", "(", "directory", ",", "topdown", "=", "False", ")", ":", "for", "name", "in", "files", ":", "os", ".", "remove", "(", "os", ".", "path", ".", "join", "(", "root", ",", "name", ")", ")", "for", "name", "in", "dirs", ":", "os", ".", "rmdir", "(", "os", ".", "path", ".", "join", "(", "root", ",", "name", ")", ")", "os", ".", "rmdir", "(", "directory", ")"], "idx": 1013}
{"url": "cosqa-train-16936", "docstring_tokens": ["Gets", "the", "user", "enter", "max", "and", "min", "values", "of", "where", "the", "raster", "points", "should", "appear", "on", "the", "y", "-", "axis"], "code": "def values(self):\n        \"\"\"Gets the user enter max and min values of where the \n        raster points should appear on the y-axis\n\n        :returns: (float, float) -- (min, max) y-values to bound the raster plot by\n        \"\"\"\n        lower = float(self.lowerSpnbx.value())\n        upper = float(self.upperSpnbx.value())\n        return (lower, upper)", "code_tokens": ["def", "values", "(", "self", ")", ":", "lower", "=", "float", "(", "self", ".", "lowerSpnbx", ".", "value", "(", ")", ")", "upper", "=", "float", "(", "self", ".", "upperSpnbx", ".", "value", "(", ")", ")", "return", "(", "lower", ",", "upper", ")"], "idx": 314}
{"url": "cosqa-train-14114", "docstring_tokens": ["Format", "list", "."], "code": "def list_formatter(handler, item, value):\n    \"\"\"Format list.\"\"\"\n    return u', '.join(str(v) for v in value)", "code_tokens": ["def", "list_formatter", "(", "handler", ",", "item", ",", "value", ")", ":", "return", "u',", "'", ".", "join", "(", "str", "(", "v", ")", "for", "v", "in", "value", ")"], "idx": 892}
{"url": "cosqa-train-11154", "docstring_tokens": ["Get", "the", "list", "of", "distinct", "values", "with", "preserving", "order", "."], "code": "def distinct(xs):\n    \"\"\"Get the list of distinct values with preserving order.\"\"\"\n    # don't use collections.OrderedDict because we do support Python 2.6\n    seen = set()\n    return [x for x in xs if x not in seen and not seen.add(x)]", "code_tokens": ["def", "distinct", "(", "xs", ")", ":", "#", "don't", "use", "collections.OrderedDict", "because", "we", "do", "support", "Python", "2.6", "seen", "=", "set", "(", ")", "return", "[", "x", "for", "x", "in", "xs", "if", "x", "not", "in", "seen", "and", "not", "seen", ".", "add", "(", "x", ")", "]"], "idx": 714}
{"url": "cosqa-train-9553", "docstring_tokens": ["Load", "graph", "as", "defined", "by", "a", "DOT", "file", ".", "The", "file", "is", "assumed", "to", "be", "in", "DOT", "format", ".", "It", "will", "be", "loaded", "parsed", "and", "a", "Dot", "class", "will", "be", "returned", "representing", "the", "graph", "."], "code": "def graph_from_dot_file(path):\n    \"\"\"Load graph as defined by a DOT file.\n    \n    The file is assumed to be in DOT format. It will\n    be loaded, parsed and a Dot class will be returned, \n    representing the graph.\n    \"\"\"\n    \n    fd = file(path, 'rb')\n    data = fd.read()\n    fd.close()\n    \n    return graph_from_dot_data(data)", "code_tokens": ["def", "graph_from_dot_file", "(", "path", ")", ":", "fd", "=", "file", "(", "path", ",", "'rb'", ")", "data", "=", "fd", ".", "read", "(", ")", "fd", ".", "close", "(", ")", "return", "graph_from_dot_data", "(", "data", ")"], "idx": 2908}
{"url": "cosqa-train-19409", "docstring_tokens": ["Yield", "all", "items", "from", "iterable", "except", "the", "last", "one", "."], "code": "def butlast(iterable):\n    \"\"\"Yield all items from ``iterable`` except the last one.\n\n    >>> list(butlast(['spam', 'eggs', 'ham']))\n    ['spam', 'eggs']\n\n    >>> list(butlast(['spam']))\n    []\n\n    >>> list(butlast([]))\n    []\n    \"\"\"\n    iterable = iter(iterable)\n    try:\n        first = next(iterable)\n    except StopIteration:\n        return\n    for second in iterable:\n        yield first\n        first = second", "code_tokens": ["def", "butlast", "(", "iterable", ")", ":", "iterable", "=", "iter", "(", "iterable", ")", "try", ":", "first", "=", "next", "(", "iterable", ")", "except", "StopIteration", ":", "return", "for", "second", "in", "iterable", ":", "yield", "first", "first", "=", "second"], "idx": 5721}
{"url": "cosqa-train-14561", "docstring_tokens": ["Reads", "a", "stream", "discarding", "the", "data", "read", "and", "returns", "its", "size", "."], "code": "def _read_stream_for_size(stream, buf_size=65536):\n    \"\"\"Reads a stream discarding the data read and returns its size.\"\"\"\n    size = 0\n    while True:\n        buf = stream.read(buf_size)\n        size += len(buf)\n        if not buf:\n            break\n    return size", "code_tokens": ["def", "_read_stream_for_size", "(", "stream", ",", "buf_size", "=", "65536", ")", ":", "size", "=", "0", "while", "True", ":", "buf", "=", "stream", ".", "read", "(", "buf_size", ")", "size", "+=", "len", "(", "buf", ")", "if", "not", "buf", ":", "break", "return", "size"], "idx": 3708}
{"url": "cosqa-train-19566", "docstring_tokens": ["Pull", "a", "file", "directly", "from", "S3", "."], "code": "def s3_get(url: str, temp_file: IO) -> None:\n    \"\"\"Pull a file directly from S3.\"\"\"\n    s3_resource = boto3.resource(\"s3\")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)", "code_tokens": ["def", "s3_get", "(", "url", ":", "str", ",", "temp_file", ":", "IO", ")", "->", "None", ":", "s3_resource", "=", "boto3", ".", "resource", "(", "\"s3\"", ")", "bucket_name", ",", "s3_path", "=", "split_s3_path", "(", "url", ")", "s3_resource", ".", "Bucket", "(", "bucket_name", ")", ".", "download_fileobj", "(", "s3_path", ",", "temp_file", ")"], "idx": 5656}
{"url": "cosqa-train-14313", "docstring_tokens": ["A", "helper", "to", "create", "a", "proxy", "method", "in", "a", "class", "."], "code": "def Proxy(f):\n  \"\"\"A helper to create a proxy method in a class.\"\"\"\n\n  def Wrapped(self, *args):\n    return getattr(self, f)(*args)\n\n  return Wrapped", "code_tokens": ["def", "Proxy", "(", "f", ")", ":", "def", "Wrapped", "(", "self", ",", "*", "args", ")", ":", "return", "getattr", "(", "self", ",", "f", ")", "(", "*", "args", ")", "return", "Wrapped"], "idx": 577}
{"url": "cosqa-train-13573", "docstring_tokens": ["must", "be", "a", "float"], "code": "def is_float(value):\n    \"\"\"must be a float\"\"\"\n    return isinstance(value, float) or isinstance(value, int) or isinstance(value, np.float64), float(value)", "code_tokens": ["def", "is_float", "(", "value", ")", ":", "return", "isinstance", "(", "value", ",", "float", ")", "or", "isinstance", "(", "value", ",", "int", ")", "or", "isinstance", "(", "value", ",", "np", ".", "float64", ")", ",", "float", "(", "value", ")"], "idx": 772}
{"url": "cosqa-train-1140", "docstring_tokens": ["Return", "a", "dataframe", "that", "is", "a", "cross", "between", "dataframes", "df1", "and", "df2"], "code": "def cross_join(df1, df2):\n    \"\"\"\n    Return a dataframe that is a cross between dataframes\n    df1 and df2\n\n    ref: https://github.com/pydata/pandas/issues/5401\n    \"\"\"\n    if len(df1) == 0:\n        return df2\n\n    if len(df2) == 0:\n        return df1\n\n    # Add as lists so that the new index keeps the items in\n    # the order that they are added together\n    all_columns = pd.Index(list(df1.columns) + list(df2.columns))\n    df1['key'] = 1\n    df2['key'] = 1\n    return pd.merge(df1, df2, on='key').loc[:, all_columns]", "code_tokens": ["def", "cross_join", "(", "df1", ",", "df2", ")", ":", "if", "len", "(", "df1", ")", "==", "0", ":", "return", "df2", "if", "len", "(", "df2", ")", "==", "0", ":", "return", "df1", "#", "Add", "as", "lists", "so", "that", "the", "new", "index", "keeps", "the", "items", "in", "#", "the", "order", "that", "they", "are", "added", "together", "all_columns", "=", "pd", ".", "Index", "(", "list", "(", "df1", ".", "columns", ")", "+", "list", "(", "df2", ".", "columns", ")", ")", "df1", "[", "'key'", "]", "=", "1", "df2", "[", "'key'", "]", "=", "1", "return", "pd", ".", "merge", "(", "df1", ",", "df2", ",", "on", "=", "'key'", ")", ".", "loc", "[", ":", ",", "all_columns", "]"], "idx": 793}
{"url": "cosqa-train-19881", "docstring_tokens": ["docstring", "for", "argparse"], "code": "def cli_run():\n    \"\"\"docstring for argparse\"\"\"\n    parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow')\n    parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+')\n    parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda')\n    args = parser.parse_args()\n    main(args)", "code_tokens": ["def", "cli_run", "(", ")", ":", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Stupidly", "simple", "code", "answers", "from", "StackOverflow'", ")", "parser", ".", "add_argument", "(", "'query'", ",", "help", "=", "\"What's", "the", "problem", "?\"", ",", "type", "=", "str", ",", "nargs", "=", "'+'", ")", "parser", ".", "add_argument", "(", "'-t'", ",", "'--tags'", ",", "help", "=", "'semicolon", "separated", "tags", "->", "python;lambda'", ")", "args", "=", "parser", ".", "parse_args", "(", ")", "main", "(", "args", ")"], "idx": 5600}
{"url": "cosqa-train-1833", "docstring_tokens": ["Set", "an", "object", "s", "field", "to", "default", "if", "it", "doesn", "t", "have", "a", "value"], "code": "def setdefault(obj, field, default):\n    \"\"\"Set an object's field to default if it doesn't have a value\"\"\"\n    setattr(obj, field, getattr(obj, field, default))", "code_tokens": ["def", "setdefault", "(", "obj", ",", "field", ",", "default", ")", ":", "setattr", "(", "obj", ",", "field", ",", "getattr", "(", "obj", ",", "field", ",", "default", ")", ")"], "idx": 1500}
{"url": "cosqa-train-9718", "docstring_tokens": ["Return", "the", "unique", "elements", "of", "a", "collection", "even", "if", "those", "elements", "are", "unhashable", "and", "unsortable", "like", "dicts", "and", "sets"], "code": "def unique(seq):\n    \"\"\"Return the unique elements of a collection even if those elements are\n       unhashable and unsortable, like dicts and sets\"\"\"\n    cleaned = []\n    for each in seq:\n        if each not in cleaned:\n            cleaned.append(each)\n    return cleaned", "code_tokens": ["def", "unique", "(", "seq", ")", ":", "cleaned", "=", "[", "]", "for", "each", "in", "seq", ":", "if", "each", "not", "in", "cleaned", ":", "cleaned", ".", "append", "(", "each", ")", "return", "cleaned"], "idx": 581}
{"url": "cosqa-train-18199", "docstring_tokens": ["Returns", "its", "parameter", "as", "an", "integer", "or", "raises", "django", ".", "forms", ".", "ValidationError", "."], "code": "def clean_int(x) -> int:\n    \"\"\"\n    Returns its parameter as an integer, or raises\n    ``django.forms.ValidationError``.\n    \"\"\"\n    try:\n        return int(x)\n    except ValueError:\n        raise forms.ValidationError(\n            \"Cannot convert to integer: {}\".format(repr(x)))", "code_tokens": ["def", "clean_int", "(", "x", ")", "->", "int", ":", "try", ":", "return", "int", "(", "x", ")", "except", "ValueError", ":", "raise", "forms", ".", "ValidationError", "(", "\"Cannot", "convert", "to", "integer:", "{}\"", ".", "format", "(", "repr", "(", "x", ")", ")", ")"], "idx": 5836}
{"url": "cosqa-train-960", "docstring_tokens": ["Check", "features", "data", "are", "not", "empty"], "code": "def contains_empty(features):\n    \"\"\"Check features data are not empty\n\n    :param features: The features data to check.\n    :type features: list of numpy arrays.\n\n    :return: True if one of the array is empty, False else.\n\n    \"\"\"\n    if not features:\n        return True\n    for feature in features:\n        if feature.shape[0] == 0:\n            return True\n    return False", "code_tokens": ["def", "contains_empty", "(", "features", ")", ":", "if", "not", "features", ":", "return", "True", "for", "feature", "in", "features", ":", "if", "feature", ".", "shape", "[", "0", "]", "==", "0", ":", "return", "True", "return", "False"], "idx": 847}
{"url": "cosqa-dev-218", "docstring_tokens": ["Move", "cursor", "to", "this", "line", "in", "the", "current", "buffer", "."], "code": "def _go_to_line(editor, line):\n    \"\"\"\n    Move cursor to this line in the current buffer.\n    \"\"\"\n    b = editor.application.current_buffer\n    b.cursor_position = b.document.translate_row_col_to_index(max(0, int(line) - 1), 0)", "code_tokens": ["def", "_go_to_line", "(", "editor", ",", "line", ")", ":", "b", "=", "editor", ".", "application", ".", "current_buffer", "b", ".", "cursor_position", "=", "b", ".", "document", ".", "translate_row_col_to_index", "(", "max", "(", "0", ",", "int", "(", "line", ")", "-", "1", ")", ",", "0", ")"], "idx": 814}
{"url": "cosqa-train-10948", "docstring_tokens": ["Test", "if", "value", "is", "an", "instance", "of", "int", "."], "code": "def test_value(self, value):\n        \"\"\"Test if value is an instance of int.\"\"\"\n        if not isinstance(value, int):\n            raise ValueError('expected int value: ' + str(type(value)))", "code_tokens": ["def", "test_value", "(", "self", ",", "value", ")", ":", "if", "not", "isinstance", "(", "value", ",", "int", ")", ":", "raise", "ValueError", "(", "'expected", "int", "value:", "'", "+", "str", "(", "type", "(", "value", ")", ")", ")"], "idx": 4573}
{"url": "cosqa-train-19334", "docstring_tokens": ["Truncates", "a", "value", "to", "a", "number", "of", "decimals", "places"], "code": "def truncate(value: Decimal, n_digits: int) -> Decimal:\n    \"\"\"Truncates a value to a number of decimals places\"\"\"\n    return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)", "code_tokens": ["def", "truncate", "(", "value", ":", "Decimal", ",", "n_digits", ":", "int", ")", "->", "Decimal", ":", "return", "Decimal", "(", "math", ".", "trunc", "(", "value", "*", "(", "10", "**", "n_digits", ")", ")", ")", "/", "(", "10", "**", "n_digits", ")"], "idx": 5704}
{"url": "cosqa-train-15119", "docstring_tokens": ["Add", "executable", "permissions", "to", "the", "file"], "code": "def add_exec_permission_to(target_file):\n    \"\"\"Add executable permissions to the file\n\n    :param target_file: the target file whose permission to be changed\n    \"\"\"\n    mode = os.stat(target_file).st_mode\n    os.chmod(target_file, mode | stat.S_IXUSR)", "code_tokens": ["def", "add_exec_permission_to", "(", "target_file", ")", ":", "mode", "=", "os", ".", "stat", "(", "target_file", ")", ".", "st_mode", "os", ".", "chmod", "(", "target_file", ",", "mode", "|", "stat", ".", "S_IXUSR", ")"], "idx": 2659}
{"url": "cosqa-train-13474", "docstring_tokens": ["Return", "manhattan", "distance", "between", "two", "lists", "of", "numbers", "."], "code": "def _manhattan_distance(vec_a, vec_b):\n    \"\"\"Return manhattan distance between two lists of numbers.\"\"\"\n    if len(vec_a) != len(vec_b):\n        raise ValueError('len(vec_a) must equal len(vec_b)')\n    return sum(map(lambda a, b: abs(a - b), vec_a, vec_b))", "code_tokens": ["def", "_manhattan_distance", "(", "vec_a", ",", "vec_b", ")", ":", "if", "len", "(", "vec_a", ")", "!=", "len", "(", "vec_b", ")", ":", "raise", "ValueError", "(", "'len(vec_a)", "must", "equal", "len(vec_b)'", ")", "return", "sum", "(", "map", "(", "lambda", "a", ",", "b", ":", "abs", "(", "a", "-", "b", ")", ",", "vec_a", ",", "vec_b", ")", ")"], "idx": 1828}
{"url": "cosqa-train-18187", "docstring_tokens": ["Finds", "the", "longest", "path", "in", "a", "dag", "between", "two", "nodes"], "code": "def dag_longest_path(graph, source, target):\n    \"\"\"\n    Finds the longest path in a dag between two nodes\n    \"\"\"\n    if source == target:\n        return [source]\n    allpaths = nx.all_simple_paths(graph, source, target)\n    longest_path = []\n    for l in allpaths:\n        if len(l) > len(longest_path):\n            longest_path = l\n    return longest_path", "code_tokens": ["def", "dag_longest_path", "(", "graph", ",", "source", ",", "target", ")", ":", "if", "source", "==", "target", ":", "return", "[", "source", "]", "allpaths", "=", "nx", ".", "all_simple_paths", "(", "graph", ",", "source", ",", "target", ")", "longest_path", "=", "[", "]", "for", "l", "in", "allpaths", ":", "if", "len", "(", "l", ")", ">", "len", "(", "longest_path", ")", ":", "longest_path", "=", "l", "return", "longest_path"], "idx": 5910}
{"url": "cosqa-train-7733", "docstring_tokens": ["*", "Get", "the", "root", "path", "for", "this", "python", "package", "-", "used", "in", "unit", "testing", "code", "*"], "code": "def getpackagepath():\n    \"\"\"\n     *Get the root path for this python package - used in unit testing code*\n    \"\"\"\n    moduleDirectory = os.path.dirname(__file__)\n    packagePath = os.path.dirname(__file__) + \"/../\"\n\n    return packagePath", "code_tokens": ["def", "getpackagepath", "(", ")", ":", "moduleDirectory", "=", "os", ".", "path", ".", "dirname", "(", "__file__", ")", "packagePath", "=", "os", ".", "path", ".", "dirname", "(", "__file__", ")", "+", "\"/../\"", "return", "packagePath"], "idx": 1712}
{"url": "cosqa-train-8563", "docstring_tokens": ["Convert", "an", "unsigned", "integer", "to", "a", "numpy", "binary", "array", "with", "the", "first", "element", "the", "MSB", "and", "the", "last", "element", "the", "LSB", "."], "code": "def to_bin(data, width):\n    \"\"\"\n    Convert an unsigned integer to a numpy binary array with the first\n    element the MSB and the last element the LSB.\n    \"\"\"\n    data_str = bin(data & (2**width-1))[2:].zfill(width)\n    return [int(x) for x in tuple(data_str)]", "code_tokens": ["def", "to_bin", "(", "data", ",", "width", ")", ":", "data_str", "=", "bin", "(", "data", "&", "(", "2", "**", "width", "-", "1", ")", ")", "[", "2", ":", "]", ".", "zfill", "(", "width", ")", "return", "[", "int", "(", "x", ")", "for", "x", "in", "tuple", "(", "data_str", ")", "]"], "idx": 4059}
{"url": "cosqa-train-18097", "docstring_tokens": ["Removes", "trailing", "zeroes", "from", "indexable", "collection", "of", "numbers"], "code": "def __remove_trailing_zeros(self, collection):\n        \"\"\"Removes trailing zeroes from indexable collection of numbers\"\"\"\n        index = len(collection) - 1\n        while index >= 0 and collection[index] == 0:\n            index -= 1\n\n        return collection[:index + 1]", "code_tokens": ["def", "__remove_trailing_zeros", "(", "self", ",", "collection", ")", ":", "index", "=", "len", "(", "collection", ")", "-", "1", "while", "index", ">=", "0", "and", "collection", "[", "index", "]", "==", "0", ":", "index", "-=", "1", "return", "collection", "[", ":", "index", "+", "1", "]"], "idx": 5636}
{"url": "cosqa-train-6367", "docstring_tokens": ["Rearrange", "the", "heap", "after", "the", "item", "at", "position", "i", "got", "updated", "."], "code": "def fix(h, i):\n    \"\"\"Rearrange the heap after the item at position i got updated.\"\"\"\n    down(h, i, h.size())\n    up(h, i)", "code_tokens": ["def", "fix", "(", "h", ",", "i", ")", ":", "down", "(", "h", ",", "i", ",", "h", ".", "size", "(", ")", ")", "up", "(", "h", ",", "i", ")"], "idx": 3468}
{"url": "cosqa-train-10663", "docstring_tokens": ["Uses", "box", "coordinates", "to", "crop", "an", "image", "without", "resizing", "it", "first", "."], "code": "def crop_box(im, box=False, **kwargs):\n    \"\"\"Uses box coordinates to crop an image without resizing it first.\"\"\"\n    if box:\n        im = im.crop(box)\n    return im", "code_tokens": ["def", "crop_box", "(", "im", ",", "box", "=", "False", ",", "*", "*", "kwargs", ")", ":", "if", "box", ":", "im", "=", "im", ".", "crop", "(", "box", ")", "return", "im"], "idx": 613}
{"url": "cosqa-train-8561", "docstring_tokens": ["Given", "two", "data", "points", "[", "X", "Y", "]", "linearly", "interpolate", "those", "at", "x", "."], "code": "def _linear_interpolation(x, X, Y):\n    \"\"\"Given two data points [X,Y], linearly interpolate those at x.\n    \"\"\"\n    return (Y[1] * (x - X[0]) + Y[0] * (X[1] - x)) / (X[1] - X[0])", "code_tokens": ["def", "_linear_interpolation", "(", "x", ",", "X", ",", "Y", ")", ":", "return", "(", "Y", "[", "1", "]", "*", "(", "x", "-", "X", "[", "0", "]", ")", "+", "Y", "[", "0", "]", "*", "(", "X", "[", "1", "]", "-", "x", ")", ")", "/", "(", "X", "[", "1", "]", "-", "X", "[", "0", "]", ")"], "idx": 1490}
{"url": "cosqa-train-16893", "docstring_tokens": ["Return", "True", "if", "dtype", "is", "a", "numeric", "type", "."], "code": "def is_numeric_dtype(dtype):\n    \"\"\"Return ``True`` if ``dtype`` is a numeric type.\"\"\"\n    dtype = np.dtype(dtype)\n    return np.issubsctype(getattr(dtype, 'base', None), np.number)", "code_tokens": ["def", "is_numeric_dtype", "(", "dtype", ")", ":", "dtype", "=", "np", ".", "dtype", "(", "dtype", ")", "return", "np", ".", "issubsctype", "(", "getattr", "(", "dtype", ",", "'base'", ",", "None", ")", ",", "np", ".", "number", ")"], "idx": 3424}
{"url": "cosqa-train-9999", "docstring_tokens": ["Returns", "a", "character", "delimited", "version", "of", "the", "provided", "list", "as", "a", "Python", "string"], "code": "def delimited(items, character='|'):\n    \"\"\"Returns a character delimited version of the provided list as a Python string\"\"\"\n    return '|'.join(items) if type(items) in (list, tuple, set) else items", "code_tokens": ["def", "delimited", "(", "items", ",", "character", "=", "'|'", ")", ":", "return", "'|'", ".", "join", "(", "items", ")", "if", "type", "(", "items", ")", "in", "(", "list", ",", "tuple", ",", "set", ")", "else", "items"], "idx": 1295}
{"url": "cosqa-train-14154", "docstring_tokens": ["iterator", "for", "JSON", "-", "per", "-", "line", "in", "a", "file", "pattern"], "code": "def json_iter (path):\n    \"\"\"\n    iterator for JSON-per-line in a file pattern\n    \"\"\"\n    with open(path, 'r') as f:\n        for line in f.readlines():\n            yield json.loads(line)", "code_tokens": ["def", "json_iter", "(", "path", ")", ":", "with", "open", "(", "path", ",", "'r'", ")", "as", "f", ":", "for", "line", "in", "f", ".", "readlines", "(", ")", ":", "yield", "json", ".", "loads", "(", "line", ")"], "idx": 983}
{"url": "cosqa-train-10533", "docstring_tokens": ["determines", "whether", "the", "card", "number", "is", "valid", "."], "code": "def is_valid(number):\n    \"\"\"determines whether the card number is valid.\"\"\"\n    n = str(number)\n    if not n.isdigit():\n        return False\n    return int(n[-1]) == get_check_digit(n[:-1])", "code_tokens": ["def", "is_valid", "(", "number", ")", ":", "n", "=", "str", "(", "number", ")", "if", "not", "n", ".", "isdigit", "(", ")", ":", "return", "False", "return", "int", "(", "n", "[", "-", "1", "]", ")", "==", "get_check_digit", "(", "n", "[", ":", "-", "1", "]", ")"], "idx": 357}
{"url": "cosqa-train-392", "docstring_tokens": ["Checks", "if", "value", "can", "be", "part", "of", "binary", "/", "bitwise", "operations", "."], "code": "def isbinary(*args):\n    \"\"\"Checks if value can be part of binary/bitwise operations.\"\"\"\n    return all(map(lambda c: isnumber(c) or isbool(c), args))", "code_tokens": ["def", "isbinary", "(", "*", "args", ")", ":", "return", "all", "(", "map", "(", "lambda", "c", ":", "isnumber", "(", "c", ")", "or", "isbool", "(", "c", ")", ",", "args", ")", ")"], "idx": 371}
{"url": "cosqa-train-13488", "docstring_tokens": ["Remove", "unwanted", "list", "indices", ".", "First", "argument", "is", "the", "list", "of", "indices", "to", "remove", ".", "Other", "elements", "are", "the", "lists", "to", "trim", "."], "code": "def rm_empty_indices(*args):\n    \"\"\"\n    Remove unwanted list indices. First argument is the list\n    of indices to remove. Other elements are the lists\n    to trim.\n    \"\"\"\n    rm_inds = args[0]\n\n    if not rm_inds:\n        return args[1:]\n\n    keep_inds = [i for i in range(len(args[1])) if i not in rm_inds]\n\n    return [[a[i] for i in keep_inds] for a in args[1:]]", "code_tokens": ["def", "rm_empty_indices", "(", "*", "args", ")", ":", "rm_inds", "=", "args", "[", "0", "]", "if", "not", "rm_inds", ":", "return", "args", "[", "1", ":", "]", "keep_inds", "=", "[", "i", "for", "i", "in", "range", "(", "len", "(", "args", "[", "1", "]", ")", ")", "if", "i", "not", "in", "rm_inds", "]", "return", "[", "[", "a", "[", "i", "]", "for", "i", "in", "keep_inds", "]", "for", "a", "in", "args", "[", "1", ":", "]", "]"], "idx": 841}
{"url": "cosqa-train-9403", "docstring_tokens": ["unset", "_instance", "for", "this", "class", "and", "singleton", "parents", "."], "code": "def clear_instance(cls):\n        \"\"\"unset _instance for this class and singleton parents.\n        \"\"\"\n        if not cls.initialized():\n            return\n        for subclass in cls._walk_mro():\n            if isinstance(subclass._instance, cls):\n                # only clear instances that are instances\n                # of the calling class\n                subclass._instance = None", "code_tokens": ["def", "clear_instance", "(", "cls", ")", ":", "if", "not", "cls", ".", "initialized", "(", ")", ":", "return", "for", "subclass", "in", "cls", ".", "_walk_mro", "(", ")", ":", "if", "isinstance", "(", "subclass", ".", "_instance", ",", "cls", ")", ":", "#", "only", "clear", "instances", "that", "are", "instances", "#", "of", "the", "calling", "class", "subclass", ".", "_instance", "=", "None"], "idx": 4238}
{"url": "cosqa-train-14932", "docstring_tokens": ["Calculate", "the", "standard", "error", "of", "a", "."], "code": "def stderr(a):\n    \"\"\"\n    Calculate the standard error of a.\n    \"\"\"\n    return np.nanstd(a) / np.sqrt(sum(np.isfinite(a)))", "code_tokens": ["def", "stderr", "(", "a", ")", ":", "return", "np", ".", "nanstd", "(", "a", ")", "/", "np", ".", "sqrt", "(", "sum", "(", "np", ".", "isfinite", "(", "a", ")", ")", ")"], "idx": 715}
{"url": "cosqa-train-12031", "docstring_tokens": ["Initialize", "python", "List", "with", "capacity", "of", "10", "or", "user", "given", "input", ".", "Python", "List", "type", "is", "a", "dynamic", "array", "so", "we", "have", "to", "restrict", "its", "dynamic", "nature", "to", "make", "it", "work", "like", "a", "static", "array", "."], "code": "def __init__(self, capacity=10):\n        \"\"\"\n        Initialize python List with capacity of 10 or user given input.\n        Python List type is a dynamic array, so we have to restrict its\n        dynamic nature to make it work like a static array.\n        \"\"\"\n        super().__init__()\n        self._array = [None] * capacity\n        self._front = 0\n        self._rear = 0", "code_tokens": ["def", "__init__", "(", "self", ",", "capacity", "=", "10", ")", ":", "super", "(", ")", ".", "__init__", "(", ")", "self", ".", "_array", "=", "[", "None", "]", "*", "capacity", "self", ".", "_front", "=", "0", "self", ".", "_rear", "=", "0"], "idx": 3243}
{"url": "cosqa-train-19288", "docstring_tokens": ["Log", "in", "to", "instagram", "with", "given", "username", "and", "password", "and", "internally", "store", "session", "object", "."], "code": "def login(self, user: str, passwd: str) -> None:\n        \"\"\"Log in to instagram with given username and password and internally store session object.\n\n        :raises InvalidArgumentException: If the provided username does not exist.\n        :raises BadCredentialsException: If the provided password is wrong.\n        :raises ConnectionException: If connection to Instagram failed.\n        :raises TwoFactorAuthRequiredException: First step of 2FA login done, now call :meth:`Instaloader.two_factor_login`.\"\"\"\n        self.context.login(user, passwd)", "code_tokens": ["def", "login", "(", "self", ",", "user", ":", "str", ",", "passwd", ":", "str", ")", "->", "None", ":", "self", ".", "context", ".", "login", "(", "user", ",", "passwd", ")"], "idx": 6158}
{"url": "cosqa-train-6945", "docstring_tokens": ["Return", "the", "shape", "of", "img", "."], "code": "def get_shape(img):\n    \"\"\"Return the shape of img.\n\n    Paramerers\n    -----------\n    img:\n\n    Returns\n    -------\n    shape: tuple\n    \"\"\"\n    if hasattr(img, 'shape'):\n        shape = img.shape\n    else:\n        shape = img.get_data().shape\n    return shape", "code_tokens": ["def", "get_shape", "(", "img", ")", ":", "if", "hasattr", "(", "img", ",", "'shape'", ")", ":", "shape", "=", "img", ".", "shape", "else", ":", "shape", "=", "img", ".", "get_data", "(", ")", ".", "shape", "return", "shape"], "idx": 2021}
{"url": "cosqa-train-16201", "docstring_tokens": ["rotates", "a", "2d", "array", "to", "a", "multiple", "of", "90", "deg", ".", "0", "=", "default", "1", "=", "90", "deg", ".", "cw", "2", "=", "180", "deg", ".", "3", "=", "90", "deg", ".", "ccw"], "code": "def rotateImage(image, angle):\n    \"\"\"\n        rotates a 2d array to a multiple of 90 deg.\n        0 = default\n        1 = 90 deg. cw\n        2 = 180 deg.\n        3 = 90 deg. ccw\n    \"\"\"\n    image = [list(row) for row in image]\n\n    for n in range(angle % 4):\n        image = list(zip(*image[::-1]))\n\n    return image", "code_tokens": ["def", "rotateImage", "(", "image", ",", "angle", ")", ":", "image", "=", "[", "list", "(", "row", ")", "for", "row", "in", "image", "]", "for", "n", "in", "range", "(", "angle", "%", "4", ")", ":", "image", "=", "list", "(", "zip", "(", "*", "image", "[", ":", ":", "-", "1", "]", ")", ")", "return", "image"], "idx": 1993}
{"url": "cosqa-dev-151", "docstring_tokens": ["Return", "the", "location", "of", "the", "static", "data", "directory", "."], "code": "def staticdir():\n    \"\"\"Return the location of the static data directory.\"\"\"\n    root = os.path.abspath(os.path.dirname(__file__))\n    return os.path.join(root, \"static\")", "code_tokens": ["def", "staticdir", "(", ")", ":", "root", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ")", "return", "os", ".", "path", ".", "join", "(", "root", ",", "\"static\"", ")"], "idx": 1813}
{"url": "cosqa-train-10259", "docstring_tokens": ["Adds", "a", "chart", "to", "the", "worksheet", "at", "(", "row", "col", ")", "."], "code": "def add_chart(self, chart, row, col):\n        \"\"\"\n        Adds a chart to the worksheet at (row, col).\n\n        :param xltable.Chart Chart: chart to add to the workbook.\n        :param int row: Row to add the chart at.\n        \"\"\"\n        self.__charts.append((chart, (row, col)))", "code_tokens": ["def", "add_chart", "(", "self", ",", "chart", ",", "row", ",", "col", ")", ":", "self", ".", "__charts", ".", "append", "(", "(", "chart", ",", "(", "row", ",", "col", ")", ")", ")"], "idx": 4433}
{"url": "cosqa-train-9329", "docstring_tokens": ["Convert", "a", "pandas", ".", "Series", "into", "an", "xarray", ".", "DataArray", "."], "code": "def from_series(cls, series):\n        \"\"\"Convert a pandas.Series into an xarray.DataArray.\n\n        If the series's index is a MultiIndex, it will be expanded into a\n        tensor product of one-dimensional coordinates (filling in missing\n        values with NaN). Thus this operation should be the inverse of the\n        `to_series` method.\n        \"\"\"\n        # TODO: add a 'name' parameter\n        name = series.name\n        df = pd.DataFrame({name: series})\n        ds = Dataset.from_dataframe(df)\n        return ds[name]", "code_tokens": ["def", "from_series", "(", "cls", ",", "series", ")", ":", "#", "TODO:", "add", "a", "'name'", "parameter", "name", "=", "series", ".", "name", "df", "=", "pd", ".", "DataFrame", "(", "{", "name", ":", "series", "}", ")", "ds", "=", "Dataset", ".", "from_dataframe", "(", "df", ")", "return", "ds", "[", "name", "]"], "idx": 3319}
{"url": "cosqa-train-17315", "docstring_tokens": ["Generate", "the", "first", "value", "in", "each", "row", "."], "code": "def genfirstvalues(cursor: Cursor, arraysize: int = 1000) \\\n        -> Generator[Any, None, None]:\n    \"\"\"\n    Generate the first value in each row.\n\n    Args:\n        cursor: the cursor\n        arraysize: split fetches into chunks of this many records\n\n    Yields:\n        the first value of each row\n    \"\"\"\n    return (row[0] for row in genrows(cursor, arraysize))", "code_tokens": ["def", "genfirstvalues", "(", "cursor", ":", "Cursor", ",", "arraysize", ":", "int", "=", "1000", ")", "->", "Generator", "[", "Any", ",", "None", ",", "None", "]", ":", "return", "(", "row", "[", "0", "]", "for", "row", "in", "genrows", "(", "cursor", ",", "arraysize", ")", ")"], "idx": 5650}
{"url": "cosqa-train-18487", "docstring_tokens": ["Return", "if", "the", "token", "is", "in", "the", "list", "or", "not", "."], "code": "def contains(self, token: str) -> bool:\n        \"\"\"Return if the token is in the list or not.\"\"\"\n        self._validate_token(token)\n        return token in self", "code_tokens": ["def", "contains", "(", "self", ",", "token", ":", "str", ")", "->", "bool", ":", "self", ".", "_validate_token", "(", "token", ")", "return", "token", "in", "self"], "idx": 5789}
{"url": "cosqa-train-14368", "docstring_tokens": ["Returns", "the", "estimated", "standard", "error", "of", "the", "mean", "(", "sx", "-", "bar", ")", "of", "the", "values", "in", "the", "passed", "list", ".", "sem", "=", "stdev", "/", "sqrt", "(", "n", ")"], "code": "def sem(inlist):\n    \"\"\"\nReturns the estimated standard error of the mean (sx-bar) of the\nvalues in the passed list.  sem = stdev / sqrt(n)\n\nUsage:   lsem(inlist)\n\"\"\"\n    sd = stdev(inlist)\n    n = len(inlist)\n    return sd / math.sqrt(n)", "code_tokens": ["def", "sem", "(", "inlist", ")", ":", "sd", "=", "stdev", "(", "inlist", ")", "n", "=", "len", "(", "inlist", ")", "return", "sd", "/", "math", ".", "sqrt", "(", "n", ")"], "idx": 2315}
{"url": "cosqa-train-12504", "docstring_tokens": ["return", "the", "key", "from", "the", "request"], "code": "def get(key, default=None):\n    \"\"\" return the key from the request\n    \"\"\"\n    data = get_form() or get_query_string()\n    return data.get(key, default)", "code_tokens": ["def", "get", "(", "key", ",", "default", "=", "None", ")", ":", "data", "=", "get_form", "(", ")", "or", "get_query_string", "(", ")", "return", "data", ".", "get", "(", "key", ",", "default", ")"], "idx": 1873}
{"url": "cosqa-train-19234", "docstring_tokens": ["Decorator", "that", "injects", "parsed", "arguments", "into", "a", "view", "function", "or", "method", "."], "code": "def use_kwargs(self, *args, **kwargs) -> typing.Callable:\n        \"\"\"Decorator that injects parsed arguments into a view function or method.\n\n        Receives the same arguments as `webargs.core.Parser.use_kwargs`.\n\n        \"\"\"\n        return super().use_kwargs(*args, **kwargs)", "code_tokens": ["def", "use_kwargs", "(", "self", ",", "*", "args", ",", "*", "*", "kwargs", ")", "->", "typing", ".", "Callable", ":", "return", "super", "(", ")", ".", "use_kwargs", "(", "*", "args", ",", "*", "*", "kwargs", ")"], "idx": 6175}
{"url": "cosqa-train-19751", "docstring_tokens": ["Make", "sure", "thre", "is", "no", "whitespace", "in", "the", "given", "string", ".", "Will", "raise", "a", "ValueError", "if", "whitespace", "is", "detected"], "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": ["def", "_check_whitespace", "(", "string", ")", ":", "if", "string", ".", "count", "(", "'", "'", ")", "+", "string", ".", "count", "(", "'\\t'", ")", "+", "string", ".", "count", "(", "'\\n'", ")", ">", "0", ":", "raise", "ValueError", "(", "INSTRUCTION_HAS_WHITESPACE", ")"], "idx": 5747}
{"url": "cosqa-train-7177", "docstring_tokens": ["Determine", "if", "end", "-", "of", "-", "file", "is", "reached", "for", "file", "fd", "."], "code": "def eof(fd):\n    \"\"\"Determine if end-of-file is reached for file fd.\"\"\"\n    b = fd.read(1)\n    end = len(b) == 0\n    if not end:\n        curpos = fd.tell()\n        fd.seek(curpos - 1)\n    return end", "code_tokens": ["def", "eof", "(", "fd", ")", ":", "b", "=", "fd", ".", "read", "(", "1", ")", "end", "=", "len", "(", "b", ")", "==", "0", "if", "not", "end", ":", "curpos", "=", "fd", ".", "tell", "(", ")", "fd", ".", "seek", "(", "curpos", "-", "1", ")", "return", "end"], "idx": 2556}
{"url": "cosqa-train-15780", "docstring_tokens": ["Clears", "globals", "and", "reloads", "modules"], "code": "def clear_globals_reload_modules(self):\n        \"\"\"Clears globals and reloads modules\"\"\"\n\n        self.code_array.clear_globals()\n        self.code_array.reload_modules()\n\n        # Clear result cache\n        self.code_array.result_cache.clear()", "code_tokens": ["def", "clear_globals_reload_modules", "(", "self", ")", ":", "self", ".", "code_array", ".", "clear_globals", "(", ")", "self", ".", "code_array", ".", "reload_modules", "(", ")", "#", "Clear", "result", "cache", "self", ".", "code_array", ".", "result_cache", ".", "clear", "(", ")"], "idx": 1680}
{"url": "cosqa-train-2985", "docstring_tokens": ["Extract", "a", "raw_connection", "and", "determine", "if", "it", "should", "be", "automatically", "closed", "."], "code": "def raw_connection_from(engine_or_conn):\n    \"\"\"Extract a raw_connection and determine if it should be automatically closed.\n\n    Only connections opened by this package will be closed automatically.\n    \"\"\"\n    if hasattr(engine_or_conn, 'cursor'):\n        return engine_or_conn, False\n    if hasattr(engine_or_conn, 'connection'):\n        return engine_or_conn.connection, False\n    return engine_or_conn.raw_connection(), True", "code_tokens": ["def", "raw_connection_from", "(", "engine_or_conn", ")", ":", "if", "hasattr", "(", "engine_or_conn", ",", "'cursor'", ")", ":", "return", "engine_or_conn", ",", "False", "if", "hasattr", "(", "engine_or_conn", ",", "'connection'", ")", ":", "return", "engine_or_conn", ".", "connection", ",", "False", "return", "engine_or_conn", ".", "raw_connection", "(", ")", ",", "True"], "idx": 2143}
{"url": "cosqa-train-8181", "docstring_tokens": ["Select", "rows", "where", "the", "given", "field", "is", "None", "."], "code": "def selectnone(table, field, complement=False):\n    \"\"\"Select rows where the given field is `None`.\"\"\"\n\n    return select(table, field, lambda v: v is None, complement=complement)", "code_tokens": ["def", "selectnone", "(", "table", ",", "field", ",", "complement", "=", "False", ")", ":", "return", "select", "(", "table", ",", "field", ",", "lambda", "v", ":", "v", "is", "None", ",", "complement", "=", "complement", ")"], "idx": 670}
{"url": "cosqa-train-8055", "docstring_tokens": ["Get", "rid", "of", "all", "axis", "ticks", "lines", "etc", "."], "code": "def axes_off(ax):\n    \"\"\"Get rid of all axis ticks, lines, etc.\n    \"\"\"\n    ax.set_frame_on(False)\n    ax.axes.get_yaxis().set_visible(False)\n    ax.axes.get_xaxis().set_visible(False)", "code_tokens": ["def", "axes_off", "(", "ax", ")", ":", "ax", ".", "set_frame_on", "(", "False", ")", "ax", ".", "axes", ".", "get_yaxis", "(", ")", ".", "set_visible", "(", "False", ")", "ax", ".", "axes", ".", "get_xaxis", "(", ")", ".", "set_visible", "(", "False", ")"], "idx": 2111}
{"url": "cosqa-train-8376", "docstring_tokens": ["Return", "True", "if", "object", "is", "defined"], "code": "def is_defined(self, objtxt, force_import=False):\n        \"\"\"Return True if object is defined\"\"\"\n        return self.interpreter.is_defined(objtxt, force_import)", "code_tokens": ["def", "is_defined", "(", "self", ",", "objtxt", ",", "force_import", "=", "False", ")", ":", "return", "self", ".", "interpreter", ".", "is_defined", "(", "objtxt", ",", "force_import", ")"], "idx": 202}
{"url": "cosqa-train-7468", "docstring_tokens": ["Return", "a", "version", "of", "the", "query", "string", "with", "the", "_e", "_k", "and", "_s", "values", "removed", "."], "code": "def filter_query_string(query):\n    \"\"\"\n        Return a version of the query string with the _e, _k and _s values\n        removed.\n    \"\"\"\n    return '&'.join([q for q in query.split('&')\n        if not (q.startswith('_k=') or q.startswith('_e=') or q.startswith('_s'))])", "code_tokens": ["def", "filter_query_string", "(", "query", ")", ":", "return", "'&'", ".", "join", "(", "[", "q", "for", "q", "in", "query", ".", "split", "(", "'&'", ")", "if", "not", "(", "q", ".", "startswith", "(", "'_k='", ")", "or", "q", ".", "startswith", "(", "'_e='", ")", "or", "q", ".", "startswith", "(", "'_s'", ")", ")", "]", ")"], "idx": 2871}
{"url": "cosqa-train-18350", "docstring_tokens": ["Discover", "the", "current", "time", "zone", "and", "it", "s", "standard", "string", "representation", "(", "for", "source", "{", "d", "}", ")", "."], "code": "def get_timezone() -> Tuple[datetime.tzinfo, str]:\n    \"\"\"Discover the current time zone and it's standard string representation (for source{d}).\"\"\"\n    dt = get_datetime_now().astimezone()\n    tzstr = dt.strftime(\"%z\")\n    tzstr = tzstr[:-2] + \":\" + tzstr[-2:]\n    return dt.tzinfo, tzstr", "code_tokens": ["def", "get_timezone", "(", ")", "->", "Tuple", "[", "datetime", ".", "tzinfo", ",", "str", "]", ":", "dt", "=", "get_datetime_now", "(", ")", ".", "astimezone", "(", ")", "tzstr", "=", "dt", ".", "strftime", "(", "\"%z\"", ")", "tzstr", "=", "tzstr", "[", ":", "-", "2", "]", "+", "\":\"", "+", "tzstr", "[", "-", "2", ":", "]", "return", "dt", ".", "tzinfo", ",", "tzstr"], "idx": 5552}
{"url": "cosqa-train-2677", "docstring_tokens": ["Strips", "trailing", "whitespace", "from", "string", "lowercases", "it", "and", "replaces", "spaces", "with", "underscores"], "code": "def normalise_string(string):\n    \"\"\" Strips trailing whitespace from string, lowercases it and replaces\n        spaces with underscores\n    \"\"\"\n    string = (string.strip()).lower()\n    return re.sub(r'\\W+', '_', string)", "code_tokens": ["def", "normalise_string", "(", "string", ")", ":", "string", "=", "(", "string", ".", "strip", "(", ")", ")", ".", "lower", "(", ")", "return", "re", ".", "sub", "(", "r'\\W+'", ",", "'_'", ",", "string", ")"], "idx": 1117}
{"url": "cosqa-train-12961", "docstring_tokens": ["transpose", "matrix"], "code": "def transpose(table):\n    \"\"\"\n    transpose matrix\n    \"\"\"\n    t = []\n    for i in range(0, len(table[0])):\n        t.append([row[i] for row in table])\n    return t", "code_tokens": ["def", "transpose", "(", "table", ")", ":", "t", "=", "[", "]", "for", "i", "in", "range", "(", "0", ",", "len", "(", "table", "[", "0", "]", ")", ")", ":", "t", ".", "append", "(", "[", "row", "[", "i", "]", "for", "row", "in", "table", "]", ")", "return", "t"], "idx": 2681}
{"url": "cosqa-train-16940", "docstring_tokens": ["Checks", "if", "two", "images", "have", "the", "same", "height", "and", "width", "(", "and", "optionally", "channels", ")", "."], "code": "def is_same_shape(self, other_im, check_channels=False):\n        \"\"\" Checks if two images have the same height and width (and optionally channels).\n\n        Parameters\n        ----------\n        other_im : :obj:`Image`\n            image to compare\n        check_channels : bool\n            whether or not to check equality of the channels\n\n        Returns\n        -------\n        bool\n            True if the images are the same shape, False otherwise\n        \"\"\"\n        if self.height == other_im.height and self.width == other_im.width:\n            if check_channels and self.channels != other_im.channels:\n                return False\n            return True\n        return False", "code_tokens": ["def", "is_same_shape", "(", "self", ",", "other_im", ",", "check_channels", "=", "False", ")", ":", "if", "self", ".", "height", "==", "other_im", ".", "height", "and", "self", ".", "width", "==", "other_im", ".", "width", ":", "if", "check_channels", "and", "self", ".", "channels", "!=", "other_im", ".", "channels", ":", "return", "False", "return", "True", "return", "False"], "idx": 205}
{"url": "cosqa-train-12042", "docstring_tokens": ["Check", "if", "string", "could", "be", "a", "valid", "python", "identifier"], "code": "def is_identifier(string):\n    \"\"\"Check if string could be a valid python identifier\n\n    :param string: string to be tested\n    :returns: True if string can be a python identifier, False otherwise\n    :rtype: bool\n    \"\"\"\n    matched = PYTHON_IDENTIFIER_RE.match(string)\n    return bool(matched) and not keyword.iskeyword(string)", "code_tokens": ["def", "is_identifier", "(", "string", ")", ":", "matched", "=", "PYTHON_IDENTIFIER_RE", ".", "match", "(", "string", ")", "return", "bool", "(", "matched", ")", "and", "not", "keyword", ".", "iskeyword", "(", "string", ")"], "idx": 167}
{"url": "cosqa-train-6684", "docstring_tokens": ["Remove", "all", "HTTP", "/", "1", ".", "1", "Hop", "-", "by", "-", "Hop", "headers", "from", "a", "list", "or", ":", "class", ":", "Headers", "object", ".", "This", "operation", "works", "in", "-", "place", "."], "code": "def remove_hop_by_hop_headers(headers):\n    \"\"\"Remove all HTTP/1.1 \"Hop-by-Hop\" headers from a list or\n    :class:`Headers` object.  This operation works in-place.\n\n    .. versionadded:: 0.5\n\n    :param headers: a list or :class:`Headers` object.\n    \"\"\"\n    headers[:] = [\n        (key, value) for key, value in headers if not is_hop_by_hop_header(key)\n    ]", "code_tokens": ["def", "remove_hop_by_hop_headers", "(", "headers", ")", ":", "headers", "[", ":", "]", "=", "[", "(", "key", ",", "value", ")", "for", "key", ",", "value", "in", "headers", "if", "not", "is_hop_by_hop_header", "(", "key", ")", "]"], "idx": 3548}
{"url": "cosqa-train-8524", "docstring_tokens": ["Convert", "from", "whatever", "is", "given", "to", "a", "list", "of", "scalars", "for", "the", "lookup_field", "."], "code": "def coerce(self, value):\n        \"\"\"Convert from whatever is given to a list of scalars for the lookup_field.\"\"\"\n        if isinstance(value, dict):\n            value = [value]\n        if not isiterable_notstring(value):\n            value = [value]\n        return [coerce_single_instance(self.lookup_field, v) for v in value]", "code_tokens": ["def", "coerce", "(", "self", ",", "value", ")", ":", "if", "isinstance", "(", "value", ",", "dict", ")", ":", "value", "=", "[", "value", "]", "if", "not", "isiterable_notstring", "(", "value", ")", ":", "value", "=", "[", "value", "]", "return", "[", "coerce_single_instance", "(", "self", ".", "lookup_field", ",", "v", ")", "for", "v", "in", "value", "]"], "idx": 1216}
{"url": "cosqa-train-12396", "docstring_tokens": ["Return", "random", "lognormal", "variates", "."], "code": "def rlognormal(mu, tau, size=None):\n    \"\"\"\n    Return random lognormal variates.\n    \"\"\"\n\n    return np.random.lognormal(mu, np.sqrt(1. / tau), size)", "code_tokens": ["def", "rlognormal", "(", "mu", ",", "tau", ",", "size", "=", "None", ")", ":", "return", "np", ".", "random", ".", "lognormal", "(", "mu", ",", "np", ".", "sqrt", "(", "1.", "/", "tau", ")", ",", "size", ")"], "idx": 551}
{"url": "cosqa-train-10196", "docstring_tokens": ["Print", "training", "time", "at", "end", "of", "training"], "code": "def on_train_end(self, logs):\n        \"\"\" Print training time at end of training \"\"\"\n        duration = timeit.default_timer() - self.train_start\n        print('done, took {:.3f} seconds'.format(duration))", "code_tokens": ["def", "on_train_end", "(", "self", ",", "logs", ")", ":", "duration", "=", "timeit", ".", "default_timer", "(", ")", "-", "self", ".", "train_start", "print", "(", "'done,", "took", "{:.3f}", "seconds'", ".", "format", "(", "duration", ")", ")"], "idx": 4162}
{"url": "cosqa-train-9031", "docstring_tokens": ["Attempt", "to", "guess", "the", "title", "from", "the", "filename"], "code": "def guess_title(basename):\n    \"\"\" Attempt to guess the title from the filename \"\"\"\n\n    base, _ = os.path.splitext(basename)\n    return re.sub(r'[ _-]+', r' ', base).title()", "code_tokens": ["def", "guess_title", "(", "basename", ")", ":", "base", ",", "_", "=", "os", ".", "path", ".", "splitext", "(", "basename", ")", "return", "re", ".", "sub", "(", "r'[", "_-]+'", ",", "r'", "'", ",", "base", ")", ".", "title", "(", ")"], "idx": 3790}
{"url": "cosqa-train-12821", "docstring_tokens": ["print", "the", "message", "to", "the", "predefined", "log", "file", "without", "newline"], "code": "def log_no_newline(self, msg):\n      \"\"\" print the message to the predefined log file without newline \"\"\"\n      self.print2file(self.logfile, False, False, msg)", "code_tokens": ["def", "log_no_newline", "(", "self", ",", "msg", ")", ":", "self", ".", "print2file", "(", "self", ".", "logfile", ",", "False", ",", "False", ",", "msg", ")"], "idx": 2091}
{"url": "cosqa-train-19736", "docstring_tokens": ["Reads", "text", "file", "contents"], "code": "def read_text_from_file(path: str) -> str:\n    \"\"\" Reads text file contents \"\"\"\n    with open(path) as text_file:\n        content = text_file.read()\n\n    return content", "code_tokens": ["def", "read_text_from_file", "(", "path", ":", "str", ")", "->", "str", ":", "with", "open", "(", "path", ")", "as", "text_file", ":", "content", "=", "text_file", ".", "read", "(", ")", "return", "content"], "idx": 5554}
{"url": "cosqa-train-3384", "docstring_tokens": ["Emulate", "what", "a", "Python", "set", "()", "does", "but", "keeping", "the", "element", "s", "order", "."], "code": "def remove_duplicates(lst):\n    \"\"\"\n    Emulate what a Python ``set()`` does, but keeping the element's order.\n    \"\"\"\n    dset = set()\n    return [l for l in lst if l not in dset and not dset.add(l)]", "code_tokens": ["def", "remove_duplicates", "(", "lst", ")", ":", "dset", "=", "set", "(", ")", "return", "[", "l", "for", "l", "in", "lst", "if", "l", "not", "in", "dset", "and", "not", "dset", ".", "add", "(", "l", ")", "]"], "idx": 278}
{"url": "cosqa-train-7235", "docstring_tokens": ["Takes", "a", "list", "of", "point", "objects", "(", "which", "must", "have", "x", "and", "y", "fields", ")", ".", "Returns", "a", "list", "of", "3", "-", "tuples", ":", "the", "indices", "of", "the", "points", "that", "form", "a", "Delaunay", "triangle", "."], "code": "def computeDelaunayTriangulation(points):\n    \"\"\" Takes a list of point objects (which must have x and y fields).\n        Returns a list of 3-tuples: the indices of the points that form a\n        Delaunay triangle.\n    \"\"\"\n    siteList = SiteList(points)\n    context  = Context()\n    context.triangulate = True\n    voronoi(siteList,context)\n    return context.triangles", "code_tokens": ["def", "computeDelaunayTriangulation", "(", "points", ")", ":", "siteList", "=", "SiteList", "(", "points", ")", "context", "=", "Context", "(", ")", "context", ".", "triangulate", "=", "True", "voronoi", "(", "siteList", ",", "context", ")", "return", "context", ".", "triangles"], "idx": 386}
{"url": "cosqa-train-19075", "docstring_tokens": ["Check", "whether", "the", "provided", "array", "or", "dtype", "is", "of", "the", "string", "dtype", "."], "code": "def is_string_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    # TODO: gh-15585: consider making the checks stricter.\n    def condition(dtype):\n        return dtype.kind in ('O', 'S', 'U') and not is_period_dtype(dtype)\n    return _is_dtype(arr_or_dtype, condition)", "code_tokens": ["def", "is_string_dtype", "(", "arr_or_dtype", ")", ":", "#", "TODO:", "gh-15585:", "consider", "making", "the", "checks", "stricter.", "def", "condition", "(", "dtype", ")", ":", "return", "dtype", ".", "kind", "in", "(", "'O'", ",", "'S'", ",", "'U'", ")", "and", "not", "is_period_dtype", "(", "dtype", ")", "return", "_is_dtype", "(", "arr_or_dtype", ",", "condition", ")"], "idx": 6152}
{"url": "cosqa-train-12873", "docstring_tokens": ["Attempts", "to", "convert", "given", "object", "to", "a", "string", "object"], "code": "def to_str(obj):\n    \"\"\"Attempts to convert given object to a string object\n    \"\"\"\n    if not isinstance(obj, str) and PY3 and isinstance(obj, bytes):\n        obj = obj.decode('utf-8')\n    return obj if isinstance(obj, string_types) else str(obj)", "code_tokens": ["def", "to_str", "(", "obj", ")", ":", "if", "not", "isinstance", "(", "obj", ",", "str", ")", "and", "PY3", "and", "isinstance", "(", "obj", ",", "bytes", ")", ":", "obj", "=", "obj", ".", "decode", "(", "'utf-8'", ")", "return", "obj", "if", "isinstance", "(", "obj", ",", "string_types", ")", "else", "str", "(", "obj", ")"], "idx": 2806}
{"url": "cosqa-train-11786", "docstring_tokens": ["Utility", "function", "to", "remove", "duplicates", "from", "a", "list", ":", "param", "seq", ":", "The", "sequence", "(", "list", ")", "to", "deduplicate", ":", "return", ":", "A", "list", "with", "original", "duplicates", "removed"], "code": "def dedupe_list(seq):\n    \"\"\"\n    Utility function to remove duplicates from a list\n    :param seq: The sequence (list) to deduplicate\n    :return: A list with original duplicates removed\n    \"\"\"\n    seen = set()\n    return [x for x in seq if not (x in seen or seen.add(x))]", "code_tokens": ["def", "dedupe_list", "(", "seq", ")", ":", "seen", "=", "set", "(", ")", "return", "[", "x", "for", "x", "in", "seq", "if", "not", "(", "x", "in", "seen", "or", "seen", ".", "add", "(", "x", ")", ")", "]"], "idx": 1450}
{"url": "cosqa-train-9779", "docstring_tokens": [""], "code": "def smooth_array(array, amount=1):\n    \"\"\"\n\n    Returns the nearest-neighbor (+/- amount) smoothed array.\n    This does not modify the array or slice off the funny end points.\n\n    \"\"\"\n    if amount==0: return array\n\n    # we have to store the old values in a temp array to keep the\n    # smoothing from affecting the smoothing\n    new_array = _n.array(array)\n\n    for n in range(len(array)):\n        new_array[n] = smooth(array, n, amount)\n\n    return new_array", "code_tokens": ["def", "smooth_array", "(", "array", ",", "amount", "=", "1", ")", ":", "if", "amount", "==", "0", ":", "return", "array", "#", "we", "have", "to", "store", "the", "old", "values", "in", "a", "temp", "array", "to", "keep", "the", "#", "smoothing", "from", "affecting", "the", "smoothing", "new_array", "=", "_n", ".", "array", "(", "array", ")", "for", "n", "in", "range", "(", "len", "(", "array", ")", ")", ":", "new_array", "[", "n", "]", "=", "smooth", "(", "array", ",", "n", ",", "amount", ")", "return", "new_array"], "idx": 2378}
{"url": "cosqa-train-19064", "docstring_tokens": ["Within", "the", "dictionary", "d", "find", "a", "key", "that", "matches", "(", "in", "case", "-", "insensitive", "fashion", ")", "the", "key", "k", "and", "return", "it", "(", "or", "None", "if", "there", "isn", "t", "one", ")", "."], "code": "def get_case_insensitive_dict_key(d: Dict, k: str) -> Optional[str]:\n    \"\"\"\n    Within the dictionary ``d``, find a key that matches (in case-insensitive\n    fashion) the key ``k``, and return it (or ``None`` if there isn't one).\n    \"\"\"\n    for key in d.keys():\n        if k.lower() == key.lower():\n            return key\n    return None", "code_tokens": ["def", "get_case_insensitive_dict_key", "(", "d", ":", "Dict", ",", "k", ":", "str", ")", "->", "Optional", "[", "str", "]", ":", "for", "key", "in", "d", ".", "keys", "(", ")", ":", "if", "k", ".", "lower", "(", ")", "==", "key", ".", "lower", "(", ")", ":", "return", "key", "return", "None"], "idx": 5951}
{"url": "cosqa-train-5715", "docstring_tokens": ["Sorting", "logic", "for", "Quantity", "objects", "."], "code": "def sort_func(self, key):\n        \"\"\"Sorting logic for `Quantity` objects.\"\"\"\n        if key == self._KEYS.VALUE:\n            return 'aaa'\n        if key == self._KEYS.SOURCE:\n            return 'zzz'\n        return key", "code_tokens": ["def", "sort_func", "(", "self", ",", "key", ")", ":", "if", "key", "==", "self", ".", "_KEYS", ".", "VALUE", ":", "return", "'aaa'", "if", "key", "==", "self", ".", "_KEYS", ".", "SOURCE", ":", "return", "'zzz'", "return", "key"], "idx": 3265}
{"url": "cosqa-train-12021", "docstring_tokens": [""], "code": "def _index_ordering(redshift_list):\n        \"\"\"\n\n        :param redshift_list: list of redshifts\n        :return: indexes in acending order to be evaluated (from z=0 to z=z_source)\n        \"\"\"\n        redshift_list = np.array(redshift_list)\n        sort_index = np.argsort(redshift_list)\n        return sort_index", "code_tokens": ["def", "_index_ordering", "(", "redshift_list", ")", ":", "redshift_list", "=", "np", ".", "array", "(", "redshift_list", ")", "sort_index", "=", "np", ".", "argsort", "(", "redshift_list", ")", "return", "sort_index"], "idx": 2034}
{"url": "cosqa-dev-261", "docstring_tokens": ["Print", "a", "colored", "string", "to", "the", "target", "handle", "."], "code": "def cprint(string, fg=None, bg=None, end='\\n', target=sys.stdout):\n    \"\"\"Print a colored string to the target handle.\n\n    fg and bg specify foreground- and background colors, respectively. The\n    remaining keyword arguments are the same as for Python's built-in print\n    function. Colors are returned to their defaults before the function\n    returns.\n\n    \"\"\"\n    _color_manager.set_color(fg, bg)\n    target.write(string + end)\n    target.flush()  # Needed for Python 3.x\n    _color_manager.set_defaults()", "code_tokens": ["def", "cprint", "(", "string", ",", "fg", "=", "None", ",", "bg", "=", "None", ",", "end", "=", "'\\n'", ",", "target", "=", "sys", ".", "stdout", ")", ":", "_color_manager", ".", "set_color", "(", "fg", ",", "bg", ")", "target", ".", "write", "(", "string", "+", "end", ")", "target", ".", "flush", "(", ")", "#", "Needed", "for", "Python", "3.x", "_color_manager", ".", "set_defaults", "(", ")"], "idx": 1026}
{"url": "cosqa-train-18586", "docstring_tokens": ["Are", "two", "indexes", "equal?", "Checks", "by", "comparing", "str", "()", "versions", "of", "them", ".", "(", "AM", "UNSURE", "IF", "THIS", "IS", "ENOUGH", ".", ")"], "code": "def indexes_equal(a: Index, b: Index) -> bool:\n    \"\"\"\n    Are two indexes equal? Checks by comparing ``str()`` versions of them.\n    (AM UNSURE IF THIS IS ENOUGH.)\n    \"\"\"\n    return str(a) == str(b)", "code_tokens": ["def", "indexes_equal", "(", "a", ":", "Index", ",", "b", ":", "Index", ")", "->", "bool", ":", "return", "str", "(", "a", ")", "==", "str", "(", "b", ")"], "idx": 5584}
{"url": "cosqa-train-14703", "docstring_tokens": ["Check", "if", "file", "is", "a", "regular", "file", "and", "is", "readable", "."], "code": "def is_readable(filename):\n    \"\"\"Check if file is a regular file and is readable.\"\"\"\n    return os.path.isfile(filename) and os.access(filename, os.R_OK)", "code_tokens": ["def", "is_readable", "(", "filename", ")", ":", "return", "os", ".", "path", ".", "isfile", "(", "filename", ")", "and", "os", ".", "access", "(", "filename", ",", "os", ".", "R_OK", ")"], "idx": 2445}
{"url": "cosqa-train-12468", "docstring_tokens": ["Natural", "log", "of", "scipy", "norm", "function", "truncated", "at", "zero"], "code": "def ln_norm(x, mu, sigma=1.0):\n    \"\"\" Natural log of scipy norm function truncated at zero \"\"\"\n    return np.log(stats.norm(loc=mu, scale=sigma).pdf(x))", "code_tokens": ["def", "ln_norm", "(", "x", ",", "mu", ",", "sigma", "=", "1.0", ")", ":", "return", "np", ".", "log", "(", "stats", ".", "norm", "(", "loc", "=", "mu", ",", "scale", "=", "sigma", ")", ".", "pdf", "(", "x", ")", ")"], "idx": 1336}
{"url": "cosqa-train-7115", "docstring_tokens": ["Ensure", "a", "a", "file", "exists", "and", "if", "not", "make", "the", "relevant", "path"], "code": "def ensure_dir(f):\n    \"\"\" Ensure a a file exists and if not make the relevant path \"\"\"\n    d = os.path.dirname(f)\n    if not os.path.exists(d):\n        os.makedirs(d)", "code_tokens": ["def", "ensure_dir", "(", "f", ")", ":", "d", "=", "os", ".", "path", ".", "dirname", "(", "f", ")", "if", "not", "os", ".", "path", ".", "exists", "(", "d", ")", ":", "os", ".", "makedirs", "(", "d", ")"], "idx": 3678}
{"url": "cosqa-train-13835", "docstring_tokens": ["Redirect", "standard", "out", "to", "file", "."], "code": "def redirect_output(fileobj):\n    \"\"\"Redirect standard out to file.\"\"\"\n    old = sys.stdout\n    sys.stdout = fileobj\n    try:\n        yield fileobj\n    finally:\n        sys.stdout = old", "code_tokens": ["def", "redirect_output", "(", "fileobj", ")", ":", "old", "=", "sys", ".", "stdout", "sys", ".", "stdout", "=", "fileobj", "try", ":", "yield", "fileobj", "finally", ":", "sys", ".", "stdout", "=", "old"], "idx": 1485}
{"url": "cosqa-train-8422", "docstring_tokens": ["Close", "connection", "with", "the", "database"], "code": "def close_database_session(session):\n    \"\"\"Close connection with the database\"\"\"\n\n    try:\n        session.close()\n    except OperationalError as e:\n        raise DatabaseError(error=e.orig.args[1], code=e.orig.args[0])", "code_tokens": ["def", "close_database_session", "(", "session", ")", ":", "try", ":", "session", ".", "close", "(", ")", "except", "OperationalError", "as", "e", ":", "raise", "DatabaseError", "(", "error", "=", "e", ".", "orig", ".", "args", "[", "1", "]", ",", "code", "=", "e", ".", "orig", ".", "args", "[", "0", "]", ")"], "idx": 4030}
{"url": "cosqa-train-13895", "docstring_tokens": ["Pull", "the", "value", "from", "the", "cookiejar", "."], "code": "def parse_cookies(self, req, name, field):\n        \"\"\"Pull the value from the cookiejar.\"\"\"\n        return core.get_value(req.COOKIES, name, field)", "code_tokens": ["def", "parse_cookies", "(", "self", ",", "req", ",", "name", ",", "field", ")", ":", "return", "core", ".", "get_value", "(", "req", ".", "COOKIES", ",", "name", ",", "field", ")"], "idx": 3111}
{"url": "cosqa-train-13084", "docstring_tokens": ["Return", "the", "unique", "elements", "of", "a", "collection", "even", "if", "those", "elements", "are", "unhashable", "and", "unsortable", "like", "dicts", "and", "sets"], "code": "def unique(seq):\n    \"\"\"Return the unique elements of a collection even if those elements are\n       unhashable and unsortable, like dicts and sets\"\"\"\n    cleaned = []\n    for each in seq:\n        if each not in cleaned:\n            cleaned.append(each)\n    return cleaned", "code_tokens": ["def", "unique", "(", "seq", ")", ":", "cleaned", "=", "[", "]", "for", "each", "in", "seq", ":", "if", "each", "not", "in", "cleaned", ":", "cleaned", ".", "append", "(", "each", ")", "return", "cleaned"], "idx": 581}
{"url": "cosqa-train-11101", "docstring_tokens": ["Saves", "the", "dictionary", "in", "json", "format", ":", "param", "fname", ":", "file", "to", "save", "to"], "code": "def save(self, fname):\n        \"\"\" Saves the dictionary in json format\n        :param fname: file to save to\n        \"\"\"\n        with open(fname, 'wb') as f:\n            json.dump(self, f)", "code_tokens": ["def", "save", "(", "self", ",", "fname", ")", ":", "with", "open", "(", "fname", ",", "'wb'", ")", "as", "f", ":", "json", ".", "dump", "(", "self", ",", "f", ")"], "idx": 686}
{"url": "cosqa-train-13837", "docstring_tokens": ["Redirect", "the", "stdout"], "code": "def redirect_stdout(new_stdout):\n    \"\"\"Redirect the stdout\n\n    Args:\n        new_stdout (io.StringIO): New stdout to use instead\n    \"\"\"\n    old_stdout, sys.stdout = sys.stdout, new_stdout\n    try:\n        yield None\n    finally:\n        sys.stdout = old_stdout", "code_tokens": ["def", "redirect_stdout", "(", "new_stdout", ")", ":", "old_stdout", ",", "sys", ".", "stdout", "=", "sys", ".", "stdout", ",", "new_stdout", "try", ":", "yield", "None", "finally", ":", "sys", ".", "stdout", "=", "old_stdout"], "idx": 1386}
{"url": "cosqa-train-16713", "docstring_tokens": ["Apply", "2to3", "tool", "(", "Python2", "to", "Python3", "conversion", "tool", ")", "to", "Python", "sources", "."], "code": "def command_py2to3(args):\n    \"\"\"\n    Apply '2to3' tool (Python2 to Python3 conversion tool) to Python sources.\n    \"\"\"\n    from lib2to3.main import main\n    sys.exit(main(\"lib2to3.fixes\", args=args.sources))", "code_tokens": ["def", "command_py2to3", "(", "args", ")", ":", "from", "lib2to3", ".", "main", "import", "main", "sys", ".", "exit", "(", "main", "(", "\"lib2to3.fixes\"", ",", "args", "=", "args", ".", "sources", ")", ")"], "idx": 1469}
{"url": "cosqa-train-18400", "docstring_tokens": ["Skip", "a", "section"], "code": "def _skip_section(self):\n        \"\"\"Skip a section\"\"\"\n        self._last = self._f.readline()\n        while len(self._last) > 0 and len(self._last[0].strip()) == 0:\n            self._last = self._f.readline()", "code_tokens": ["def", "_skip_section", "(", "self", ")", ":", "self", ".", "_last", "=", "self", ".", "_f", ".", "readline", "(", ")", "while", "len", "(", "self", ".", "_last", ")", ">", "0", "and", "len", "(", "self", ".", "_last", "[", "0", "]", ".", "strip", "(", ")", ")", "==", "0", ":", "self", ".", "_last", "=", "self", ".", "_f", ".", "readline", "(", ")"], "idx": 5576}
{"url": "cosqa-train-2457", "docstring_tokens": ["Returns", "the", "name", "of", "the", "current", "git", "branch"], "code": "def get_git_branch(git_path='git'):\n    \"\"\"Returns the name of the current git branch\n    \"\"\"\n    branch_match = call((git_path, 'rev-parse', '--symbolic-full-name', 'HEAD'))\n    if branch_match == \"HEAD\":\n        return None\n    else:\n        return os.path.basename(branch_match)", "code_tokens": ["def", "get_git_branch", "(", "git_path", "=", "'git'", ")", ":", "branch_match", "=", "call", "(", "(", "git_path", ",", "'rev-parse'", ",", "'--symbolic-full-name'", ",", "'HEAD'", ")", ")", "if", "branch_match", "==", "\"HEAD\"", ":", "return", "None", "else", ":", "return", "os", ".", "path", ".", "basename", "(", "branch_match", ")"], "idx": 1869}
{"url": "cosqa-train-6845", "docstring_tokens": ["Check", "if", "a", "username", "/", "password", "combination", "is", "valid", "."], "code": "def check_auth(email, password):\n    \"\"\"Check if a username/password combination is valid.\n    \"\"\"\n    try:\n        user = User.get(User.email == email)\n    except User.DoesNotExist:\n        return False\n    return password == user.password", "code_tokens": ["def", "check_auth", "(", "email", ",", "password", ")", ":", "try", ":", "user", "=", "User", ".", "get", "(", "User", ".", "email", "==", "email", ")", "except", "User", ".", "DoesNotExist", ":", "return", "False", "return", "password", "==", "user", ".", "password"], "idx": 3593}
{"url": "cosqa-train-4863", "docstring_tokens": ["Reads", "the", "date", "from", "a", "string", "in", "the", "format", "YYYY", "/", "MM", "/", "DD", "and", "returns", ":", "class", ":", "datetime", ".", "date"], "code": "def _read_date_from_string(str1):\n    \"\"\"\n    Reads the date from a string in the format YYYY/MM/DD and returns\n    :class: datetime.date\n    \"\"\"\n    full_date = [int(x) for x in str1.split('/')]\n    return datetime.date(full_date[0], full_date[1], full_date[2])", "code_tokens": ["def", "_read_date_from_string", "(", "str1", ")", ":", "full_date", "=", "[", "int", "(", "x", ")", "for", "x", "in", "str1", ".", "split", "(", "'/'", ")", "]", "return", "datetime", ".", "date", "(", "full_date", "[", "0", "]", ",", "full_date", "[", "1", "]", ",", "full_date", "[", "2", "]", ")"], "idx": 571}
{"url": "cosqa-train-13090", "docstring_tokens": ["Find", "rightmost", "value", "less", "than", "or", "equal", "to", "x", "."], "code": "def find_le(a, x):\n    \"\"\"Find rightmost value less than or equal to x.\"\"\"\n    i = bs.bisect_right(a, x)\n    if i: return i - 1\n    raise ValueError", "code_tokens": ["def", "find_le", "(", "a", ",", "x", ")", ":", "i", "=", "bs", ".", "bisect_right", "(", "a", ",", "x", ")", "if", "i", ":", "return", "i", "-", "1", "raise", "ValueError"], "idx": 612}
{"url": "cosqa-train-7948", "docstring_tokens": ["writes", "the", "line", "and", "count", "newlines", "after", "the", "line"], "code": "def write_line(self, line, count=1):\n        \"\"\"writes the line and count newlines after the line\"\"\"\n        self.write(line)\n        self.write_newlines(count)", "code_tokens": ["def", "write_line", "(", "self", ",", "line", ",", "count", "=", "1", ")", ":", "self", ".", "write", "(", "line", ")", "self", ".", "write_newlines", "(", "count", ")"], "idx": 2415}
{"url": "cosqa-train-5672", "docstring_tokens": ["Return", "True", "if", "value", "is", "an", "integer", "."], "code": "def is_int(value):\n    \"\"\"Return `True` if ``value`` is an integer.\"\"\"\n    if isinstance(value, bool):\n        return False\n    try:\n        int(value)\n        return True\n    except (ValueError, TypeError):\n        return False", "code_tokens": ["def", "is_int", "(", "value", ")", ":", "if", "isinstance", "(", "value", ",", "bool", ")", ":", "return", "False", "try", ":", "int", "(", "value", ")", "return", "True", "except", "(", "ValueError", ",", "TypeError", ")", ":", "return", "False"], "idx": 637}
{"url": "cosqa-train-13664", "docstring_tokens": ["Represent", "data", "as", "a", "masked", "array", "."], "code": "def ma(self):\n        \"\"\"Represent data as a masked array.\n\n        The array is returned with column-first indexing, i.e. for a data file with\n        columns X Y1 Y2 Y3 ... the array a will be a[0] = X, a[1] = Y1, ... .\n\n        inf and nan are filtered via :func:`numpy.isfinite`.\n        \"\"\"\n        a = self.array\n        return numpy.ma.MaskedArray(a, mask=numpy.logical_not(numpy.isfinite(a)))", "code_tokens": ["def", "ma", "(", "self", ")", ":", "a", "=", "self", ".", "array", "return", "numpy", ".", "ma", ".", "MaskedArray", "(", "a", ",", "mask", "=", "numpy", ".", "logical_not", "(", "numpy", ".", "isfinite", "(", "a", ")", ")", ")"], "idx": 861}
{"url": "cosqa-train-6638", "docstring_tokens": ["move", "to", "util_iter"], "code": "def isetdiff_flags(list1, list2):\n    \"\"\"\n    move to util_iter\n    \"\"\"\n    set2 = set(list2)\n    return (item not in set2 for item in list1)", "code_tokens": ["def", "isetdiff_flags", "(", "list1", ",", "list2", ")", ":", "set2", "=", "set", "(", "list2", ")", "return", "(", "item", "not", "in", "set2", "for", "item", "in", "list1", ")"], "idx": 281}
{"url": "cosqa-train-10449", "docstring_tokens": ["Convert", "a", "value", "to", "str", "on", "Python", "3", "and", "unicode", "on", "Python", "2", "."], "code": "def text(value, encoding=\"utf-8\", errors=\"strict\"):\n    \"\"\"Convert a value to str on Python 3 and unicode on Python 2.\"\"\"\n    if isinstance(value, text_type):\n        return value\n    elif isinstance(value, bytes):\n        return text_type(value, encoding, errors)\n    else:\n        return text_type(value)", "code_tokens": ["def", "text", "(", "value", ",", "encoding", "=", "\"utf-8\"", ",", "errors", "=", "\"strict\"", ")", ":", "if", "isinstance", "(", "value", ",", "text_type", ")", ":", "return", "value", "elif", "isinstance", "(", "value", ",", "bytes", ")", ":", "return", "text_type", "(", "value", ",", "encoding", ",", "errors", ")", "else", ":", "return", "text_type", "(", "value", ")"], "idx": 4478}
{"url": "cosqa-train-11076", "docstring_tokens": ["Creates", "a", "new", "dict", "from", "an", "existing", "dict", "that", "only", "has", "the", "given", "keys"], "code": "def filter_dict(d, keys):\n    \"\"\"\n    Creates a new dict from an existing dict that only has the given keys\n    \"\"\"\n    return {k: v for k, v in d.items() if k in keys}", "code_tokens": ["def", "filter_dict", "(", "d", ",", "keys", ")", ":", "return", "{", "k", ":", "v", "for", "k", ",", "v", "in", "d", ".", "items", "(", ")", "if", "k", "in", "keys", "}"], "idx": 177}
{"url": "cosqa-dev-409", "docstring_tokens": ["Convert", "datetime", "to", "epoch", "seconds", "."], "code": "def _dt_to_epoch(dt):\n        \"\"\"Convert datetime to epoch seconds.\"\"\"\n        try:\n            epoch = dt.timestamp()\n        except AttributeError:  # py2\n            epoch = (dt - datetime(1970, 1, 1)).total_seconds()\n        return epoch", "code_tokens": ["def", "_dt_to_epoch", "(", "dt", ")", ":", "try", ":", "epoch", "=", "dt", ".", "timestamp", "(", ")", "except", "AttributeError", ":", "#", "py2", "epoch", "=", "(", "dt", "-", "datetime", "(", "1970", ",", "1", ",", "1", ")", ")", ".", "total_seconds", "(", ")", "return", "epoch"], "idx": 459}
{"url": "cosqa-train-11165", "docstring_tokens": ["Remove", "non", "-", "alphanumerical", "characters", "from", "metric", "word", ".", "And", "trim", "excessive", "underscores", "."], "code": "def sanitize_word(s):\n    \"\"\"Remove non-alphanumerical characters from metric word.\n    And trim excessive underscores.\n    \"\"\"\n    s = re.sub('[^\\w-]+', '_', s)\n    s = re.sub('__+', '_', s)\n    return s.strip('_')", "code_tokens": ["def", "sanitize_word", "(", "s", ")", ":", "s", "=", "re", ".", "sub", "(", "'[^\\w-]+'", ",", "'_'", ",", "s", ")", "s", "=", "re", ".", "sub", "(", "'__+'", ",", "'_'", ",", "s", ")", "return", "s", ".", "strip", "(", "'_'", ")"], "idx": 2339}
{"url": "cosqa-train-14538", "docstring_tokens": ["Start", "web", "application"], "code": "def web(host, port):\n    \"\"\"Start web application\"\"\"\n    from .webserver.web import get_app\n    get_app().run(host=host, port=port)", "code_tokens": ["def", "web", "(", "host", ",", "port", ")", ":", "from", ".", "webserver", ".", "web", "import", "get_app", "get_app", "(", ")", ".", "run", "(", "host", "=", "host", ",", "port", "=", "port", ")"], "idx": 1338}
{"url": "cosqa-train-18581", "docstring_tokens": ["Retrun", "True", "if", "x", "is", "a", "valid", "YYYYMMDD", "date", ";", "otherwise", "return", "False", "."], "code": "def valid_date(x: str) -> bool:\n    \"\"\"\n    Retrun ``True`` if ``x`` is a valid YYYYMMDD date;\n    otherwise return ``False``.\n    \"\"\"\n    try:\n        if x != dt.datetime.strptime(x, DATE_FORMAT).strftime(DATE_FORMAT):\n            raise ValueError\n        return True\n    except ValueError:\n        return False", "code_tokens": ["def", "valid_date", "(", "x", ":", "str", ")", "->", "bool", ":", "try", ":", "if", "x", "!=", "dt", ".", "datetime", ".", "strptime", "(", "x", ",", "DATE_FORMAT", ")", ".", "strftime", "(", "DATE_FORMAT", ")", ":", "raise", "ValueError", "return", "True", "except", "ValueError", ":", "return", "False"], "idx": 5581}
{"url": "cosqa-train-7160", "docstring_tokens": ["Given", "a", "datetime", ".", "timedelta", "object", "return", "the", "delta", "in", "milliseconds"], "code": "def datetime_delta_to_ms(delta):\n    \"\"\"\n    Given a datetime.timedelta object, return the delta in milliseconds\n    \"\"\"\n    delta_ms = delta.days * 24 * 60 * 60 * 1000\n    delta_ms += delta.seconds * 1000\n    delta_ms += delta.microseconds / 1000\n    delta_ms = int(delta_ms)\n    return delta_ms", "code_tokens": ["def", "datetime_delta_to_ms", "(", "delta", ")", ":", "delta_ms", "=", "delta", ".", "days", "*", "24", "*", "60", "*", "60", "*", "1000", "delta_ms", "+=", "delta", ".", "seconds", "*", "1000", "delta_ms", "+=", "delta", ".", "microseconds", "/", "1000", "delta_ms", "=", "int", "(", "delta_ms", ")", "return", "delta_ms"], "idx": 2902}
{"url": "cosqa-train-13919", "docstring_tokens": ["Resets", "the", "iterator", "to", "the", "start", "."], "code": "def reset(self):\n\t\t\"\"\"\n\t\tResets the iterator to the start.\n\n\t\tAny remaining values in the current iteration are discarded.\n\t\t\"\"\"\n\t\tself.__iterator, self.__saved = itertools.tee(self.__saved)", "code_tokens": ["def", "reset", "(", "self", ")", ":", "self", ".", "__iterator", ",", "self", ".", "__saved", "=", "itertools", ".", "tee", "(", "self", ".", "__saved", ")"], "idx": 1126}
{"url": "cosqa-train-8974", "docstring_tokens": ["Return", "the", "high", "median", "of", "data", "."], "code": "def median_high(data):\n    \"\"\"Return the high median of data.\n\n    When the number of data points is odd, the middle value is returned.\n    When it is even, the larger of the two middle values is returned.\n\n    \"\"\"\n    data = sorted(data)\n    n = len(data)\n    if n == 0:\n        raise StatisticsError(\"no median for empty data\")\n    return data[n // 2]", "code_tokens": ["def", "median_high", "(", "data", ")", ":", "data", "=", "sorted", "(", "data", ")", "n", "=", "len", "(", "data", ")", "if", "n", "==", "0", ":", "raise", "StatisticsError", "(", "\"no", "median", "for", "empty", "data\"", ")", "return", "data", "[", "n", "//", "2", "]"], "idx": 1979}
{"url": "cosqa-train-11471", "docstring_tokens": ["Remove", "and", "return", "the", "item", "at", "index", "."], "code": "def pop(self, index=-1):\n\t\t\"\"\"Remove and return the item at index.\"\"\"\n\t\tvalue = self._list.pop(index)\n\t\tdel self._dict[value]\n\t\treturn value", "code_tokens": ["def", "pop", "(", "self", ",", "index", "=", "-", "1", ")", ":", "value", "=", "self", ".", "_list", ".", "pop", "(", "index", ")", "del", "self", ".", "_dict", "[", "value", "]", "return", "value"], "idx": 1019}
{"url": "cosqa-train-16297", "docstring_tokens": ["Check", "if", "filename1", "and", "filename2", "point", "to", "the", "same", "file", "object", ".", "There", "can", "be", "false", "negatives", "ie", ".", "the", "result", "is", "False", "but", "it", "is", "the", "same", "file", "anyway", ".", "Reason", "is", "that", "network", "filesystems", "can", "create", "different", "paths", "to", "the", "same", "physical", "file", "."], "code": "def is_same_file (filename1, filename2):\n    \"\"\"Check if filename1 and filename2 point to the same file object.\n    There can be false negatives, ie. the result is False, but it is\n    the same file anyway. Reason is that network filesystems can create\n    different paths to the same physical file.\n    \"\"\"\n    if filename1 == filename2:\n        return True\n    if os.name == 'posix':\n        return os.path.samefile(filename1, filename2)\n    return is_same_filename(filename1, filename2)", "code_tokens": ["def", "is_same_file", "(", "filename1", ",", "filename2", ")", ":", "if", "filename1", "==", "filename2", ":", "return", "True", "if", "os", ".", "name", "==", "'posix'", ":", "return", "os", ".", "path", ".", "samefile", "(", "filename1", ",", "filename2", ")", "return", "is_same_filename", "(", "filename1", ",", "filename2", ")"], "idx": 2832}
{"url": "cosqa-train-8492", "docstring_tokens": ["Write", "data", "with", "column", "headers", "to", "a", "CSV", "."], "code": "def writeCSV(data, headers, csvFile):\n  \"\"\"Write data with column headers to a CSV.\"\"\"\n  with open(csvFile, \"wb\") as f:\n    writer = csv.writer(f, delimiter=\",\")\n    writer.writerow(headers)\n    writer.writerows(data)", "code_tokens": ["def", "writeCSV", "(", "data", ",", "headers", ",", "csvFile", ")", ":", "with", "open", "(", "csvFile", ",", "\"wb\"", ")", "as", "f", ":", "writer", "=", "csv", ".", "writer", "(", "f", ",", "delimiter", "=", "\",\"", ")", "writer", ".", "writerow", "(", "headers", ")", "writer", ".", "writerows", "(", "data", ")"], "idx": 4044}
{"url": "cosqa-train-18659", "docstring_tokens": ["Delete", "log", "file", "."], "code": "def DeleteLog() -> None:\n        \"\"\"Delete log file.\"\"\"\n        if os.path.exists(Logger.FileName):\n            os.remove(Logger.FileName)", "code_tokens": ["def", "DeleteLog", "(", ")", "->", "None", ":", "if", "os", ".", "path", ".", "exists", "(", "Logger", ".", "FileName", ")", ":", "os", ".", "remove", "(", "Logger", ".", "FileName", ")"], "idx": 6095}
{"url": "cosqa-train-18736", "docstring_tokens": ["Truncates", "a", "value", "to", "a", "number", "of", "decimals", "places"], "code": "def truncate(value: Decimal, n_digits: int) -> Decimal:\n    \"\"\"Truncates a value to a number of decimals places\"\"\"\n    return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)", "code_tokens": ["def", "truncate", "(", "value", ":", "Decimal", ",", "n_digits", ":", "int", ")", "->", "Decimal", ":", "return", "Decimal", "(", "math", ".", "trunc", "(", "value", "*", "(", "10", "**", "n_digits", ")", ")", ")", "/", "(", "10", "**", "n_digits", ")"], "idx": 5704}
{"url": "cosqa-train-16420", "docstring_tokens": ["Merge", "all", "the", "strings", ".", "Put", "space", "between", "them", "."], "code": "def join(mapping, bind, values):\n    \"\"\" Merge all the strings. Put space between them. \"\"\"\n    return [' '.join([six.text_type(v) for v in values if v is not None])]", "code_tokens": ["def", "join", "(", "mapping", ",", "bind", ",", "values", ")", ":", "return", "[", "'", "'", ".", "join", "(", "[", "six", ".", "text_type", "(", "v", ")", "for", "v", "in", "values", "if", "v", "is", "not", "None", "]", ")", "]"], "idx": 2587}
{"url": "cosqa-train-7507", "docstring_tokens": ["helper", "to", "clean", "up", "an", "input", "string"], "code": "def clean(some_string, uppercase=False):\n    \"\"\"\n    helper to clean up an input string\n    \"\"\"\n    if uppercase:\n        return some_string.strip().upper()\n    else:\n        return some_string.strip().lower()", "code_tokens": ["def", "clean", "(", "some_string", ",", "uppercase", "=", "False", ")", ":", "if", "uppercase", ":", "return", "some_string", ".", "strip", "(", ")", ".", "upper", "(", ")", "else", ":", "return", "some_string", ".", "strip", "(", ")", ".", "lower", "(", ")"], "idx": 3327}
{"url": "cosqa-train-14795", "docstring_tokens": ["Returns", "the", "number", "of", "characters", "at", "the", "beginning", "of", "text", "that", "are", "whitespace", "."], "code": "def _count_leading_whitespace(text):\n  \"\"\"Returns the number of characters at the beginning of text that are whitespace.\"\"\"\n  idx = 0\n  for idx, char in enumerate(text):\n    if not char.isspace():\n      return idx\n  return idx + 1", "code_tokens": ["def", "_count_leading_whitespace", "(", "text", ")", ":", "idx", "=", "0", "for", "idx", ",", "char", "in", "enumerate", "(", "text", ")", ":", "if", "not", "char", ".", "isspace", "(", ")", ":", "return", "idx", "return", "idx", "+", "1"], "idx": 1859}
{"url": "cosqa-train-8907", "docstring_tokens": ["Return", "the", "cosine", "and", "sin", "for", "the", "given", "angle", "in", "degrees", "with", "special", "-", "case", "handling", "of", "multiples", "of", "90", "for", "perfect", "right", "angles"], "code": "def cos_sin_deg(deg):\n    \"\"\"Return the cosine and sin for the given angle\n    in degrees, with special-case handling of multiples\n    of 90 for perfect right angles\n    \"\"\"\n    deg = deg % 360.0\n    if deg == 90.0:\n        return 0.0, 1.0\n    elif deg == 180.0:\n        return -1.0, 0\n    elif deg == 270.0:\n        return 0, -1.0\n    rad = math.radians(deg)\n    return math.cos(rad), math.sin(rad)", "code_tokens": ["def", "cos_sin_deg", "(", "deg", ")", ":", "deg", "=", "deg", "%", "360.0", "if", "deg", "==", "90.0", ":", "return", "0.0", ",", "1.0", "elif", "deg", "==", "180.0", ":", "return", "-", "1.0", ",", "0", "elif", "deg", "==", "270.0", ":", "return", "0", ",", "-", "1.0", "rad", "=", "math", ".", "radians", "(", "deg", ")", "return", "math", ".", "cos", "(", "rad", ")", ",", "math", ".", "sin", "(", "rad", ")"], "idx": 4132}
{"url": "cosqa-train-8140", "docstring_tokens": ["Handle", "the", "+", "operator", "."], "code": "def __add__(self, other):\n        \"\"\"Handle the `+` operator.\"\"\"\n        return self._handle_type(other)(self.value + other.value)", "code_tokens": ["def", "__add__", "(", "self", ",", "other", ")", ":", "return", "self", ".", "_handle_type", "(", "other", ")", "(", "self", ".", "value", "+", "other", ".", "value", ")"], "idx": 23}
{"url": "cosqa-train-13030", "docstring_tokens": ["Create", "a", "conda", "environment", "inside", "the", "current", "sandbox", "for", "the", "given", "list", "of", "dependencies", "and", "options", "."], "code": "def create_conda_env(sandbox_dir, env_name, dependencies, options=()):\n    \"\"\"\n    Create a conda environment inside the current sandbox for the given list of dependencies and options.\n\n    Parameters\n    ----------\n    sandbox_dir : str\n    env_name : str\n    dependencies : list\n        List of conda specs\n    options\n        List of additional options to pass to conda.  Things like [\"-c\", \"conda-forge\"]\n\n    Returns\n    -------\n    (env_dir, env_name)\n    \"\"\"\n\n    env_dir = os.path.join(sandbox_dir, env_name)\n    cmdline = [\"conda\", \"create\", \"--yes\", \"--copy\", \"--quiet\", \"-p\", env_dir] + list(options) + dependencies\n\n    log.info(\"Creating conda environment: \")\n    log.info(\"  command line: %s\", cmdline)\n    subprocess.check_call(cmdline, stderr=subprocess.PIPE, stdout=subprocess.PIPE)\n    log.debug(\"Environment created\")\n\n    return env_dir, env_name", "code_tokens": ["def", "create_conda_env", "(", "sandbox_dir", ",", "env_name", ",", "dependencies", ",", "options", "=", "(", ")", ")", ":", "env_dir", "=", "os", ".", "path", ".", "join", "(", "sandbox_dir", ",", "env_name", ")", "cmdline", "=", "[", "\"conda\"", ",", "\"create\"", ",", "\"--yes\"", ",", "\"--copy\"", ",", "\"--quiet\"", ",", "\"-p\"", ",", "env_dir", "]", "+", "list", "(", "options", ")", "+", "dependencies", "log", ".", "info", "(", "\"Creating", "conda", "environment:", "\"", ")", "log", ".", "info", "(", "\"", "", "command", "line:", "%s\"", ",", "cmdline", ")", "subprocess", ".", "check_call", "(", "cmdline", ",", "stderr", "=", "subprocess", ".", "PIPE", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", "log", ".", "debug", "(", "\"Environment", "created\"", ")", "return", "env_dir", ",", "env_name"], "idx": 1839}
{"url": "cosqa-train-12628", "docstring_tokens": ["Checks", "if", "two", "images", "have", "the", "same", "height", "and", "width", "(", "and", "optionally", "channels", ")", "."], "code": "def is_same_shape(self, other_im, check_channels=False):\n        \"\"\" Checks if two images have the same height and width (and optionally channels).\n\n        Parameters\n        ----------\n        other_im : :obj:`Image`\n            image to compare\n        check_channels : bool\n            whether or not to check equality of the channels\n\n        Returns\n        -------\n        bool\n            True if the images are the same shape, False otherwise\n        \"\"\"\n        if self.height == other_im.height and self.width == other_im.width:\n            if check_channels and self.channels != other_im.channels:\n                return False\n            return True\n        return False", "code_tokens": ["def", "is_same_shape", "(", "self", ",", "other_im", ",", "check_channels", "=", "False", ")", ":", "if", "self", ".", "height", "==", "other_im", ".", "height", "and", "self", ".", "width", "==", "other_im", ".", "width", ":", "if", "check_channels", "and", "self", ".", "channels", "!=", "other_im", ".", "channels", ":", "return", "False", "return", "True", "return", "False"], "idx": 205}
{"url": "cosqa-train-9486", "docstring_tokens": ["Return", "a", "prettier", "version", "of", "obj"], "code": "def _get_pretty_string(obj):\n    \"\"\"Return a prettier version of obj\n\n    Parameters\n    ----------\n    obj : object\n        Object to pretty print\n\n    Returns\n    -------\n    s : str\n        Pretty print object repr\n    \"\"\"\n    sio = StringIO()\n    pprint.pprint(obj, stream=sio)\n    return sio.getvalue()", "code_tokens": ["def", "_get_pretty_string", "(", "obj", ")", ":", "sio", "=", "StringIO", "(", ")", "pprint", ".", "pprint", "(", "obj", ",", "stream", "=", "sio", ")", "return", "sio", ".", "getvalue", "(", ")"], "idx": 1942}
{"url": "cosqa-train-7202", "docstring_tokens": ["Wrapper", "for", "iterating", "numpy", "array"], "code": "def _npiter(arr):\n    \"\"\"Wrapper for iterating numpy array\"\"\"\n    for a in np.nditer(arr, flags=[\"refs_ok\"]):\n        c = a.item()\n        if c is not None:\n            yield c", "code_tokens": ["def", "_npiter", "(", "arr", ")", ":", "for", "a", "in", "np", ".", "nditer", "(", "arr", ",", "flags", "=", "[", "\"refs_ok\"", "]", ")", ":", "c", "=", "a", ".", "item", "(", ")", "if", "c", "is", "not", "None", ":", "yield", "c"], "idx": 3140}
{"url": "cosqa-dev-372", "docstring_tokens": ["Helper", "for", "pulling", "a", "keyed", "value", "off", "various", "types", "of", "objects"], "code": "def get_value(key, obj, default=missing):\n    \"\"\"Helper for pulling a keyed value off various types of objects\"\"\"\n    if isinstance(key, int):\n        return _get_value_for_key(key, obj, default)\n    return _get_value_for_keys(key.split('.'), obj, default)", "code_tokens": ["def", "get_value", "(", "key", ",", "obj", ",", "default", "=", "missing", ")", ":", "if", "isinstance", "(", "key", ",", "int", ")", ":", "return", "_get_value_for_key", "(", "key", ",", "obj", ",", "default", ")", "return", "_get_value_for_keys", "(", "key", ".", "split", "(", "'.'", ")", ",", "obj", ",", "default", ")"], "idx": 2593}
{"url": "cosqa-train-11264", "docstring_tokens": ["Return", "an", "iterator", "over", "the", "values", "of", "a", "dictionary", "."], "code": "def itervalues(d, **kw):\n    \"\"\"Return an iterator over the values of a dictionary.\"\"\"\n    if not PY2:\n        return iter(d.values(**kw))\n    return d.itervalues(**kw)", "code_tokens": ["def", "itervalues", "(", "d", ",", "*", "*", "kw", ")", ":", "if", "not", "PY2", ":", "return", "iter", "(", "d", ".", "values", "(", "*", "*", "kw", ")", ")", "return", "d", ".", "itervalues", "(", "*", "*", "kw", ")"], "idx": 1287}
{"url": "cosqa-train-16023", "docstring_tokens": ["Load", "and", "parse", "a", "feature", "file", "."], "code": "def load_feature(fname, language):\n    \"\"\" Load and parse a feature file. \"\"\"\n\n    fname = os.path.abspath(fname)\n    feat = parse_file(fname, language)\n    return feat", "code_tokens": ["def", "load_feature", "(", "fname", ",", "language", ")", ":", "fname", "=", "os", ".", "path", ".", "abspath", "(", "fname", ")", "feat", "=", "parse_file", "(", "fname", ",", "language", ")", "return", "feat"], "idx": 3282}
{"url": "cosqa-train-18625", "docstring_tokens": ["Split", "a", "text", "into", "a", "list", "of", "tokens", "."], "code": "def split(text: str) -> List[str]:\n    \"\"\"Split a text into a list of tokens.\n\n    :param text: the text to split\n    :return: tokens\n    \"\"\"\n    return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]", "code_tokens": ["def", "split", "(", "text", ":", "str", ")", "->", "List", "[", "str", "]", ":", "return", "[", "word", "for", "word", "in", "SEPARATOR", ".", "split", "(", "text", ")", "if", "word", ".", "strip", "(", "'", "\\t'", ")", "]"], "idx": 5571}
{"url": "cosqa-train-11126", "docstring_tokens": ["Init", "a", "noise", "variable", "."], "code": "def normal_noise(points):\n    \"\"\"Init a noise variable.\"\"\"\n    return np.random.rand(1) * np.random.randn(points, 1) \\\n        + random.sample([2, -2], 1)", "code_tokens": ["def", "normal_noise", "(", "points", ")", ":", "return", "np", ".", "random", ".", "rand", "(", "1", ")", "*", "np", ".", "random", ".", "randn", "(", "points", ",", "1", ")", "+", "random", ".", "sample", "(", "[", "2", ",", "-", "2", "]", ",", "1", ")"], "idx": 3344}
{"url": "cosqa-train-6655", "docstring_tokens": ["Connect", "and", "login", "to", "an", "FTP", "server", "and", "return", "ftplib", ".", "FTP", "object", "."], "code": "def connect(host, port, username, password):\n        \"\"\"Connect and login to an FTP server and return ftplib.FTP object.\"\"\"\n        # Instantiate ftplib client\n        session = ftplib.FTP()\n\n        # Connect to host without auth\n        session.connect(host, port)\n\n        # Authenticate connection\n        session.login(username, password)\n        return session", "code_tokens": ["def", "connect", "(", "host", ",", "port", ",", "username", ",", "password", ")", ":", "#", "Instantiate", "ftplib", "client", "session", "=", "ftplib", ".", "FTP", "(", ")", "#", "Connect", "to", "host", "without", "auth", "session", ".", "connect", "(", "host", ",", "port", ")", "#", "Authenticate", "connection", "session", ".", "login", "(", "username", ",", "password", ")", "return", "session"], "idx": 350}
{"url": "cosqa-train-17671", "docstring_tokens": ["return", "the", "number", "of", "channels", "present", "in", "samples"], "code": "def numchannels(samples:np.ndarray) -> int:\n    \"\"\"\n    return the number of channels present in samples\n\n    samples: a numpy array as returned by sndread\n\n    for multichannel audio, samples is always interleaved,\n    meaning that samples[n] returns always a frame, which\n    is either a single scalar for mono audio, or an array\n    for multichannel audio.\n    \"\"\"\n    if len(samples.shape) == 1:\n        return 1\n    else:\n        return samples.shape[1]", "code_tokens": ["def", "numchannels", "(", "samples", ":", "np", ".", "ndarray", ")", "->", "int", ":", "if", "len", "(", "samples", ".", "shape", ")", "==", "1", ":", "return", "1", "else", ":", "return", "samples", ".", "shape", "[", "1", "]"], "idx": 5756}
{"url": "cosqa-train-17641", "docstring_tokens": [">>>", "sort_key", "((", "name", "(", "ROUTE", "URL", ")))", "-", "3"], "code": "def sort_key(x):\n    \"\"\"\n    >>> sort_key(('name', ('ROUTE', 'URL')))\n    -3\n    \"\"\"\n    name, (r, u) = x\n    return - len(u) + u.count('}') * 100", "code_tokens": ["def", "sort_key", "(", "x", ")", ":", "name", ",", "(", "r", ",", "u", ")", "=", "x", "return", "-", "len", "(", "u", ")", "+", "u", ".", "count", "(", "'}'", ")", "*", "100"], "idx": 5890}
{"url": "cosqa-train-17962", "docstring_tokens": ["(", "Point", "Point", ")", "-", ">", "Point", "Return", "the", "point", "that", "lies", "in", "between", "the", "two", "input", "points", "."], "code": "def _mid(pt1, pt2):\n    \"\"\"\n    (Point, Point) -> Point\n    Return the point that lies in between the two input points.\n    \"\"\"\n    (x0, y0), (x1, y1) = pt1, pt2\n    return 0.5 * (x0 + x1), 0.5 * (y0 + y1)", "code_tokens": ["def", "_mid", "(", "pt1", ",", "pt2", ")", ":", "(", "x0", ",", "y0", ")", ",", "(", "x1", ",", "y1", ")", "=", "pt1", ",", "pt2", "return", "0.5", "*", "(", "x0", "+", "x1", ")", ",", "0.5", "*", "(", "y0", "+", "y1", ")"], "idx": 5853}
{"url": "cosqa-train-12831", "docstring_tokens": ["Due", "to", "the", "way", "Angular", "organizes", "it", "model", "when", "this", "Form", "data", "is", "sent", "using", "Ajax", "then", "for", "this", "kind", "of", "widget", "the", "sent", "data", "has", "to", "be", "converted", "into", "a", "format", "suitable", "for", "Django", "s", "Form", "validation", "."], "code": "def convert_ajax_data(self, field_data):\n        \"\"\"\n        Due to the way Angular organizes it model, when this Form data is sent using Ajax,\n        then for this kind of widget, the sent data has to be converted into a format suitable\n        for Django's Form validation.\n        \"\"\"\n        data = [key for key, val in field_data.items() if val]\n        return data", "code_tokens": ["def", "convert_ajax_data", "(", "self", ",", "field_data", ")", ":", "data", "=", "[", "key", "for", "key", ",", "val", "in", "field_data", ".", "items", "(", ")", "if", "val", "]", "return", "data"], "idx": 4888}
{"url": "cosqa-train-10881", "docstring_tokens": ["Return", "the", "number", "of", "characters", "in", "two", "strings", "that", "don", "t", "exactly", "match"], "code": "def count_string_diff(a,b):\n    \"\"\"Return the number of characters in two strings that don't exactly match\"\"\"\n    shortest = min(len(a), len(b))\n    return sum(a[i] != b[i] for i in range(shortest))", "code_tokens": ["def", "count_string_diff", "(", "a", ",", "b", ")", ":", "shortest", "=", "min", "(", "len", "(", "a", ")", ",", "len", "(", "b", ")", ")", "return", "sum", "(", "a", "[", "i", "]", "!=", "b", "[", "i", "]", "for", "i", "in", "range", "(", "shortest", ")", ")"], "idx": 1824}
{"url": "cosqa-train-12311", "docstring_tokens": ["Converts", "protobuf", "message", "to", "a", "JSON", "dictionary", "."], "code": "def MessageToDict(message,\n                  including_default_value_fields=False,\n                  preserving_proto_field_name=False):\n  \"\"\"Converts protobuf message to a JSON dictionary.\n\n  Args:\n    message: The protocol buffers message instance to serialize.\n    including_default_value_fields: If True, singular primitive fields,\n        repeated fields, and map fields will always be serialized.  If\n        False, only serialize non-empty fields.  Singular message fields\n        and oneof fields are not affected by this option.\n    preserving_proto_field_name: If True, use the original proto field\n        names as defined in the .proto file. If False, convert the field\n        names to lowerCamelCase.\n\n  Returns:\n    A dict representation of the JSON formatted protocol buffer message.\n  \"\"\"\n  printer = _Printer(including_default_value_fields,\n                     preserving_proto_field_name)\n  # pylint: disable=protected-access\n  return printer._MessageToJsonObject(message)", "code_tokens": ["def", "MessageToDict", "(", "message", ",", "including_default_value_fields", "=", "False", ",", "preserving_proto_field_name", "=", "False", ")", ":", "printer", "=", "_Printer", "(", "including_default_value_fields", ",", "preserving_proto_field_name", ")", "#", "pylint:", "disable=protected-access", "return", "printer", ".", "_MessageToJsonObject", "(", "message", ")"], "idx": 4806}
{"url": "cosqa-train-11007", "docstring_tokens": ["Like", "argsort", "but", "returns", "an", "index", "suitable", "for", "sorting", "the", "the", "original", "array", "even", "if", "that", "array", "is", "multidimensional"], "code": "def argsort_indices(a, axis=-1):\n    \"\"\"Like argsort, but returns an index suitable for sorting the\n    the original array even if that array is multidimensional\n    \"\"\"\n    a = np.asarray(a)\n    ind = list(np.ix_(*[np.arange(d) for d in a.shape]))\n    ind[axis] = a.argsort(axis)\n    return tuple(ind)", "code_tokens": ["def", "argsort_indices", "(", "a", ",", "axis", "=", "-", "1", ")", ":", "a", "=", "np", ".", "asarray", "(", "a", ")", "ind", "=", "list", "(", "np", ".", "ix_", "(", "*", "[", "np", ".", "arange", "(", "d", ")", "for", "d", "in", "a", ".", "shape", "]", ")", ")", "ind", "[", "axis", "]", "=", "a", ".", "argsort", "(", "axis", ")", "return", "tuple", "(", "ind", ")"], "idx": 604}
{"url": "cosqa-train-6873", "docstring_tokens": ["Register", "a", "modele", "onto", "the", "lemmatizer"], "code": "def register_modele(self, modele: Modele):\n        \"\"\" Register a modele onto the lemmatizer\n\n        :param modele: Modele to register\n        \"\"\"\n        self.lemmatiseur._modeles[modele.gr()] = modele", "code_tokens": ["def", "register_modele", "(", "self", ",", "modele", ":", "Modele", ")", ":", "self", ".", "lemmatiseur", ".", "_modeles", "[", "modele", ".", "gr", "(", ")", "]", "=", "modele"], "idx": 662}
{"url": "cosqa-train-17967", "docstring_tokens": ["Shape", "of", "histogram", "s", "data", "."], "code": "def shape(self) -> Tuple[int, ...]:\n        \"\"\"Shape of histogram's data.\n\n        Returns\n        -------\n        One-element tuple with the number of bins along each axis.\n        \"\"\"\n        return tuple(bins.bin_count for bins in self._binnings)", "code_tokens": ["def", "shape", "(", "self", ")", "->", "Tuple", "[", "int", ",", "...", "]", ":", "return", "tuple", "(", "bins", ".", "bin_count", "for", "bins", "in", "self", ".", "_binnings", ")"], "idx": 5791}
{"url": "cosqa-train-8700", "docstring_tokens": ["r", "Checks", "if", "l", "is", "a", "numpy", "array", "of", "integers"], "code": "def is_int_vector(l):\n    r\"\"\"Checks if l is a numpy array of integers\n\n    \"\"\"\n    if isinstance(l, np.ndarray):\n        if l.ndim == 1 and (l.dtype.kind == 'i' or l.dtype.kind == 'u'):\n            return True\n    return False", "code_tokens": ["def", "is_int_vector", "(", "l", ")", ":", "if", "isinstance", "(", "l", ",", "np", ".", "ndarray", ")", ":", "if", "l", ".", "ndim", "==", "1", "and", "(", "l", ".", "dtype", ".", "kind", "==", "'i'", "or", "l", ".", "dtype", ".", "kind", "==", "'u'", ")", ":", "return", "True", "return", "False"], "idx": 1618}
{"url": "cosqa-train-10680", "docstring_tokens": ["searchs", "a", "value", "in", "a", "dicionary", "and", "returns", "the", "key", "of", "the", "first", "occurrence"], "code": "def get_key_by_value(dictionary, search_value):\n    \"\"\"\n    searchs a value in a dicionary and returns the key of the first occurrence\n\n    :param dictionary: dictionary to search in\n    :param search_value: value to search for\n    \"\"\"\n    for key, value in dictionary.iteritems():\n        if value == search_value:\n            return ugettext(key)", "code_tokens": ["def", "get_key_by_value", "(", "dictionary", ",", "search_value", ")", ":", "for", "key", ",", "value", "in", "dictionary", ".", "iteritems", "(", ")", ":", "if", "value", "==", "search_value", ":", "return", "ugettext", "(", "key", ")"], "idx": 1056}
{"url": "cosqa-train-15005", "docstring_tokens": ["Converts", "python", "datetime", "to", "epoch", "microseconds", "."], "code": "def _DateToEpoch(date):\n  \"\"\"Converts python datetime to epoch microseconds.\"\"\"\n  tz_zero = datetime.datetime.utcfromtimestamp(0)\n  diff_sec = int((date - tz_zero).total_seconds())\n  return diff_sec * 1000000", "code_tokens": ["def", "_DateToEpoch", "(", "date", ")", ":", "tz_zero", "=", "datetime", ".", "datetime", ".", "utcfromtimestamp", "(", "0", ")", "diff_sec", "=", "int", "(", "(", "date", "-", "tz_zero", ")", ".", "total_seconds", "(", ")", ")", "return", "diff_sec", "*", "1000000"], "idx": 1707}
{"url": "cosqa-train-13836", "docstring_tokens": ["Gather", "a", "list", "of", "proxies", "to", "use", "."], "code": "def _GetProxies(self):\n    \"\"\"Gather a list of proxies to use.\"\"\"\n    # Detect proxies from the OS environment.\n    result = client_utils.FindProxies()\n\n    # Also try to connect directly if all proxies fail.\n    result.append(\"\")\n\n    # Also try all proxies configured in the config system.\n    result.extend(config.CONFIG[\"Client.proxy_servers\"])\n\n    return result", "code_tokens": ["def", "_GetProxies", "(", "self", ")", ":", "#", "Detect", "proxies", "from", "the", "OS", "environment.", "result", "=", "client_utils", ".", "FindProxies", "(", ")", "#", "Also", "try", "to", "connect", "directly", "if", "all", "proxies", "fail.", "result", ".", "append", "(", "\"\"", ")", "#", "Also", "try", "all", "proxies", "configured", "in", "the", "config", "system.", "result", ".", "extend", "(", "config", ".", "CONFIG", "[", "\"Client.proxy_servers\"", "]", ")", "return", "result"], "idx": 5065}
{"url": "cosqa-train-17261", "docstring_tokens": ["Utility", "method", "to", "run", "commands", "synchronously", "for", "testing", "."], "code": "def _run_sync(self, method: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Utility method to run commands synchronously for testing.\n        \"\"\"\n        if self.loop.is_running():\n            raise RuntimeError(\"Event loop is already running.\")\n\n        if not self.is_connected:\n            self.loop.run_until_complete(self.connect())\n\n        task = asyncio.Task(method(*args, **kwargs), loop=self.loop)\n        result = self.loop.run_until_complete(task)\n\n        self.loop.run_until_complete(self.quit())\n\n        return result", "code_tokens": ["def", "_run_sync", "(", "self", ",", "method", ":", "Callable", ",", "*", "args", ",", "*", "*", "kwargs", ")", "->", "Any", ":", "if", "self", ".", "loop", ".", "is_running", "(", ")", ":", "raise", "RuntimeError", "(", "\"Event", "loop", "is", "already", "running.\"", ")", "if", "not", "self", ".", "is_connected", ":", "self", ".", "loop", ".", "run_until_complete", "(", "self", ".", "connect", "(", ")", ")", "task", "=", "asyncio", ".", "Task", "(", "method", "(", "*", "args", ",", "*", "*", "kwargs", ")", ",", "loop", "=", "self", ".", "loop", ")", "result", "=", "self", ".", "loop", ".", "run_until_complete", "(", "task", ")", "self", ".", "loop", ".", "run_until_complete", "(", "self", ".", "quit", "(", ")", ")", "return", "result"], "idx": 5681}
{"url": "cosqa-train-10906", "docstring_tokens": ["Resolve", "which", "cross", "validation", "strategy", "is", "used", "."], "code": "def check_cv(self, y):\n        \"\"\"Resolve which cross validation strategy is used.\"\"\"\n        y_arr = None\n        if self.stratified:\n            # Try to convert y to numpy for sklearn's check_cv; if conversion\n            # doesn't work, still try.\n            try:\n                y_arr = to_numpy(y)\n            except (AttributeError, TypeError):\n                y_arr = y\n\n        if self._is_float(self.cv):\n            return self._check_cv_float()\n        return self._check_cv_non_float(y_arr)", "code_tokens": ["def", "check_cv", "(", "self", ",", "y", ")", ":", "y_arr", "=", "None", "if", "self", ".", "stratified", ":", "#", "Try", "to", "convert", "y", "to", "numpy", "for", "sklearn's", "check_cv;", "if", "conversion", "#", "doesn't", "work,", "still", "try.", "try", ":", "y_arr", "=", "to_numpy", "(", "y", ")", "except", "(", "AttributeError", ",", "TypeError", ")", ":", "y_arr", "=", "y", "if", "self", ".", "_is_float", "(", "self", ".", "cv", ")", ":", "return", "self", ".", "_check_cv_float", "(", ")", "return", "self", ".", "_check_cv_non_float", "(", "y_arr", ")"], "idx": 4567}
{"url": "cosqa-train-12340", "docstring_tokens": ["Removes", "trailing", "zeros", "in", "the", "list", "of", "integers", "and", "returns", "a", "new", "list", "of", "integers"], "code": "def _remove_blank(l):\n        \"\"\" Removes trailing zeros in the list of integers and returns a new list of integers\"\"\"\n        ret = []\n        for i, _ in enumerate(l):\n            if l[i] == 0:\n                break\n            ret.append(l[i])\n        return ret", "code_tokens": ["def", "_remove_blank", "(", "l", ")", ":", "ret", "=", "[", "]", "for", "i", ",", "_", "in", "enumerate", "(", "l", ")", ":", "if", "l", "[", "i", "]", "==", "0", ":", "break", "ret", ".", "append", "(", "l", "[", "i", "]", ")", "return", "ret"], "idx": 1006}
{"url": "cosqa-train-4698", "docstring_tokens": ["A", "generator", "of", "n", "-", "length", "chunks", "of", "an", "input", "iterable"], "code": "def split_every(iterable, n):  # TODO: Remove this, or make it return a generator.\n    \"\"\"\n    A generator of n-length chunks of an input iterable\n    \"\"\"\n    i = iter(iterable)\n    piece = list(islice(i, n))\n    while piece:\n        yield piece\n        piece = list(islice(i, n))", "code_tokens": ["def", "split_every", "(", "iterable", ",", "n", ")", ":", "#", "TODO:", "Remove", "this,", "or", "make", "it", "return", "a", "generator.", "i", "=", "iter", "(", "iterable", ")", "piece", "=", "list", "(", "islice", "(", "i", ",", "n", ")", ")", "while", "piece", ":", "yield", "piece", "piece", "=", "list", "(", "islice", "(", "i", ",", "n", ")", ")"], "idx": 2914}
{"url": "cosqa-dev-537", "docstring_tokens": ["Return", "the", "dotproduct", "of", "two", "vectors", "."], "code": "def dot_v3(v, w):\n    \"\"\"Return the dotproduct of two vectors.\"\"\"\n\n    return sum([x * y for x, y in zip(v, w)])", "code_tokens": ["def", "dot_v3", "(", "v", ",", "w", ")", ":", "return", "sum", "(", "[", "x", "*", "y", "for", "x", ",", "y", "in", "zip", "(", "v", ",", "w", ")", "]", ")"], "idx": 871}
{"url": "cosqa-train-2408", "docstring_tokens": ["Detach", "from", "all", "tracked", "classes", "and", "objects", ".", "Restore", "the", "original", "constructors", "and", "cleanse", "the", "tracking", "lists", "."], "code": "def detach_all(self):\n        \"\"\"\n        Detach from all tracked classes and objects.\n        Restore the original constructors and cleanse the tracking lists.\n        \"\"\"\n        self.detach_all_classes()\n        self.objects.clear()\n        self.index.clear()\n        self._keepalive[:] = []", "code_tokens": ["def", "detach_all", "(", "self", ")", ":", "self", ".", "detach_all_classes", "(", ")", "self", ".", "objects", ".", "clear", "(", ")", "self", ".", "index", ".", "clear", "(", ")", "self", ".", "_keepalive", "[", ":", "]", "=", "[", "]"], "idx": 1842}
{"url": "cosqa-train-12597", "docstring_tokens": ["Indicates", "whether", "or", "not", "the", "given", "row", "contains", "valid", "data", "."], "code": "def is_valid_row(cls, row):\n        \"\"\"Indicates whether or not the given row contains valid data.\"\"\"\n        for k in row.keys():\n            if row[k] is None:\n                return False\n        return True", "code_tokens": ["def", "is_valid_row", "(", "cls", ",", "row", ")", ":", "for", "k", "in", "row", ".", "keys", "(", ")", ":", "if", "row", "[", "k", "]", "is", "None", ":", "return", "False", "return", "True"], "idx": 1620}
{"url": "cosqa-train-13988", "docstring_tokens": ["Region", "formed", "by", "taking", "border", "elements", "."], "code": "def border(self):\n        \"\"\"Region formed by taking border elements.\n\n        :returns: :class:`jicimagelib.region.Region`\n        \"\"\"\n\n        border_array = self.bitmap - self.inner.bitmap\n        return Region(border_array)", "code_tokens": ["def", "border", "(", "self", ")", ":", "border_array", "=", "self", ".", "bitmap", "-", "self", ".", "inner", ".", "bitmap", "return", "Region", "(", "border_array", ")"], "idx": 3568}
{"url": "cosqa-train-11754", "docstring_tokens": ["Perform", "re", ".", "sub", "with", "the", "patterns", "in", "the", "given", "dict", "Args", ":", "dict_", ":", "{", "pattern", ":", "repl", "}", "source", ":", "str"], "code": "def substitute(dict_, source):\n    \"\"\" Perform re.sub with the patterns in the given dict\n    Args:\n      dict_: {pattern: repl}\n      source: str\n    \"\"\"\n    d_esc = (re.escape(k) for k in dict_.keys())\n    pattern = re.compile('|'.join(d_esc))\n    return pattern.sub(lambda x: dict_[x.group()], source)", "code_tokens": ["def", "substitute", "(", "dict_", ",", "source", ")", ":", "d_esc", "=", "(", "re", ".", "escape", "(", "k", ")", "for", "k", "in", "dict_", ".", "keys", "(", ")", ")", "pattern", "=", "re", ".", "compile", "(", "'|'", ".", "join", "(", "d_esc", ")", ")", "return", "pattern", ".", "sub", "(", "lambda", "x", ":", "dict_", "[", "x", ".", "group", "(", ")", "]", ",", "source", ")"], "idx": 4713}
{"url": "cosqa-train-10463", "docstring_tokens": ["Wraps", "a", "function", "to", "run", "in", "a", "given", "directory", "."], "code": "def change_dir(directory):\n  \"\"\"\n  Wraps a function to run in a given directory.\n\n  \"\"\"\n  def cd_decorator(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n      org_path = os.getcwd()\n      os.chdir(directory)\n      func(*args, **kwargs)\n      os.chdir(org_path)\n    return wrapper\n  return cd_decorator", "code_tokens": ["def", "change_dir", "(", "directory", ")", ":", "def", "cd_decorator", "(", "func", ")", ":", "@", "wraps", "(", "func", ")", "def", "wrapper", "(", "*", "args", ",", "*", "*", "kwargs", ")", ":", "org_path", "=", "os", ".", "getcwd", "(", ")", "os", ".", "chdir", "(", "directory", ")", "func", "(", "*", "args", ",", "*", "*", "kwargs", ")", "os", ".", "chdir", "(", "org_path", ")", "return", "wrapper", "return", "cd_decorator"], "idx": 2811}
{"url": "cosqa-train-7461", "docstring_tokens": ["Register", "service", "into", "the", "system", ".", "Called", "by", "Services", "."], "code": "def register_service(self, service):\n        \"\"\"\n            Register service into the system. Called by Services.\n        \"\"\"\n        if service not in self.services:\n            self.services.append(service)", "code_tokens": ["def", "register_service", "(", "self", ",", "service", ")", ":", "if", "service", "not", "in", "self", ".", "services", ":", "self", ".", "services", ".", "append", "(", "service", ")"], "idx": 3784}
{"url": "cosqa-train-16042", "docstring_tokens": [":", "param", "string", "s", ":", "under_scored", "string", "to", "be", "CamelCased", ":", "return", ":", "CamelCase", "version", "of", "input", ":", "rtype", ":", "str"], "code": "def to_camel(s):\n    \"\"\"\n    :param string s: under_scored string to be CamelCased\n    :return: CamelCase version of input\n    :rtype: str\n    \"\"\"\n    # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups\n    return re.sub(r'_([a-zA-Z])', lambda m: m.group(1).upper(), '_' + s)", "code_tokens": ["def", "to_camel", "(", "s", ")", ":", "#", "r'(?!^)_([a-zA-Z])", "original", "regex", "wasn't", "process", "first", "groups", "return", "re", ".", "sub", "(", "r'_([a-zA-Z])'", ",", "lambda", "m", ":", "m", ".", "group", "(", "1", ")", ".", "upper", "(", ")", ",", "'_'", "+", "s", ")"], "idx": 3683}
{"url": "cosqa-train-1815", "docstring_tokens": ["Slicing", "op", "."], "code": "def Slice(a, begin, size):\n    \"\"\"\n    Slicing op.\n    \"\"\"\n    return np.copy(a)[[slice(*tpl) for tpl in zip(begin, begin+size)]],", "code_tokens": ["def", "Slice", "(", "a", ",", "begin", ",", "size", ")", ":", "return", "np", ".", "copy", "(", "a", ")", "[", "[", "slice", "(", "*", "tpl", ")", "for", "tpl", "in", "zip", "(", "begin", ",", "begin", "+", "size", ")", "]", "]", ","], "idx": 1486}
{"url": "cosqa-train-10647", "docstring_tokens": ["compose", "a", "list", "of", "functions"], "code": "def compose(*funcs):\n    \"\"\"compose a list of functions\"\"\"\n    return lambda x: reduce(lambda v, f: f(v), reversed(funcs), x)", "code_tokens": ["def", "compose", "(", "*", "funcs", ")", ":", "return", "lambda", "x", ":", "reduce", "(", "lambda", "v", ",", "f", ":", "f", "(", "v", ")", ",", "reversed", "(", "funcs", ")", ",", "x", ")"], "idx": 1578}
{"url": "cosqa-train-11306", "docstring_tokens": ["Calculates", "the", "request", "payload", "size"], "code": "def calculate_size(name, replace_existing_values):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += BOOLEAN_SIZE_IN_BYTES\n    return data_size", "code_tokens": ["def", "calculate_size", "(", "name", ",", "replace_existing_values", ")", ":", "data_size", "=", "0", "data_size", "+=", "calculate_size_str", "(", "name", ")", "data_size", "+=", "BOOLEAN_SIZE_IN_BYTES", "return", "data_size"], "idx": 4632}
{"url": "cosqa-train-13579", "docstring_tokens": ["Reset", "analyzer", "state"], "code": "def reset(self):\n        \"\"\"Reset analyzer state\n        \"\"\"\n        self.prevframe = None\n        self.wasmoving = False\n        self.t0 = 0\n        self.ismoving = False", "code_tokens": ["def", "reset", "(", "self", ")", ":", "self", ".", "prevframe", "=", "None", "self", ".", "wasmoving", "=", "False", "self", ".", "t0", "=", "0", "self", ".", "ismoving", "=", "False"], "idx": 2156}
{"url": "cosqa-train-7228", "docstring_tokens": ["Return", "the", "opposite", "of", "input", "condition", "."], "code": "def _not(condition=None, **kwargs):\n    \"\"\"\n    Return the opposite of input condition.\n\n    :param condition: condition to process.\n\n    :result: not condition.\n    :rtype: bool\n    \"\"\"\n\n    result = True\n\n    if condition is not None:\n        result = not run(condition, **kwargs)\n\n    return result", "code_tokens": ["def", "_not", "(", "condition", "=", "None", ",", "*", "*", "kwargs", ")", ":", "result", "=", "True", "if", "condition", "is", "not", "None", ":", "result", "=", "not", "run", "(", "condition", ",", "*", "*", "kwargs", ")", "return", "result"], "idx": 18}
{"url": "cosqa-train-2086", "docstring_tokens": ["Returns", "a", "boolean", "indicating", "if", "the", "attribute", "name", "is", "valid", "or", "not"], "code": "def _validate_key(self, key):\n        \"\"\"Returns a boolean indicating if the attribute name is valid or not\"\"\"\n        return not any([key.startswith(i) for i in self.EXCEPTIONS])", "code_tokens": ["def", "_validate_key", "(", "self", ",", "key", ")", ":", "return", "not", "any", "(", "[", "key", ".", "startswith", "(", "i", ")", "for", "i", "in", "self", ".", "EXCEPTIONS", "]", ")"], "idx": 1653}
{"url": "cosqa-train-6783", "docstring_tokens": ["Get", "the", "date", "that", "a", "file", "was", "created", "."], "code": "def get_creation_datetime(filepath):\n    \"\"\"\n    Get the date that a file was created.\n\n    Parameters\n    ----------\n    filepath : str\n\n    Returns\n    -------\n    creation_datetime : datetime.datetime or None\n    \"\"\"\n    if platform.system() == 'Windows':\n        return datetime.fromtimestamp(os.path.getctime(filepath))\n    else:\n        stat = os.stat(filepath)\n        try:\n            return datetime.fromtimestamp(stat.st_birthtime)\n        except AttributeError:\n            # We're probably on Linux. No easy way to get creation dates here,\n            # so we'll settle for when its content was last modified.\n            return None", "code_tokens": ["def", "get_creation_datetime", "(", "filepath", ")", ":", "if", "platform", ".", "system", "(", ")", "==", "'Windows'", ":", "return", "datetime", ".", "fromtimestamp", "(", "os", ".", "path", ".", "getctime", "(", "filepath", ")", ")", "else", ":", "stat", "=", "os", ".", "stat", "(", "filepath", ")", "try", ":", "return", "datetime", ".", "fromtimestamp", "(", "stat", ".", "st_birthtime", ")", "except", "AttributeError", ":", "#", "We're", "probably", "on", "Linux.", "No", "easy", "way", "to", "get", "creation", "dates", "here,", "#", "so", "we'll", "settle", "for", "when", "its", "content", "was", "last", "modified.", "return", "None"], "idx": 3577}
{"url": "cosqa-train-3720", "docstring_tokens": ["Takes", "a", "value", "or", "list", "of", "values", "and", "returns", "a", "single", "result", "joined", "by", "if", "necessary", "."], "code": "def vectorize(values):\n    \"\"\"\n    Takes a value or list of values and returns a single result, joined by \",\"\n    if necessary.\n    \"\"\"\n    if isinstance(values, list):\n        return ','.join(str(v) for v in values)\n    return values", "code_tokens": ["def", "vectorize", "(", "values", ")", ":", "if", "isinstance", "(", "values", ",", "list", ")", ":", "return", "','", ".", "join", "(", "str", "(", "v", ")", "for", "v", "in", "values", ")", "return", "values"], "idx": 2504}
{"url": "cosqa-train-18863", "docstring_tokens": ["Check", "if", "the", "memory", "is", "too", "full", "for", "further", "caching", "."], "code": "def memory_full():\n    \"\"\"Check if the memory is too full for further caching.\"\"\"\n    current_process = psutil.Process(os.getpid())\n    return (current_process.memory_percent() >\n            config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)", "code_tokens": ["def", "memory_full", "(", ")", ":", "current_process", "=", "psutil", ".", "Process", "(", "os", ".", "getpid", "(", ")", ")", "return", "(", "current_process", ".", "memory_percent", "(", ")", ">", "config", ".", "MAXIMUM_CACHE_MEMORY_PERCENTAGE", ")"], "idx": 5684}
{"url": "cosqa-train-8196", "docstring_tokens": ["Assert", "that", "a", "value", "must", "be", "a", "given", "type", "."], "code": "def _assert_is_type(name, value, value_type):\n    \"\"\"Assert that a value must be a given type.\"\"\"\n    if not isinstance(value, value_type):\n        if type(value_type) is tuple:\n            types = ', '.join(t.__name__ for t in value_type)\n            raise ValueError('{0} must be one of ({1})'.format(name, types))\n        else:\n            raise ValueError('{0} must be {1}'\n                             .format(name, value_type.__name__))", "code_tokens": ["def", "_assert_is_type", "(", "name", ",", "value", ",", "value_type", ")", ":", "if", "not", "isinstance", "(", "value", ",", "value_type", ")", ":", "if", "type", "(", "value_type", ")", "is", "tuple", ":", "types", "=", "',", "'", ".", "join", "(", "t", ".", "__name__", "for", "t", "in", "value_type", ")", "raise", "ValueError", "(", "'{0}", "must", "be", "one", "of", "({1})'", ".", "format", "(", "name", ",", "types", ")", ")", "else", ":", "raise", "ValueError", "(", "'{0}", "must", "be", "{1}'", ".", "format", "(", "name", ",", "value_type", ".", "__name__", ")", ")"], "idx": 1519}
{"url": "cosqa-train-18243", "docstring_tokens": ["Return", "True", "if", "the", "given", "DataFrame", "has", "a", "column", "of", "the", "given", "name", "(", "string", ")", "and", "there", "exists", "at", "least", "one", "non", "-", "NaN", "value", "in", "that", "column", ";", "return", "False", "otherwise", "."], "code": "def is_not_null(df: DataFrame, col_name: str) -> bool:\n    \"\"\"\n    Return ``True`` if the given DataFrame has a column of the given\n    name (string), and there exists at least one non-NaN value in that\n    column; return ``False`` otherwise.\n    \"\"\"\n    if (\n        isinstance(df, pd.DataFrame)\n        and col_name in df.columns\n        and df[col_name].notnull().any()\n    ):\n        return True\n    else:\n        return False", "code_tokens": ["def", "is_not_null", "(", "df", ":", "DataFrame", ",", "col_name", ":", "str", ")", "->", "bool", ":", "if", "(", "isinstance", "(", "df", ",", "pd", ".", "DataFrame", ")", "and", "col_name", "in", "df", ".", "columns", "and", "df", "[", "col_name", "]", ".", "notnull", "(", ")", ".", "any", "(", ")", ")", ":", "return", "True", "else", ":", "return", "False"], "idx": 5659}
{"url": "cosqa-train-5613", "docstring_tokens": ["Creates", "sql", "datetime2", "object", "from", "Python", "datetime", "object", "ignoring", "timezone"], "code": "def from_pydatetime(cls, pydatetime):\n        \"\"\"\n        Creates sql datetime2 object from Python datetime object\n        ignoring timezone\n        @param pydatetime: Python datetime object\n        @return: sql datetime2 object\n        \"\"\"\n        return cls(date=Date.from_pydate(pydatetime.date),\n                   time=Time.from_pytime(pydatetime.time))", "code_tokens": ["def", "from_pydatetime", "(", "cls", ",", "pydatetime", ")", ":", "return", "cls", "(", "date", "=", "Date", ".", "from_pydate", "(", "pydatetime", ".", "date", ")", ",", "time", "=", "Time", ".", "from_pytime", "(", "pydatetime", ".", "time", ")", ")"], "idx": 2647}
{"url": "cosqa-train-11293", "docstring_tokens": ["Print", "dicttree", "in", "Json", "-", "like", "format", ".", "keys", "are", "sorted"], "code": "def prettyprint(d):\n        \"\"\"Print dicttree in Json-like format. keys are sorted\n        \"\"\"\n        print(json.dumps(d, sort_keys=True, \n                         indent=4, separators=(\",\" , \": \")))", "code_tokens": ["def", "prettyprint", "(", "d", ")", ":", "print", "(", "json", ".", "dumps", "(", "d", ",", "sort_keys", "=", "True", ",", "indent", "=", "4", ",", "separators", "=", "(", "\",\"", ",", "\":", "\"", ")", ")", ")"], "idx": 2227}
{"url": "cosqa-train-15992", "docstring_tokens": ["Set", "x", "-", "axis", "limits", "of", "a", "subplot", "."], "code": "def set_xlimits(self, row, column, min=None, max=None):\n        \"\"\"Set x-axis limits of a subplot.\n\n        :param row,column: specify the subplot.\n        :param min: minimal axis value\n        :param max: maximum axis value\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.set_xlimits(min, max)", "code_tokens": ["def", "set_xlimits", "(", "self", ",", "row", ",", "column", ",", "min", "=", "None", ",", "max", "=", "None", ")", ":", "subplot", "=", "self", ".", "get_subplot_at", "(", "row", ",", "column", ")", "subplot", ".", "set_xlimits", "(", "min", ",", "max", ")"], "idx": 3455}
{"url": "cosqa-dev-183", "docstring_tokens": ["Computes", "l2", "norm", "of", "params", "by", "flattening", "them", "into", "a", "vector", "."], "code": "def l2_norm(params):\n    \"\"\"Computes l2 norm of params by flattening them into a vector.\"\"\"\n    flattened, _ = flatten(params)\n    return np.dot(flattened, flattened)", "code_tokens": ["def", "l2_norm", "(", "params", ")", ":", "flattened", ",", "_", "=", "flatten", "(", "params", ")", "return", "np", ".", "dot", "(", "flattened", ",", "flattened", ")"], "idx": 3651}
{"url": "cosqa-train-13850", "docstring_tokens": ["Ajout", "d", "un", "message", "de", "log", "de", "type", "INFO"], "code": "def info(self, text):\n\t\t\"\"\" Ajout d'un message de log de type INFO \"\"\"\n\t\tself.logger.info(\"{}{}\".format(self.message_prefix, text))", "code_tokens": ["def", "info", "(", "self", ",", "text", ")", ":", "self", ".", "logger", ".", "info", "(", "\"{}{}\"", ".", "format", "(", "self", ".", "message_prefix", ",", "text", ")", ")"], "idx": 3865}
{"url": "cosqa-train-18125", "docstring_tokens": ["Swap", "the", "methods", "atom", "to", "remove", "method", "with", "key", "."], "code": "def __remove_method(m: lmap.Map, key: T) -> lmap.Map:\n        \"\"\"Swap the methods atom to remove method with key.\"\"\"\n        return m.dissoc(key)", "code_tokens": ["def", "__remove_method", "(", "m", ":", "lmap", ".", "Map", ",", "key", ":", "T", ")", "->", "lmap", ".", "Map", ":", "return", "m", ".", "dissoc", "(", "key", ")"], "idx": 5911}
{"url": "cosqa-train-10987", "docstring_tokens": ["convert", "a", "ctypes", "structure", "to", "a", "dictionary"], "code": "def struct2dict(struct):\n    \"\"\"convert a ctypes structure to a dictionary\"\"\"\n    return {x: getattr(struct, x) for x in dict(struct._fields_).keys()}", "code_tokens": ["def", "struct2dict", "(", "struct", ")", ":", "return", "{", "x", ":", "getattr", "(", "struct", ",", "x", ")", "for", "x", "in", "dict", "(", "struct", ".", "_fields_", ")", ".", "keys", "(", ")", "}"], "idx": 3597}
{"url": "cosqa-train-10674", "docstring_tokens": ["initializes", "3D", "plot"], "code": "def plot3d_init(fignum):\n    \"\"\"\n    initializes 3D plot\n    \"\"\"\n    from mpl_toolkits.mplot3d import Axes3D\n    fig = plt.figure(fignum)\n    ax = fig.add_subplot(111, projection='3d')\n    return ax", "code_tokens": ["def", "plot3d_init", "(", "fignum", ")", ":", "from", "mpl_toolkits", ".", "mplot3d", "import", "Axes3D", "fig", "=", "plt", ".", "figure", "(", "fignum", ")", "ax", "=", "fig", ".", "add_subplot", "(", "111", ",", "projection", "=", "'3d'", ")", "return", "ax"], "idx": 3693}
{"url": "cosqa-train-15321", "docstring_tokens": ["Get", "the", "month", "start", "date", "a", "nd", "end", "date"], "code": "def get_month_start_end_day():\n    \"\"\"\n    Get the month start date a nd end date\n    \"\"\"\n    t = date.today()\n    n = mdays[t.month]\n    return (date(t.year, t.month, 1), date(t.year, t.month, n))", "code_tokens": ["def", "get_month_start_end_day", "(", ")", ":", "t", "=", "date", ".", "today", "(", ")", "n", "=", "mdays", "[", "t", ".", "month", "]", "return", "(", "date", "(", "t", ".", "year", ",", "t", ".", "month", ",", "1", ")", ",", "date", "(", "t", ".", "year", ",", "t", ".", "month", ",", "n", ")", ")"], "idx": 405}
{"url": "cosqa-train-16144", "docstring_tokens": ["Remove", "duplicates", "from", "an", "iterable", "preserving", "the", "order", "."], "code": "def delete_duplicates(seq):\n    \"\"\"\n    Remove duplicates from an iterable, preserving the order.\n\n    Args:\n        seq: Iterable of various type.\n\n    Returns:\n        list: List of unique objects.\n\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": ["def", "delete_duplicates", "(", "seq", ")", ":", "seen", "=", "set", "(", ")", "seen_add", "=", "seen", ".", "add", "return", "[", "x", "for", "x", "in", "seq", "if", "not", "(", "x", "in", "seen", "or", "seen_add", "(", "x", ")", ")", "]"], "idx": 394}
{"url": "cosqa-train-15205", "docstring_tokens": ["Pull", "a", "form", "value", "from", "the", "request", "."], "code": "def parse_form(self, req, name, field):\n        \"\"\"Pull a form value from the request.\"\"\"\n        return get_value(req.body_arguments, name, field)", "code_tokens": ["def", "parse_form", "(", "self", ",", "req", ",", "name", ",", "field", ")", ":", "return", "get_value", "(", "req", ".", "body_arguments", ",", "name", ",", "field", ")"], "idx": 1464}
{"url": "cosqa-train-343", "docstring_tokens": ["Python2", "accumulate", "implementation", "taken", "from", "https", ":", "//", "docs", ".", "python", ".", "org", "/", "3", "/", "library", "/", "itertools", ".", "html#itertools", ".", "accumulate"], "code": "def _accumulate(sequence, func):\n    \"\"\"\n    Python2 accumulate implementation taken from\n    https://docs.python.org/3/library/itertools.html#itertools.accumulate\n    \"\"\"\n    iterator = iter(sequence)\n    total = next(iterator)\n    yield total\n    for element in iterator:\n        total = func(total, element)\n        yield total", "code_tokens": ["def", "_accumulate", "(", "sequence", ",", "func", ")", ":", "iterator", "=", "iter", "(", "sequence", ")", "total", "=", "next", "(", "iterator", ")", "yield", "total", "for", "element", "in", "iterator", ":", "total", "=", "func", "(", "total", ",", "element", ")", "yield", "total"], "idx": 325}
{"url": "cosqa-train-8679", "docstring_tokens": ["Create", ":", "class", ":", "PNG", "from", "raw", "bytes", ".", ":", "arg", "bytes", "b", ":", "The", "raw", "bytes", "of", "the", "PNG", "file", ".", ":", "rtype", ":", ":", "class", ":", "PNG"], "code": "def from_bytes(cls, b):\n\t\t\"\"\"Create :class:`PNG` from raw bytes.\n\t\t\n\t\t:arg bytes b: The raw bytes of the PNG file.\n\t\t:rtype: :class:`PNG`\n\t\t\"\"\"\n\t\tim = cls()\n\t\tim.chunks = list(parse_chunks(b))\n\t\tim.init()\n\t\treturn im", "code_tokens": ["def", "from_bytes", "(", "cls", ",", "b", ")", ":", "im", "=", "cls", "(", ")", "im", ".", "chunks", "=", "list", "(", "parse_chunks", "(", "b", ")", ")", "im", ".", "init", "(", ")", "return", "im"], "idx": 907}
{"url": "cosqa-train-13081", "docstring_tokens": ["Get", "the", "modified", "time", "for", "a", "file", "as", "a", "datetime", "instance"], "code": "def get_time(filename):\n\t\"\"\"\n\tGet the modified time for a file as a datetime instance\n\t\"\"\"\n\tts = os.stat(filename).st_mtime\n\treturn datetime.datetime.utcfromtimestamp(ts)", "code_tokens": ["def", "get_time", "(", "filename", ")", ":", "ts", "=", "os", ".", "stat", "(", "filename", ")", ".", "st_mtime", "return", "datetime", ".", "datetime", ".", "utcfromtimestamp", "(", "ts", ")"], "idx": 1794}
{"url": "cosqa-train-8766", "docstring_tokens": ["Returns", "the", "first", "line", "of", "a", "file", "."], "code": "def getfirstline(file, default):\n    \"\"\"\n    Returns the first line of a file.\n    \"\"\"\n    with open(file, 'rb') as fh:\n        content = fh.readlines()\n        if len(content) == 1:\n            return content[0].decode('utf-8').strip('\\n')\n\n    return default", "code_tokens": ["def", "getfirstline", "(", "file", ",", "default", ")", ":", "with", "open", "(", "file", ",", "'rb'", ")", "as", "fh", ":", "content", "=", "fh", ".", "readlines", "(", ")", "if", "len", "(", "content", ")", "==", "1", ":", "return", "content", "[", "0", "]", ".", "decode", "(", "'utf-8'", ")", ".", "strip", "(", "'\\n'", ")", "return", "default"], "idx": 971}
{"url": "cosqa-train-12454", "docstring_tokens": ["Batches", "a", "list", "into", "a", "list", "of", "lists", "with", "sub", "-", "lists", "sized", "by", "a", "specified", "batch", "size", "."], "code": "def batch(items, size):\n    \"\"\"Batches a list into a list of lists, with sub-lists sized by a specified\n    batch size.\"\"\"\n    return [items[x:x + size] for x in xrange(0, len(items), size)]", "code_tokens": ["def", "batch", "(", "items", ",", "size", ")", ":", "return", "[", "items", "[", "x", ":", "x", "+", "size", "]", "for", "x", "in", "xrange", "(", "0", ",", "len", "(", "items", ")", ",", "size", ")", "]"], "idx": 654}
{"url": "cosqa-train-9774", "docstring_tokens": ["Get", "all", "versions", "of", "req", "from", "PyPI", "."], "code": "def all_versions(req):\n    \"\"\"Get all versions of req from PyPI.\"\"\"\n    import requests\n    url = \"https://pypi.python.org/pypi/\" + req + \"/json\"\n    return tuple(requests.get(url).json()[\"releases\"].keys())", "code_tokens": ["def", "all_versions", "(", "req", ")", ":", "import", "requests", "url", "=", "\"https://pypi.python.org/pypi/\"", "+", "req", "+", "\"/json\"", "return", "tuple", "(", "requests", ".", "get", "(", "url", ")", ".", "json", "(", ")", "[", "\"releases\"", "]", ".", "keys", "(", ")", ")"], "idx": 4321}
{"url": "cosqa-train-9835", "docstring_tokens": ["Sort", "the", "list", "into", "natural", "alphanumeric", "order", "."], "code": "def natural_sort(list, key=lambda s:s):\n    \"\"\"\n    Sort the list into natural alphanumeric order.\n    \"\"\"\n    def get_alphanum_key_func(key):\n        convert = lambda text: int(text) if text.isdigit() else text\n        return lambda s: [convert(c) for c in re.split('([0-9]+)', key(s))]\n    sort_key = get_alphanum_key_func(key)\n    list.sort(key=sort_key)", "code_tokens": ["def", "natural_sort", "(", "list", ",", "key", "=", "lambda", "s", ":", "s", ")", ":", "def", "get_alphanum_key_func", "(", "key", ")", ":", "convert", "=", "lambda", "text", ":", "int", "(", "text", ")", "if", "text", ".", "isdigit", "(", ")", "else", "text", "return", "lambda", "s", ":", "[", "convert", "(", "c", ")", "for", "c", "in", "re", ".", "split", "(", "'([0-9]+)'", ",", "key", "(", "s", ")", ")", "]", "sort_key", "=", "get_alphanum_key_func", "(", "key", ")", "list", ".", "sort", "(", "key", "=", "sort_key", ")"], "idx": 4334}
{"url": "cosqa-train-12074", "docstring_tokens": ["Returns", "True", "if", "pip", "exists", "inside", "the", "virtual", "environment", ".", "Can", "be", "used", "as", "a", "naive", "way", "to", "verify", "that", "the", "environment", "is", "installed", "."], "code": "def _pip_exists(self):\n        \"\"\"Returns True if pip exists inside the virtual environment. Can be\n        used as a naive way to verify that the environment is installed.\"\"\"\n        return os.path.isfile(os.path.join(self.path, 'bin', 'pip'))", "code_tokens": ["def", "_pip_exists", "(", "self", ")", ":", "return", "os", ".", "path", ".", "isfile", "(", "os", ".", "path", ".", "join", "(", "self", ".", "path", ",", "'bin'", ",", "'pip'", ")", ")"], "idx": 239}
{"url": "cosqa-train-14676", "docstring_tokens": ["Takes", "in", "an", "object", "and", "a", "variable", "length", "amount", "of", "named", "attributes", "and", "checks", "to", "see", "if", "the", "object", "has", "each", "property", ".", "If", "any", "of", "the", "attributes", "are", "missing", "this", "returns", "false", "."], "code": "def hasattrs(object, *names):\n    \"\"\"\n    Takes in an object and a variable length amount of named attributes,\n    and checks to see if the object has each property. If any of the\n    attributes are missing, this returns false.\n\n    :param object: an object that may or may not contain the listed attributes\n    :param names: a variable amount of attribute names to check for\n    :return: True if the object contains each named attribute, false otherwise\n    \"\"\"\n    for name in names:\n        if not hasattr(object, name):\n            return False\n    return True", "code_tokens": ["def", "hasattrs", "(", "object", ",", "*", "names", ")", ":", "for", "name", "in", "names", ":", "if", "not", "hasattr", "(", "object", ",", "name", ")", ":", "return", "False", "return", "True"], "idx": 178}
{"url": "cosqa-train-18994", "docstring_tokens": [">>>", "list", "=", "[", "0", "0", "7", "]", ">>>", "list_to_str", "(", "list", ")", "0", "0", "7"], "code": "def list_to_str(list, separator=','):\n    \"\"\"\n    >>> list = [0, 0, 7]\n    >>> list_to_str(list)\n    '0,0,7'\n    \"\"\"\n    list = [str(x) for x in list]\n    return separator.join(list)", "code_tokens": ["def", "list_to_str", "(", "list", ",", "separator", "=", "','", ")", ":", "list", "=", "[", "str", "(", "x", ")", "for", "x", "in", "list", "]", "return", "separator", ".", "join", "(", "list", ")"], "idx": 5700}
{"url": "cosqa-train-18856", "docstring_tokens": ["Check", "if", "enough", "time", "has", "elapsed", "to", "perform", "a", "check", "()", "."], "code": "def needs_check(self):\n        \"\"\"\n        Check if enough time has elapsed to perform a check().\n\n        If this time has elapsed, a state change check through\n        has_state_changed() should be performed and eventually a sync().\n\n        :rtype: boolean\n        \"\"\"\n        if self.lastcheck is None:\n            return True\n        return time.time() - self.lastcheck >= self.ipchangedetection_sleep", "code_tokens": ["def", "needs_check", "(", "self", ")", ":", "if", "self", ".", "lastcheck", "is", "None", ":", "return", "True", "return", "time", ".", "time", "(", ")", "-", "self", ".", "lastcheck", ">=", "self", ".", "ipchangedetection_sleep"], "idx": 6125}
{"url": "cosqa-train-11191", "docstring_tokens": ["Execute", "the", "SQL", "command", "and", "return", "the", "data", "rows", "as", "tuples"], "code": "def execute(self, cmd, *args, **kwargs):\n        \"\"\" Execute the SQL command and return the data rows as tuples\n        \"\"\"\n        self.cursor.execute(cmd, *args, **kwargs)", "code_tokens": ["def", "execute", "(", "self", ",", "cmd", ",", "*", "args", ",", "*", "*", "kwargs", ")", ":", "self", ".", "cursor", ".", "execute", "(", "cmd", ",", "*", "args", ",", "*", "*", "kwargs", ")"], "idx": 4611}
{"url": "cosqa-train-8861", "docstring_tokens": ["Return", "list", "of", "Logger", "classes", "."], "code": "def _get_loggers():\n    \"\"\"Return list of Logger classes.\"\"\"\n    from .. import loader\n    modules = loader.get_package_modules('logger')\n    return list(loader.get_plugins(modules, [_Logger]))", "code_tokens": ["def", "_get_loggers", "(", ")", ":", "from", ".", ".", "import", "loader", "modules", "=", "loader", ".", "get_package_modules", "(", "'logger'", ")", "return", "list", "(", "loader", ".", "get_plugins", "(", "modules", ",", "[", "_Logger", "]", ")", ")"], "idx": 1928}
{"url": "cosqa-train-9435", "docstring_tokens": ["Parses", "a", "date", "string", "formatted", "like", "YYYY", "-", "MM", "-", "DD", "."], "code": "def parse(self, s):\n        \"\"\"\n        Parses a date string formatted like ``YYYY-MM-DD``.\n        \"\"\"\n        return datetime.datetime.strptime(s, self.date_format).date()", "code_tokens": ["def", "parse", "(", "self", ",", "s", ")", ":", "return", "datetime", ".", "datetime", ".", "strptime", "(", "s", ",", "self", ".", "date_format", ")", ".", "date", "(", ")"], "idx": 107}
{"url": "cosqa-train-16197", "docstring_tokens": ["Is", "this", "an", "integer", "."], "code": "def is_integer(obj):\n    \"\"\"Is this an integer.\n\n    :param object obj:\n    :return:\n    \"\"\"\n    if PYTHON3:\n        return isinstance(obj, int)\n    return isinstance(obj, (int, long))", "code_tokens": ["def", "is_integer", "(", "obj", ")", ":", "if", "PYTHON3", ":", "return", "isinstance", "(", "obj", ",", "int", ")", "return", "isinstance", "(", "obj", ",", "(", "int", ",", "long", ")", ")"], "idx": 2128}
{"url": "cosqa-train-7375", "docstring_tokens": ["Find", "the", "leftmost", "index", "of", "an", "element", "in", "a", "list", "using", "binary", "search", "."], "code": "def bisect_index(a, x):\n    \"\"\" Find the leftmost index of an element in a list using binary search.\n\n    Parameters\n    ----------\n    a: list\n        A sorted list.\n    x: arbitrary\n        The element.\n\n    Returns\n    -------\n    int\n        The index.\n\n    \"\"\"\n    i = bisect.bisect_left(a, x)\n    if i != len(a) and a[i] == x:\n        return i\n    raise ValueError", "code_tokens": ["def", "bisect_index", "(", "a", ",", "x", ")", ":", "i", "=", "bisect", ".", "bisect_left", "(", "a", ",", "x", ")", "if", "i", "!=", "len", "(", "a", ")", "and", "a", "[", "i", "]", "==", "x", ":", "return", "i", "raise", "ValueError"], "idx": 1588}
{"url": "cosqa-train-13709", "docstring_tokens": ["Get", "a", "single", "document", "from", "the", "collection", "this", "class", "is", "bound", "to", ".", "Additional", "arguments", "are", "processed", "according", "to", "_prepare_find", "prior", "to", "passing", "to", "PyMongo", "where", "positional", "parameters", "are", "interpreted", "as", "query", "fragments", "parametric", "keyword", "arguments", "combined", "and", "other", "keyword", "arguments", "passed", "along", "with", "minor", "transformation", ".", "Automatically", "calls", "to_mongo", "with", "the", "retrieved", "data", ".", "https", ":", "//", "api", ".", "mongodb", ".", "com", "/", "python", "/", "current", "/", "api", "/", "pymongo", "/", "collection", ".", "html#pymongo", ".", "collection", ".", "Collection", ".", "find_one"], "code": "def find_one(cls, *args, **kw):\n\t\t\"\"\"Get a single document from the collection this class is bound to.\n\t\t\n\t\tAdditional arguments are processed according to `_prepare_find` prior to passing to PyMongo, where positional\n\t\tparameters are interpreted as query fragments, parametric keyword arguments combined, and other keyword\n\t\targuments passed along with minor transformation.\n\t\t\n\t\tAutomatically calls `to_mongo` with the retrieved data.\n\t\t\n\t\thttps://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.find_one\n\t\t\"\"\"\n\t\t\n\t\tif len(args) == 1 and not isinstance(args[0], Filter):\n\t\t\targs = (getattr(cls, cls.__pk__) == args[0], )\n\t\t\n\t\tDoc, collection, query, options = cls._prepare_find(*args, **kw)\n\t\tresult = Doc.from_mongo(collection.find_one(query, **options))\n\t\t\n\t\treturn result", "code_tokens": ["def", "find_one", "(", "cls", ",", "*", "args", ",", "*", "*", "kw", ")", ":", "if", "len", "(", "args", ")", "==", "1", "and", "not", "isinstance", "(", "args", "[", "0", "]", ",", "Filter", ")", ":", "args", "=", "(", "getattr", "(", "cls", ",", "cls", ".", "__pk__", ")", "==", "args", "[", "0", "]", ",", ")", "Doc", ",", "collection", ",", "query", ",", "options", "=", "cls", ".", "_prepare_find", "(", "*", "args", ",", "*", "*", "kw", ")", "result", "=", "Doc", ".", "from_mongo", "(", "collection", ".", "find_one", "(", "query", ",", "*", "*", "options", ")", ")", "return", "result"], "idx": 4414}
{"url": "cosqa-train-13133", "docstring_tokens": ["Returns", "HTML", "from", "MediaWiki", "markup"], "code": "def parse(text, showToc=True):\n\t\"\"\"Returns HTML from MediaWiki markup\"\"\"\n\tp = Parser(show_toc=showToc)\n\treturn p.parse(text)", "code_tokens": ["def", "parse", "(", "text", ",", "showToc", "=", "True", ")", ":", "p", "=", "Parser", "(", "show_toc", "=", "showToc", ")", "return", "p", ".", "parse", "(", "text", ")"], "idx": 4798}
{"url": "cosqa-train-13001", "docstring_tokens": ["Refresh", "the", "screen", ".", "You", "don", "t", "need", "to", "override", "this", "except", "to", "update", "only", "small", "portins", "of", "the", "screen", "."], "code": "def update_screen(self):\n        \"\"\"Refresh the screen. You don't need to override this except to update only small portins of the screen.\"\"\"\n        self.clock.tick(self.FPS)\n        pygame.display.update()", "code_tokens": ["def", "update_screen", "(", "self", ")", ":", "self", ".", "clock", ".", "tick", "(", "self", ".", "FPS", ")", "pygame", ".", "display", ".", "update", "(", ")"], "idx": 1913}
{"url": "cosqa-train-7669", "docstring_tokens": ["Sets", "all", "defaults", "for", "the", "given", "dictionary", "to", "those", "contained", "in", "a", "second", "defaults", "dictionary", ".", "This", "convenience", "method", "calls", ":"], "code": "def setDictDefaults (d, defaults):\n  \"\"\"Sets all defaults for the given dictionary to those contained in a\n  second defaults dictionary.  This convenience method calls:\n\n    d.setdefault(key, value)\n\n  for each key and value in the given defaults dictionary.\n  \"\"\"\n  for key, val in defaults.items():\n    d.setdefault(key, val)\n\n  return d", "code_tokens": ["def", "setDictDefaults", "(", "d", ",", "defaults", ")", ":", "for", "key", ",", "val", "in", "defaults", ".", "items", "(", ")", ":", "d", ".", "setdefault", "(", "key", ",", "val", ")", "return", "d"], "idx": 3846}
{"url": "cosqa-train-11996", "docstring_tokens": ["given", "a", "segment", "(", "rectangle", ")", "and", "an", "image", "returns", "it", "s", "corresponding", "subimage"], "code": "def region_from_segment(image, segment):\n    \"\"\"given a segment (rectangle) and an image, returns it's corresponding subimage\"\"\"\n    x, y, w, h = segment\n    return image[y:y + h, x:x + w]", "code_tokens": ["def", "region_from_segment", "(", "image", ",", "segment", ")", ":", "x", ",", "y", ",", "w", ",", "h", "=", "segment", "return", "image", "[", "y", ":", "y", "+", "h", ",", "x", ":", "x", "+", "w", "]"], "idx": 941}
{"url": "cosqa-train-14675", "docstring_tokens": ["Convenience", "function", "that", "removes", "a", "dicts", "keys", "that", "have", "falsy", "values"], "code": "def _clean_dict(target_dict, whitelist=None):\n    \"\"\" Convenience function that removes a dicts keys that have falsy values\n    \"\"\"\n    assert isinstance(target_dict, dict)\n    return {\n        ustr(k).strip(): ustr(v).strip()\n        for k, v in target_dict.items()\n        if v not in (None, Ellipsis, [], (), \"\")\n        and (not whitelist or k in whitelist)\n    }", "code_tokens": ["def", "_clean_dict", "(", "target_dict", ",", "whitelist", "=", "None", ")", ":", "assert", "isinstance", "(", "target_dict", ",", "dict", ")", "return", "{", "ustr", "(", "k", ")", ".", "strip", "(", ")", ":", "ustr", "(", "v", ")", ".", "strip", "(", ")", "for", "k", ",", "v", "in", "target_dict", ".", "items", "(", ")", "if", "v", "not", "in", "(", "None", ",", "Ellipsis", ",", "[", "]", ",", "(", ")", ",", "\"\"", ")", "and", "(", "not", "whitelist", "or", "k", "in", "whitelist", ")", "}"], "idx": 695}
{"url": "cosqa-train-11364", "docstring_tokens": ["A", "Bark", "logging", "handler", "logging", "output", "to", "a", "named", "file", ".", "At", "intervals", "specified", "by", "the", "when", "the", "file", "will", "be", "rotated", "under", "control", "of", "backupCount", "."], "code": "def timed_rotating_file_handler(name, logname, filename, when='h',\n                                interval=1, backupCount=0,\n                                encoding=None, delay=False, utc=False):\n    \"\"\"\n    A Bark logging handler logging output to a named file.  At\n    intervals specified by the 'when', the file will be rotated, under\n    control of 'backupCount'.\n\n    Similar to logging.handlers.TimedRotatingFileHandler.\n    \"\"\"\n\n    return wrap_log_handler(logging.handlers.TimedRotatingFileHandler(\n        filename, when=when, interval=interval, backupCount=backupCount,\n        encoding=encoding, delay=delay, utc=utc))", "code_tokens": ["def", "timed_rotating_file_handler", "(", "name", ",", "logname", ",", "filename", ",", "when", "=", "'h'", ",", "interval", "=", "1", ",", "backupCount", "=", "0", ",", "encoding", "=", "None", ",", "delay", "=", "False", ",", "utc", "=", "False", ")", ":", "return", "wrap_log_handler", "(", "logging", ".", "handlers", ".", "TimedRotatingFileHandler", "(", "filename", ",", "when", "=", "when", ",", "interval", "=", "interval", ",", "backupCount", "=", "backupCount", ",", "encoding", "=", "encoding", ",", "delay", "=", "delay", ",", "utc", "=", "utc", ")", ")"], "idx": 166}
{"url": "cosqa-dev-382", "docstring_tokens": ["Get", "a", "list", "of", "the", "data", "types", "for", "each", "column", "in", "*", "data", "*", "."], "code": "def _get_column_types(self, data):\n        \"\"\"Get a list of the data types for each column in *data*.\"\"\"\n        columns = list(zip_longest(*data))\n        return [self._get_column_type(column) for column in columns]", "code_tokens": ["def", "_get_column_types", "(", "self", ",", "data", ")", ":", "columns", "=", "list", "(", "zip_longest", "(", "*", "data", ")", ")", "return", "[", "self", ".", "_get_column_type", "(", "column", ")", "for", "column", "in", "columns", "]"], "idx": 461}
{"url": "cosqa-train-14453", "docstring_tokens": ["Delete", "the", "index", "if", "it", "exists", "."], "code": "def delete_index(self):\n        \"\"\"\n        Delete the index, if it exists.\n        \"\"\"\n        es = self._init_connection()\n        if es.indices.exists(index=self.index):\n            es.indices.delete(index=self.index)", "code_tokens": ["def", "delete_index", "(", "self", ")", ":", "es", "=", "self", ".", "_init_connection", "(", ")", "if", "es", ".", "indices", ".", "exists", "(", "index", "=", "self", ".", "index", ")", ":", "es", ".", "indices", ".", "delete", "(", "index", "=", "self", ".", "index", ")"], "idx": 5167}
{"url": "cosqa-train-10228", "docstring_tokens": ["Returns", "a", "Seaborn", "linear", "regression", "plot"], "code": "def _linear_seaborn_(self, label=None, style=None, opts=None):\n        \"\"\"\n        Returns a Seaborn linear regression plot\n        \"\"\"\n        xticks, yticks = self._get_ticks(opts)\n        try:\n            fig = sns.lmplot(self.x, self.y, data=self.df)\n            fig = self._set_with_height(fig, opts)\n            return fig\n        except Exception as e:\n            self.err(e, self.linear_,\n                     \"Can not draw linear regression chart\")", "code_tokens": ["def", "_linear_seaborn_", "(", "self", ",", "label", "=", "None", ",", "style", "=", "None", ",", "opts", "=", "None", ")", ":", "xticks", ",", "yticks", "=", "self", ".", "_get_ticks", "(", "opts", ")", "try", ":", "fig", "=", "sns", ".", "lmplot", "(", "self", ".", "x", ",", "self", ".", "y", ",", "data", "=", "self", ".", "df", ")", "fig", "=", "self", ".", "_set_with_height", "(", "fig", ",", "opts", ")", "return", "fig", "except", "Exception", "as", "e", ":", "self", ".", "err", "(", "e", ",", "self", ".", "linear_", ",", "\"Can", "not", "draw", "linear", "regression", "chart\"", ")"], "idx": 3277}
{"url": "cosqa-train-6824", "docstring_tokens": ["Given", "a", "gzipped", "stream", "of", "data", "yield", "streams", "of", "decompressed", "data", "."], "code": "def load_streams(chunks):\n    \"\"\"\n    Given a gzipped stream of data, yield streams of decompressed data.\n    \"\"\"\n    chunks = peekable(chunks)\n    while chunks:\n        if six.PY3:\n            dc = zlib.decompressobj(wbits=zlib.MAX_WBITS | 16)\n        else:\n            dc = zlib.decompressobj(zlib.MAX_WBITS | 16)\n        yield load_stream(dc, chunks)\n        if dc.unused_data:\n            chunks = peekable(itertools.chain((dc.unused_data,), chunks))", "code_tokens": ["def", "load_streams", "(", "chunks", ")", ":", "chunks", "=", "peekable", "(", "chunks", ")", "while", "chunks", ":", "if", "six", ".", "PY3", ":", "dc", "=", "zlib", ".", "decompressobj", "(", "wbits", "=", "zlib", ".", "MAX_WBITS", "|", "16", ")", "else", ":", "dc", "=", "zlib", ".", "decompressobj", "(", "zlib", ".", "MAX_WBITS", "|", "16", ")", "yield", "load_stream", "(", "dc", ",", "chunks", ")", "if", "dc", ".", "unused_data", ":", "chunks", "=", "peekable", "(", "itertools", ".", "chain", "(", "(", "dc", ".", "unused_data", ",", ")", ",", "chunks", ")", ")"], "idx": 3586}
{"url": "cosqa-train-8526", "docstring_tokens": ["split", "string", "*", "s", "*", "into", "list", "of", "strings", "no", "longer", "than", "*", "length", "*"], "code": "def split_len(s, length):\n    \"\"\"split string *s* into list of strings no longer than *length*\"\"\"\n    return [s[i:i+length] for i in range(0, len(s), length)]", "code_tokens": ["def", "split_len", "(", "s", ",", "length", ")", ":", "return", "[", "s", "[", "i", ":", "i", "+", "length", "]", "for", "i", "in", "range", "(", "0", ",", "len", "(", "s", ")", ",", "length", ")", "]"], "idx": 3224}
{"url": "cosqa-train-8781", "docstring_tokens": ["Takes", "JSON", "formatted", "data", "converting", "it", "into", "native", "Python", "objects"], "code": "def json(body, charset='utf-8', **kwargs):\n    \"\"\"Takes JSON formatted data, converting it into native Python objects\"\"\"\n    return json_converter.loads(text(body, charset=charset))", "code_tokens": ["def", "json", "(", "body", ",", "charset", "=", "'utf-8'", ",", "*", "*", "kwargs", ")", ":", "return", "json_converter", ".", "loads", "(", "text", "(", "body", ",", "charset", "=", "charset", ")", ")"], "idx": 2057}
{"url": "cosqa-train-11211", "docstring_tokens": ["Args", ":", "img", "(", "PIL", "Image", ")", ":", "Image", "to", "be", "padded", "."], "code": "def __call__(self, img):\n        \"\"\"\n        Args:\n            img (PIL Image): Image to be padded.\n\n        Returns:\n            PIL Image: Padded image.\n        \"\"\"\n        return F.pad(img, self.padding, self.fill, self.padding_mode)", "code_tokens": ["def", "__call__", "(", "self", ",", "img", ")", ":", "return", "F", ".", "pad", "(", "img", ",", "self", ".", "padding", ",", "self", ".", "fill", ",", "self", ".", "padding_mode", ")"], "idx": 2553}
{"url": "cosqa-train-8082", "docstring_tokens": ["Removes", "a", ":", "py", ":", "class", ":", ".", "Series", "from", "the", "chart", "."], "code": "def remove_series(self, series):\n        \"\"\"Removes a :py:class:`.Series` from the chart.\n\n        :param Series series: The :py:class:`.Series` to remove.\n        :raises ValueError: if you try to remove the last\\\n        :py:class:`.Series`.\"\"\"\n\n        if len(self.all_series()) == 1:\n            raise ValueError(\"Cannot remove last series from %s\" % str(self))\n        self._all_series.remove(series)\n        series._chart = None", "code_tokens": ["def", "remove_series", "(", "self", ",", "series", ")", ":", "if", "len", "(", "self", ".", "all_series", "(", ")", ")", "==", "1", ":", "raise", "ValueError", "(", "\"Cannot", "remove", "last", "series", "from", "%s\"", "%", "str", "(", "self", ")", ")", "self", ".", "_all_series", ".", "remove", "(", "series", ")", "series", ".", "_chart", "=", "None"], "idx": 1100}
{"url": "cosqa-train-4463", "docstring_tokens": ["Check", "the", "validity", "of", "an", "IPv6", "address"], "code": "def is_valid_ipv6(ip_str):\n    \"\"\"\n    Check the validity of an IPv6 address\n    \"\"\"\n    try:\n        socket.inet_pton(socket.AF_INET6, ip_str)\n    except socket.error:\n        return False\n    return True", "code_tokens": ["def", "is_valid_ipv6", "(", "ip_str", ")", ":", "try", ":", "socket", ".", "inet_pton", "(", "socket", ".", "AF_INET6", ",", "ip_str", ")", "except", "socket", ".", "error", ":", "return", "False", "return", "True"], "idx": 1249}
{"url": "cosqa-train-12359", "docstring_tokens": ["Does", "a", "string", "replace", "with", "a", "list", "of", "search", "and", "replacements"], "code": "def multi_replace(instr, search_list=[], repl_list=None):\n    \"\"\"\n    Does a string replace with a list of search and replacements\n\n    TODO: rename\n    \"\"\"\n    repl_list = [''] * len(search_list) if repl_list is None else repl_list\n    for ser, repl in zip(search_list, repl_list):\n        instr = instr.replace(ser, repl)\n    return instr", "code_tokens": ["def", "multi_replace", "(", "instr", ",", "search_list", "=", "[", "]", ",", "repl_list", "=", "None", ")", ":", "repl_list", "=", "[", "''", "]", "*", "len", "(", "search_list", ")", "if", "repl_list", "is", "None", "else", "repl_list", "for", "ser", ",", "repl", "in", "zip", "(", "search_list", ",", "repl_list", ")", ":", "instr", "=", "instr", ".", "replace", "(", "ser", ",", "repl", ")", "return", "instr"], "idx": 1023}
{"url": "cosqa-train-13512", "docstring_tokens": ["Format", "a", "message", "in", "the", "log"], "code": "def format(self, record, *args, **kwargs):\n        \"\"\"\n        Format a message in the log\n\n        Act like the normal format, but indent anything that is a\n        newline within the message.\n\n        \"\"\"\n        return logging.Formatter.format(\n            self, record, *args, **kwargs).replace('\\n', '\\n' + ' ' * 8)", "code_tokens": ["def", "format", "(", "self", ",", "record", ",", "*", "args", ",", "*", "*", "kwargs", ")", ":", "return", "logging", ".", "Formatter", ".", "format", "(", "self", ",", "record", ",", "*", "args", ",", "*", "*", "kwargs", ")", ".", "replace", "(", "'\\n'", ",", "'\\n'", "+", "'", "'", "*", "8", ")"], "idx": 748}
{"url": "cosqa-train-16237", "docstring_tokens": ["Return", "lines", "of", "a", "file", "with", "whitespace", "removed"], "code": "def get_stripped_file_lines(filename):\n    \"\"\"\n    Return lines of a file with whitespace removed\n    \"\"\"\n    try:\n        lines = open(filename).readlines()\n    except FileNotFoundError:\n        fatal(\"Could not open file: {!r}\".format(filename))\n\n    return [line.strip() for line in lines]", "code_tokens": ["def", "get_stripped_file_lines", "(", "filename", ")", ":", "try", ":", "lines", "=", "open", "(", "filename", ")", ".", "readlines", "(", ")", "except", "FileNotFoundError", ":", "fatal", "(", "\"Could", "not", "open", "file:", "{!r}\"", ".", "format", "(", "filename", ")", ")", "return", "[", "line", ".", "strip", "(", ")", "for", "line", "in", "lines", "]"], "idx": 3099}
{"url": "cosqa-train-13661", "docstring_tokens": ["Returns", "the", "index", "of", "a", "geometry", "in", "a", "list", "of", "geometries", "avoiding", "expensive", "equality", "checks", "of", "in", "operator", "."], "code": "def find_geom(geom, geoms):\n    \"\"\"\n    Returns the index of a geometry in a list of geometries avoiding\n    expensive equality checks of `in` operator.\n    \"\"\"\n    for i, g in enumerate(geoms):\n        if g is geom:\n            return i", "code_tokens": ["def", "find_geom", "(", "geom", ",", "geoms", ")", ":", "for", "i", ",", "g", "in", "enumerate", "(", "geoms", ")", ":", "if", "g", "is", "geom", ":", "return", "i"], "idx": 1272}
{"url": "cosqa-train-9723", "docstring_tokens": ["Utility", "function", "to", "remove", "duplicates", "from", "a", "list", ":", "param", "seq", ":", "The", "sequence", "(", "list", ")", "to", "deduplicate", ":", "return", ":", "A", "list", "with", "original", "duplicates", "removed"], "code": "def dedupe_list(seq):\n    \"\"\"\n    Utility function to remove duplicates from a list\n    :param seq: The sequence (list) to deduplicate\n    :return: A list with original duplicates removed\n    \"\"\"\n    seen = set()\n    return [x for x in seq if not (x in seen or seen.add(x))]", "code_tokens": ["def", "dedupe_list", "(", "seq", ")", ":", "seen", "=", "set", "(", ")", "return", "[", "x", "for", "x", "in", "seq", "if", "not", "(", "x", "in", "seen", "or", "seen", ".", "add", "(", "x", ")", ")", "]"], "idx": 1450}
{"url": "cosqa-train-17563", "docstring_tokens": ["Return", "a", "dict", "with", "swapped", "keys", "and", "values"], "code": "def inverted_dict(d):\n    \"\"\"Return a dict with swapped keys and values\n\n    >>> inverted_dict({0: ('a', 'b'), 1: 'cd'}) == {'cd': 1, ('a', 'b'): 0}\n    True\n    \"\"\"\n    return dict((force_hashable(v), k) for (k, v) in viewitems(dict(d)))", "code_tokens": ["def", "inverted_dict", "(", "d", ")", ":", "return", "dict", "(", "(", "force_hashable", "(", "v", ")", ",", "k", ")", "for", "(", "k", ",", "v", ")", "in", "viewitems", "(", "dict", "(", "d", ")", ")", ")"], "idx": 5553}
{"url": "cosqa-train-10714", "docstring_tokens": ["This", "turns", "off", "stdout", "buffering", "so", "that", "outputs", "are", "immediately", "materialized", "and", "log", "messages", "show", "up", "before", "the", "program", "exits"], "code": "def disable_stdout_buffering():\n    \"\"\"This turns off stdout buffering so that outputs are immediately\n    materialized and log messages show up before the program exits\"\"\"\n    stdout_orig = sys.stdout\n    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)\n    # NOTE(brandyn): This removes the original stdout\n    return stdout_orig", "code_tokens": ["def", "disable_stdout_buffering", "(", ")", ":", "stdout_orig", "=", "sys", ".", "stdout", "sys", ".", "stdout", "=", "os", ".", "fdopen", "(", "sys", ".", "stdout", ".", "fileno", "(", ")", ",", "'w'", ",", "0", ")", "#", "NOTE(brandyn):", "This", "removes", "the", "original", "stdout", "return", "stdout_orig"], "idx": 2887}
{"url": "cosqa-train-15275", "docstring_tokens": ["Generate", "a", "unique", "ID", "that", "is", "somewhat", "guaranteed", "to", "be", "unique", "among", "all", "instances", "running", "at", "the", "same", "time", "."], "code": "def generate_unique_host_id():\n    \"\"\"Generate a unique ID, that is somewhat guaranteed to be unique among all\n    instances running at the same time.\"\"\"\n    host = \".\".join(reversed(socket.gethostname().split(\".\")))\n    pid = os.getpid()\n    return \"%s.%d\" % (host, pid)", "code_tokens": ["def", "generate_unique_host_id", "(", ")", ":", "host", "=", "\".\"", ".", "join", "(", "reversed", "(", "socket", ".", "gethostname", "(", ")", ".", "split", "(", "\".\"", ")", ")", ")", "pid", "=", "os", ".", "getpid", "(", ")", "return", "\"%s.%d\"", "%", "(", "host", ",", "pid", ")"], "idx": 335}
{"url": "cosqa-train-13510", "docstring_tokens": ["Write", "text", ".", "An", "additional", "attribute", "terminator", "with", "a", "value", "of", "None", "is", "added", "to", "the", "logging", "record", "to", "indicate", "that", "StreamHandler", "should", "not", "add", "a", "newline", "."], "code": "def write(self, text):\n        \"\"\"Write text. An additional attribute terminator with a value of\n           None is added to the logging record to indicate that StreamHandler\n           should not add a newline.\"\"\"\n        self.logger.log(self.loglevel, text, extra={'terminator': None})", "code_tokens": ["def", "write", "(", "self", ",", "text", ")", ":", "self", ".", "logger", ".", "log", "(", "self", ".", "loglevel", ",", "text", ",", "extra", "=", "{", "'terminator'", ":", "None", "}", ")"], "idx": 2097}
{"url": "cosqa-train-238", "docstring_tokens": ["Function", "that", "verify", "if", "the", "header", "parameter", "is", "a", "essential", "header"], "code": "def required_header(header):\n    \"\"\"Function that verify if the header parameter is a essential header\n\n    :param header:  A string represented a header\n    :returns:       A boolean value that represent if the header is required\n    \"\"\"\n    if header in IGNORE_HEADERS:\n        return False\n\n    if header.startswith('HTTP_') or header == 'CONTENT_TYPE':\n        return True\n\n    return False", "code_tokens": ["def", "required_header", "(", "header", ")", ":", "if", "header", "in", "IGNORE_HEADERS", ":", "return", "False", "if", "header", ".", "startswith", "(", "'HTTP_'", ")", "or", "header", "==", "'CONTENT_TYPE'", ":", "return", "True", "return", "False"], "idx": 233}
{"url": "cosqa-train-11148", "docstring_tokens": ["Compare", "by", "iteration"], "code": "def compare(dicts):\n    \"\"\"Compare by iteration\"\"\"\n\n    common_members = {}\n    common_keys = reduce(lambda x, y: x & y, map(dict.keys, dicts))\n    for k in common_keys:\n        common_members[k] = list(\n            reduce(lambda x, y: x & y, [set(d[k]) for d in dicts]))\n\n    return common_members", "code_tokens": ["def", "compare", "(", "dicts", ")", ":", "common_members", "=", "{", "}", "common_keys", "=", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "&", "y", ",", "map", "(", "dict", ".", "keys", ",", "dicts", ")", ")", "for", "k", "in", "common_keys", ":", "common_members", "[", "k", "]", "=", "list", "(", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "&", "y", ",", "[", "set", "(", "d", "[", "k", "]", ")", "for", "d", "in", "dicts", "]", ")", ")", "return", "common_members"], "idx": 522}
{"url": "cosqa-train-1105", "docstring_tokens": ["Generate", "an", "endless", "sequence", "of", "random", "integers", "from", "permutations", "of", "the", "set", "[", "0", "...", "N", ")", "."], "code": "def endless_permutations(N, random_state=None):\n    \"\"\"\n    Generate an endless sequence of random integers from permutations of the\n    set [0, ..., N).\n\n    If we call this N times, we will sweep through the entire set without\n    replacement, on the (N+1)th call a new permutation will be created, etc.\n\n    Parameters\n    ----------\n    N: int\n        the length of the set\n    random_state: int or RandomState, optional\n        random seed\n\n    Yields\n    ------\n    int:\n        a random int from the set [0, ..., N)\n    \"\"\"\n    generator = check_random_state(random_state)\n    while True:\n        batch_inds = generator.permutation(N)\n        for b in batch_inds:\n            yield b", "code_tokens": ["def", "endless_permutations", "(", "N", ",", "random_state", "=", "None", ")", ":", "generator", "=", "check_random_state", "(", "random_state", ")", "while", "True", ":", "batch_inds", "=", "generator", ".", "permutation", "(", "N", ")", "for", "b", "in", "batch_inds", ":", "yield", "b"], "idx": 957}
{"url": "cosqa-train-4145", "docstring_tokens": ["Remove", "duplicates", "from", "a", "list", "preserving", "the", "order", "."], "code": "def dedupe_list(l):\n    \"\"\"Remove duplicates from a list preserving the order.\n\n    We might be tempted to use the list(set(l)) idiom, but it doesn't preserve\n    the order, which hinders testability and does not work for lists with\n    unhashable elements.\n    \"\"\"\n    result = []\n\n    for el in l:\n        if el not in result:\n            result.append(el)\n\n    return result", "code_tokens": ["def", "dedupe_list", "(", "l", ")", ":", "result", "=", "[", "]", "for", "el", "in", "l", ":", "if", "el", "not", "in", "result", ":", "result", ".", "append", "(", "el", ")", "return", "result"], "idx": 721}
{"url": "cosqa-train-13164", "docstring_tokens": ["Get", "the", "value", "of", "a", "local", "variable", "somewhere", "in", "the", "call", "stack", "."], "code": "def getvariable(name):\n    \"\"\"Get the value of a local variable somewhere in the call stack.\"\"\"\n    import inspect\n    fr = inspect.currentframe()\n    try:\n        while fr:\n            fr = fr.f_back\n            vars = fr.f_locals\n            if name in vars:\n                return vars[name]\n    except:\n        pass\n    return None", "code_tokens": ["def", "getvariable", "(", "name", ")", ":", "import", "inspect", "fr", "=", "inspect", ".", "currentframe", "(", ")", "try", ":", "while", "fr", ":", "fr", "=", "fr", ".", "f_back", "vars", "=", "fr", ".", "f_locals", "if", "name", "in", "vars", ":", "return", "vars", "[", "name", "]", "except", ":", "pass", "return", "None"], "idx": 1793}
{"url": "cosqa-train-14068", "docstring_tokens": ["split", "string", "into", "list", "of", "strings", "by", "specified", "number", "."], "code": "def _split_str(s, n):\n    \"\"\"\n    split string into list of strings by specified number.\n    \"\"\"\n    length = len(s)\n    return [s[i:i + n] for i in range(0, length, n)]", "code_tokens": ["def", "_split_str", "(", "s", ",", "n", ")", ":", "length", "=", "len", "(", "s", ")", "return", "[", "s", "[", "i", ":", "i", "+", "n", "]", "for", "i", "in", "range", "(", "0", ",", "length", ",", "n", ")", "]"], "idx": 424}
{"url": "cosqa-train-13524", "docstring_tokens": ["Banana", "banana"], "code": "def set_verbosity(verbosity):\n        \"\"\"Banana banana\n        \"\"\"\n        Logger._verbosity = min(max(0, WARNING - verbosity), 2)\n        debug(\"Verbosity set to %d\" % (WARNING - Logger._verbosity), 'logging')", "code_tokens": ["def", "set_verbosity", "(", "verbosity", ")", ":", "Logger", ".", "_verbosity", "=", "min", "(", "max", "(", "0", ",", "WARNING", "-", "verbosity", ")", ",", "2", ")", "debug", "(", "\"Verbosity", "set", "to", "%d\"", "%", "(", "WARNING", "-", "Logger", ".", "_verbosity", ")", ",", "'logging'", ")"], "idx": 5020}
{"url": "cosqa-train-10334", "docstring_tokens": ["Set", "the", "pixel", "at", "(", "x", "y", ")", "to", "the", "integers", "in", "sequence", "color", "."], "code": "def setPixel(self, x, y, color):\n        \"\"\"Set the pixel at (x,y) to the integers in sequence 'color'.\"\"\"\n        return _fitz.Pixmap_setPixel(self, x, y, color)", "code_tokens": ["def", "setPixel", "(", "self", ",", "x", ",", "y", ",", "color", ")", ":", "return", "_fitz", ".", "Pixmap_setPixel", "(", "self", ",", "x", ",", "y", ",", "color", ")"], "idx": 1518}
{"url": "cosqa-train-6757", "docstring_tokens": ["Official", "way", "to", "get", "the", "extension", "of", "compiled", "files", "(", ".", "pyc", "or", ".", "pyo", ")"], "code": "def _get_compiled_ext():\n    \"\"\"Official way to get the extension of compiled files (.pyc or .pyo)\"\"\"\n    for ext, mode, typ in imp.get_suffixes():\n        if typ == imp.PY_COMPILED:\n            return ext", "code_tokens": ["def", "_get_compiled_ext", "(", ")", ":", "for", "ext", ",", "mode", ",", "typ", "in", "imp", ".", "get_suffixes", "(", ")", ":", "if", "typ", "==", "imp", ".", "PY_COMPILED", ":", "return", "ext"], "idx": 523}
{"url": "cosqa-train-12848", "docstring_tokens": ["Draw", "a", "horizontal", "line", "up", "to", "a", "given", "length", "."], "code": "def hline(self, x, y, width, color):\n        \"\"\"Draw a horizontal line up to a given length.\"\"\"\n        self.rect(x, y, width, 1, color, fill=True)", "code_tokens": ["def", "hline", "(", "self", ",", "x", ",", "y", ",", "width", ",", "color", ")", ":", "self", ".", "rect", "(", "x", ",", "y", ",", "width", ",", "1", ",", "color", ",", "fill", "=", "True", ")"], "idx": 225}
{"url": "cosqa-train-19534", "docstring_tokens": ["Retrun", "True", "if", "x", "is", "a", "valid", "YYYYMMDD", "date", ";", "otherwise", "return", "False", "."], "code": "def valid_date(x: str) -> bool:\n    \"\"\"\n    Retrun ``True`` if ``x`` is a valid YYYYMMDD date;\n    otherwise return ``False``.\n    \"\"\"\n    try:\n        if x != dt.datetime.strptime(x, DATE_FORMAT).strftime(DATE_FORMAT):\n            raise ValueError\n        return True\n    except ValueError:\n        return False", "code_tokens": ["def", "valid_date", "(", "x", ":", "str", ")", "->", "bool", ":", "try", ":", "if", "x", "!=", "dt", ".", "datetime", ".", "strptime", "(", "x", ",", "DATE_FORMAT", ")", ".", "strftime", "(", "DATE_FORMAT", ")", ":", "raise", "ValueError", "return", "True", "except", "ValueError", ":", "return", "False"], "idx": 5581}
{"url": "cosqa-train-421", "docstring_tokens": ["Detokenize", "a", "string", "by", "removing", "spaces", "before", "punctuation", "."], "code": "def detokenize(s):\n    \"\"\" Detokenize a string by removing spaces before punctuation.\"\"\"\n    print(s)\n    s = re.sub(\"\\s+([;:,\\.\\?!])\", \"\\\\1\", s)\n    s = re.sub(\"\\s+(n't)\", \"\\\\1\", s)\n    return s", "code_tokens": ["def", "detokenize", "(", "s", ")", ":", "print", "(", "s", ")", "s", "=", "re", ".", "sub", "(", "\"\\s+([;:,\\.\\?!])\"", ",", "\"\\\\1\"", ",", "s", ")", "s", "=", "re", ".", "sub", "(", "\"\\s+(n't)\"", ",", "\"\\\\1\"", ",", "s", ")", "return", "s"], "idx": 398}
{"url": "cosqa-train-8663", "docstring_tokens": ["Join", "the", "given", "iterable", "with"], "code": "def commajoin_as_strings(iterable):\n    \"\"\" Join the given iterable with ',' \"\"\"\n    return _(u',').join((six.text_type(i) for i in iterable))", "code_tokens": ["def", "commajoin_as_strings", "(", "iterable", ")", ":", "return", "_", "(", "u','", ")", ".", "join", "(", "(", "six", ".", "text_type", "(", "i", ")", "for", "i", "in", "iterable", ")", ")"], "idx": 160}
{"url": "cosqa-train-6516", "docstring_tokens": ["Install", "Postgres", "on", "remote"], "code": "def install_postgres(user=None, dbname=None, password=None):\n    \"\"\"Install Postgres on remote\"\"\"\n    execute(pydiploy.django.install_postgres_server,\n            user=user, dbname=dbname, password=password)", "code_tokens": ["def", "install_postgres", "(", "user", "=", "None", ",", "dbname", "=", "None", ",", "password", "=", "None", ")", ":", "execute", "(", "pydiploy", ".", "django", ".", "install_postgres_server", ",", "user", "=", "user", ",", "dbname", "=", "dbname", ",", "password", "=", "password", ")"], "idx": 3451}
{"url": "cosqa-train-11518", "docstring_tokens": ["Filter", "out", "any", "values", "in", "target", "not", "in", "image", ":", "param", "image", ":", "image", "containing", "values", "to", "appear", "in", "filtered", "image", ":", "param", "target", ":", "the", "image", "to", "filter", ":", "rtype", ":", "2d", ":", "class", ":", "numpy", ".", "ndarray", "containing", "only", "value", "in", "image", "and", "with", "the", "same", "dimensions", "as", "target"], "code": "def filter_greys_using_image(image, target):\n    \"\"\"Filter out any values in target not in image\n\n    :param image: image containing values to appear in filtered image\n    :param target: the image to filter\n    :rtype: 2d  :class:`numpy.ndarray` containing only value in image\n        and with the same dimensions as target\n\n    \"\"\"\n    maskbase = numpy.array(range(256), dtype=numpy.uint8)\n    mask = numpy.where(numpy.in1d(maskbase, numpy.unique(image)), maskbase, 0)\n    return mask[target]", "code_tokens": ["def", "filter_greys_using_image", "(", "image", ",", "target", ")", ":", "maskbase", "=", "numpy", ".", "array", "(", "range", "(", "256", ")", ",", "dtype", "=", "numpy", ".", "uint8", ")", "mask", "=", "numpy", ".", "where", "(", "numpy", ".", "in1d", "(", "maskbase", ",", "numpy", ".", "unique", "(", "image", ")", ")", ",", "maskbase", ",", "0", ")", "return", "mask", "[", "target", "]"], "idx": 3528}
{"url": "cosqa-train-7105", "docstring_tokens": ["Return", "the", "length", "of", "the", "longest", "consecutive", "run", "of", "identical", "values", "."], "code": "def longest_run_1d(arr):\n    \"\"\"Return the length of the longest consecutive run of identical values.\n\n    Parameters\n    ----------\n    arr : bool array\n      Input array\n\n    Returns\n    -------\n    int\n      Length of longest run.\n    \"\"\"\n    v, rl = rle_1d(arr)[:2]\n    return np.where(v, rl, 0).max()", "code_tokens": ["def", "longest_run_1d", "(", "arr", ")", ":", "v", ",", "rl", "=", "rle_1d", "(", "arr", ")", "[", ":", "2", "]", "return", "np", ".", "where", "(", "v", ",", "rl", ",", "0", ")", ".", "max", "(", ")"], "idx": 1368}
{"url": "cosqa-train-18157", "docstring_tokens": ["Load", "YAML", "from", "file", "."], "code": "def load_yaml(yaml_file: str) -> Any:\n    \"\"\"\n    Load YAML from file.\n\n    :param yaml_file: path to YAML file\n    :return: content of the YAML as dict/list\n    \"\"\"\n    with open(yaml_file, 'r') as file:\n        return ruamel.yaml.load(file, ruamel.yaml.RoundTripLoader)", "code_tokens": ["def", "load_yaml", "(", "yaml_file", ":", "str", ")", "->", "Any", ":", "with", "open", "(", "yaml_file", ",", "'r'", ")", "as", "file", ":", "return", "ruamel", ".", "yaml", ".", "load", "(", "file", ",", "ruamel", ".", "yaml", ".", "RoundTripLoader", ")"], "idx": 6002}
{"url": "cosqa-train-6748", "docstring_tokens": ["Return", "the", "names", "of", "all", "callable", "attributes", "of", "an", "object"], "code": "def get_methods(*objs):\n    \"\"\" Return the names of all callable attributes of an object\"\"\"\n    return set(\n        attr\n        for obj in objs\n        for attr in dir(obj)\n        if not attr.startswith('_') and callable(getattr(obj, attr))\n    )", "code_tokens": ["def", "get_methods", "(", "*", "objs", ")", ":", "return", "set", "(", "attr", "for", "obj", "in", "objs", "for", "attr", "in", "dir", "(", "obj", ")", "if", "not", "attr", ".", "startswith", "(", "'_'", ")", "and", "callable", "(", "getattr", "(", "obj", ",", "attr", ")", ")", ")"], "idx": 385}
{"url": "cosqa-train-7245", "docstring_tokens": ["Convert", "numbers", "to", "floats", "whether", "the", "decimal", "point", "is", ".", "or"], "code": "def comma_converter(float_string):\n    \"\"\"Convert numbers to floats whether the decimal point is '.' or ','\"\"\"\n    trans_table = maketrans(b',', b'.')\n    return float(float_string.translate(trans_table))", "code_tokens": ["def", "comma_converter", "(", "float_string", ")", ":", "trans_table", "=", "maketrans", "(", "b','", ",", "b'.'", ")", "return", "float", "(", "float_string", ".", "translate", "(", "trans_table", ")", ")"], "idx": 736}
{"url": "cosqa-train-18041", "docstring_tokens": ["Returns", "all", "column", "names", "and", "their", "data", "types", "as", "a", "list", "."], "code": "def dtypes(self):\n        \"\"\"Returns all column names and their data types as a list.\n\n        >>> df.dtypes\n        [('age', 'int'), ('name', 'string')]\n        \"\"\"\n        return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]", "code_tokens": ["def", "dtypes", "(", "self", ")", ":", "return", "[", "(", "str", "(", "f", ".", "name", ")", ",", "f", ".", "dataType", ".", "simpleString", "(", ")", ")", "for", "f", "in", "self", ".", "schema", ".", "fields", "]"], "idx": 5803}
{"url": "cosqa-train-19641", "docstring_tokens": ["Matrix", "multiplication", "using", "binary"], "code": "def __rmatmul__(self, other):\n        \"\"\"\n        Matrix multiplication using binary `@` operator in Python>=3.5.\n        \"\"\"\n        return self.T.dot(np.transpose(other)).T", "code_tokens": ["def", "__rmatmul__", "(", "self", ",", "other", ")", ":", "return", "self", ".", "T", ".", "dot", "(", "np", ".", "transpose", "(", "other", ")", ")", ".", "T"], "idx": 5730}
{"url": "cosqa-train-17955", "docstring_tokens": ["Yields", "all", "permutations", "with", "replacement", ":", "list", "(", "product", "(", "cat", "repeat", "=", "2", "))", "=", ">", "[", "(", "c", "c", ")", "(", "c", "a", ")", "(", "c", "t", ")", "(", "a", "c", ")", "(", "a", "a", ")", "(", "a", "t", ")", "(", "t", "c", ")", "(", "t", "a", ")", "(", "t", "t", ")", "]"], "code": "def product(*args, **kwargs):\n    \"\"\" Yields all permutations with replacement:\n        list(product(\"cat\", repeat=2)) => \n        [(\"c\", \"c\"), \n         (\"c\", \"a\"), \n         (\"c\", \"t\"), \n         (\"a\", \"c\"), \n         (\"a\", \"a\"), \n         (\"a\", \"t\"), \n         (\"t\", \"c\"), \n         (\"t\", \"a\"), \n         (\"t\", \"t\")]\n    \"\"\"\n    p = [[]]\n    for iterable in map(tuple, args) * kwargs.get(\"repeat\", 1):\n        p = [x + [y] for x in p for y in iterable]\n    for p in p:\n        yield tuple(p)", "code_tokens": ["def", "product", "(", "*", "args", ",", "*", "*", "kwargs", ")", ":", "p", "=", "[", "[", "]", "]", "for", "iterable", "in", "map", "(", "tuple", ",", "args", ")", "*", "kwargs", ".", "get", "(", "\"repeat\"", ",", "1", ")", ":", "p", "=", "[", "x", "+", "[", "y", "]", "for", "x", "in", "p", "for", "y", "in", "iterable", "]", "for", "p", "in", "p", ":", "yield", "tuple", "(", "p", ")"], "idx": 5967}
{"url": "cosqa-train-8365", "docstring_tokens": ["Validates", "that", "value", "is", "an", "instance", "of", "basestring", "for", "Python", "2", "or", "str", "for", "Python", "3", "."], "code": "def validate_string(option, value):\n    \"\"\"Validates that 'value' is an instance of `basestring` for Python 2\n    or `str` for Python 3.\n    \"\"\"\n    if isinstance(value, string_type):\n        return value\n    raise TypeError(\"Wrong type for %s, value must be \"\n                    \"an instance of %s\" % (option, string_type.__name__))", "code_tokens": ["def", "validate_string", "(", "option", ",", "value", ")", ":", "if", "isinstance", "(", "value", ",", "string_type", ")", ":", "return", "value", "raise", "TypeError", "(", "\"Wrong", "type", "for", "%s,", "value", "must", "be", "\"", "\"an", "instance", "of", "%s\"", "%", "(", "option", ",", "string_type", ".", "__name__", ")", ")"], "idx": 2584}
{"url": "cosqa-train-16072", "docstring_tokens": ["Message", "printer", "."], "code": "def _show(self, message, indent=0, enable_verbose=True):  # pragma: no cover\n        \"\"\"Message printer.\n        \"\"\"\n        if enable_verbose:\n            print(\"    \" * indent + message)", "code_tokens": ["def", "_show", "(", "self", ",", "message", ",", "indent", "=", "0", ",", "enable_verbose", "=", "True", ")", ":", "#", "pragma:", "no", "cover", "if", "enable_verbose", ":", "print", "(", "\"", "", "", "", "\"", "*", "indent", "+", "message", ")"], "idx": 1030}
{"url": "cosqa-train-17475", "docstring_tokens": ["Print", "out", "a", "neat", "targets", "dependency", "tree", "based", "on", "requested", "targets", "."], "code": "def cmd_dot(conf: Config):\n    \"\"\"Print out a neat targets dependency tree based on requested targets.\n\n    Use graphviz to render the dot file, e.g.:\n\n    > ybt dot :foo :bar | dot -Tpng -o graph.png\n    \"\"\"\n    build_context = BuildContext(conf)\n    populate_targets_graph(build_context, conf)\n    if conf.output_dot_file is None:\n        write_dot(build_context, conf, sys.stdout)\n    else:\n        with open(conf.output_dot_file, 'w') as out_file:\n            write_dot(build_context, conf, out_file)", "code_tokens": ["def", "cmd_dot", "(", "conf", ":", "Config", ")", ":", "build_context", "=", "BuildContext", "(", "conf", ")", "populate_targets_graph", "(", "build_context", ",", "conf", ")", "if", "conf", ".", "output_dot_file", "is", "None", ":", "write_dot", "(", "build_context", ",", "conf", ",", "sys", ".", "stdout", ")", "else", ":", "with", "open", "(", "conf", ".", "output_dot_file", ",", "'w'", ")", "as", "out_file", ":", "write_dot", "(", "build_context", ",", "conf", ",", "out_file", ")"], "idx": 5811}
{"url": "cosqa-train-4947", "docstring_tokens": ["Composes", "the", "passed", "filters", "into", "an", "and", "-", "joined", "filter", "."], "code": "def BROADCAST_FILTER_NOT(func):\n        \"\"\"\n        Composes the passed filters into an and-joined filter.\n        \"\"\"\n        return lambda u, command, *args, **kwargs: not func(u, command, *args, **kwargs)", "code_tokens": ["def", "BROADCAST_FILTER_NOT", "(", "func", ")", ":", "return", "lambda", "u", ",", "command", ",", "*", "args", ",", "*", "*", "kwargs", ":", "not", "func", "(", "u", ",", "command", ",", "*", "args", ",", "*", "*", "kwargs", ")"], "idx": 2927}
{"url": "cosqa-train-8712", "docstring_tokens": ["Wrapper", "for", "pymongo", ".", "Collection", ".", "ensure_index"], "code": "def ensure_index(self, key, unique=False):\n        \"\"\"Wrapper for pymongo.Collection.ensure_index\n        \"\"\"\n        return self.collection.ensure_index(key, unique=unique)", "code_tokens": ["def", "ensure_index", "(", "self", ",", "key", ",", "unique", "=", "False", ")", ":", "return", "self", ".", "collection", ".", "ensure_index", "(", "key", ",", "unique", "=", "unique", ")"], "idx": 3314}
{"url": "cosqa-train-16025", "docstring_tokens": ["Recieving", "the", "JSON", "file", "from", "uulm"], "code": "def get(url):\n    \"\"\"Recieving the JSON file from uulm\"\"\"\n    response = urllib.request.urlopen(url)\n    data = response.read()\n    data = data.decode(\"utf-8\")\n    data = json.loads(data)\n    return data", "code_tokens": ["def", "get", "(", "url", ")", ":", "response", "=", "urllib", ".", "request", ".", "urlopen", "(", "url", ")", "data", "=", "response", ".", "read", "(", ")", "data", "=", "data", ".", "decode", "(", "\"utf-8\"", ")", "data", "=", "json", ".", "loads", "(", "data", ")", "return", "data"], "idx": 1410}
{"url": "cosqa-train-14666", "docstring_tokens": ["Check", "whether", "a", "certain", "column", "exists"], "code": "def column_exists(cr, table, column):\n    \"\"\" Check whether a certain column exists \"\"\"\n    cr.execute(\n        'SELECT count(attname) FROM pg_attribute '\n        'WHERE attrelid = '\n        '( SELECT oid FROM pg_class WHERE relname = %s ) '\n        'AND attname = %s',\n        (table, column))\n    return cr.fetchone()[0] == 1", "code_tokens": ["def", "column_exists", "(", "cr", ",", "table", ",", "column", ")", ":", "cr", ".", "execute", "(", "'SELECT", "count(attname)", "FROM", "pg_attribute", "'", "'WHERE", "attrelid", "=", "'", "'(", "SELECT", "oid", "FROM", "pg_class", "WHERE", "relname", "=", "%s", ")", "'", "'AND", "attname", "=", "%s'", ",", "(", "table", ",", "column", ")", ")", "return", "cr", ".", "fetchone", "(", ")", "[", "0", "]", "==", "1"], "idx": 2194}
{"url": "cosqa-train-14312", "docstring_tokens": ["Clears", "the", "default", "matplotlib", "ticks", "."], "code": "def clear_matplotlib_ticks(self, axis=\"both\"):\n        \"\"\"Clears the default matplotlib ticks.\"\"\"\n        ax = self.get_axes()\n        plotting.clear_matplotlib_ticks(ax=ax, axis=axis)", "code_tokens": ["def", "clear_matplotlib_ticks", "(", "self", ",", "axis", "=", "\"both\"", ")", ":", "ax", "=", "self", ".", "get_axes", "(", ")", "plotting", ".", "clear_matplotlib_ticks", "(", "ax", "=", "ax", ",", "axis", "=", "axis", ")"], "idx": 788}
{"url": "cosqa-train-8391", "docstring_tokens": ["Build", "argument", "parsers", "."], "code": "def build_parser():\n    \"\"\"Build argument parsers.\"\"\"\n\n    parser = argparse.ArgumentParser(\"Release packages to pypi\")\n    parser.add_argument('--check', '-c', action=\"store_true\", help=\"Do a dry run without uploading\")\n    parser.add_argument('component', help=\"The component to release as component-version\")\n    return parser", "code_tokens": ["def", "build_parser", "(", ")", ":", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\"Release", "packages", "to", "pypi\"", ")", "parser", ".", "add_argument", "(", "'--check'", ",", "'-c'", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Do", "a", "dry", "run", "without", "uploading\"", ")", "parser", ".", "add_argument", "(", "'component'", ",", "help", "=", "\"The", "component", "to", "release", "as", "component-version\"", ")", "return", "parser"], "idx": 1508}
{"url": "cosqa-train-9068", "docstring_tokens": ["Given", "HTML", "markup", "return", "a", "list", "of", "hrefs", "for", "each", "anchor", "tag", "."], "code": "def get_anchor_href(markup):\n    \"\"\"\n    Given HTML markup, return a list of hrefs for each anchor tag.\n    \"\"\"\n    soup = BeautifulSoup(markup, 'lxml')\n    return ['%s' % link.get('href') for link in soup.find_all('a')]", "code_tokens": ["def", "get_anchor_href", "(", "markup", ")", ":", "soup", "=", "BeautifulSoup", "(", "markup", ",", "'lxml'", ")", "return", "[", "'%s'", "%", "link", ".", "get", "(", "'href'", ")", "for", "link", "in", "soup", ".", "find_all", "(", "'a'", ")", "]"], "idx": 4158}
{"url": "cosqa-train-15011", "docstring_tokens": ["Represent", "string", "/", "bytes", "s", "as", "base64", "omitting", "newlines"], "code": "def toBase64(s):\n    \"\"\"Represent string / bytes s as base64, omitting newlines\"\"\"\n    if isinstance(s, str):\n        s = s.encode(\"utf-8\")\n    return binascii.b2a_base64(s)[:-1]", "code_tokens": ["def", "toBase64", "(", "s", ")", ":", "if", "isinstance", "(", "s", ",", "str", ")", ":", "s", "=", "s", ".", "encode", "(", "\"utf-8\"", ")", "return", "binascii", ".", "b2a_base64", "(", "s", ")", "[", ":", "-", "1", "]"], "idx": 554}
{"url": "cosqa-train-12325", "docstring_tokens": ["Apply", "2to3", "tool", "(", "Python2", "to", "Python3", "conversion", "tool", ")", "to", "Python", "sources", "."], "code": "def command_py2to3(args):\n    \"\"\"\n    Apply '2to3' tool (Python2 to Python3 conversion tool) to Python sources.\n    \"\"\"\n    from lib2to3.main import main\n    sys.exit(main(\"lib2to3.fixes\", args=args.sources))", "code_tokens": ["def", "command_py2to3", "(", "args", ")", ":", "from", "lib2to3", ".", "main", "import", "main", "sys", ".", "exit", "(", "main", "(", "\"lib2to3.fixes\"", ",", "args", "=", "args", ".", "sources", ")", ")"], "idx": 1469}
{"url": "cosqa-dev-272", "docstring_tokens": ["Shot", "noise", "corruption", "to", "images", "."], "code": "def shot_noise(x, severity=1):\n  \"\"\"Shot noise corruption to images.\n\n  Args:\n    x: numpy array, uncorrupted image, assumed to have uint8 pixel in [0,255].\n    severity: integer, severity of corruption.\n\n  Returns:\n    numpy array, image with uint8 pixels in [0,255]. Added shot noise.\n  \"\"\"\n  c = [60, 25, 12, 5, 3][severity - 1]\n  x = np.array(x) / 255.\n  x_clip = np.clip(np.random.poisson(x * c) / float(c), 0, 1) * 255\n  return around_and_astype(x_clip)", "code_tokens": ["def", "shot_noise", "(", "x", ",", "severity", "=", "1", ")", ":", "c", "=", "[", "60", ",", "25", ",", "12", ",", "5", ",", "3", "]", "[", "severity", "-", "1", "]", "x", "=", "np", ".", "array", "(", "x", ")", "/", "255.", "x_clip", "=", "np", ".", "clip", "(", "np", ".", "random", ".", "poisson", "(", "x", "*", "c", ")", "/", "float", "(", "c", ")", ",", "0", ",", "1", ")", "*", "255", "return", "around_and_astype", "(", "x_clip", ")"], "idx": 1396}
{"url": "cosqa-train-10428", "docstring_tokens": ["Returns", "a", "number", "of", "query", "results", ".", "This", "is", "faster", "than", ".", "count", "()", "on", "the", "query"], "code": "def get_count(self, query):\n        \"\"\"\n        Returns a number of query results. This is faster than .count() on the query\n        \"\"\"\n        count_q = query.statement.with_only_columns(\n            [func.count()]).order_by(None)\n        count = query.session.execute(count_q).scalar()\n        return count", "code_tokens": ["def", "get_count", "(", "self", ",", "query", ")", ":", "count_q", "=", "query", ".", "statement", ".", "with_only_columns", "(", "[", "func", ".", "count", "(", ")", "]", ")", ".", "order_by", "(", "None", ")", "count", "=", "query", ".", "session", ".", "execute", "(", "count_q", ")", ".", "scalar", "(", ")", "return", "count"], "idx": 2396}
{"url": "cosqa-train-10679", "docstring_tokens": ["Returns", "int", "()", "of", "val", "if", "val", "is", "not", "convertable", "to", "int", "use", "default", "instead"], "code": "def safe_int(val, default=None):\n    \"\"\"\n    Returns int() of val if val is not convertable to int use default\n    instead\n\n    :param val:\n    :param default:\n    \"\"\"\n\n    try:\n        val = int(val)\n    except (ValueError, TypeError):\n        val = default\n\n    return val", "code_tokens": ["def", "safe_int", "(", "val", ",", "default", "=", "None", ")", ":", "try", ":", "val", "=", "int", "(", "val", ")", "except", "(", "ValueError", ",", "TypeError", ")", ":", "val", "=", "default", "return", "val"], "idx": 2494}
{"url": "cosqa-train-15392", "docstring_tokens": ["prints", "the", "top", "n", "lines", "of", "a", "file"], "code": "def head(filename, n=10):\n    \"\"\" prints the top `n` lines of a file \"\"\"\n    with freader(filename) as fr:\n        for _ in range(n):\n            print(fr.readline().strip())", "code_tokens": ["def", "head", "(", "filename", ",", "n", "=", "10", ")", ":", "with", "freader", "(", "filename", ")", "as", "fr", ":", "for", "_", "in", "range", "(", "n", ")", ":", "print", "(", "fr", ".", "readline", "(", ")", ".", "strip", "(", ")", ")"], "idx": 1073}
{"url": "cosqa-train-11258", "docstring_tokens": ["Erases", "n", "lines", "from", "the", "screen", "and", "moves", "the", "cursor", "up", "to", "follow"], "code": "def erase_lines(n=1):\n    \"\"\" Erases n lines from the screen and moves the cursor up to follow\n    \"\"\"\n    for _ in range(n):\n        print(codes.cursor[\"up\"], end=\"\")\n        print(codes.cursor[\"eol\"], end=\"\")", "code_tokens": ["def", "erase_lines", "(", "n", "=", "1", ")", ":", "for", "_", "in", "range", "(", "n", ")", ":", "print", "(", "codes", ".", "cursor", "[", "\"up\"", "]", ",", "end", "=", "\"\"", ")", "print", "(", "codes", ".", "cursor", "[", "\"eol\"", "]", ",", "end", "=", "\"\"", ")"], "idx": 783}
{"url": "cosqa-train-10604", "docstring_tokens": ["1x1", "convolution"], "code": "def conv1x1(in_planes, out_planes, stride=1):\n    \"\"\"1x1 convolution\"\"\"\n    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)", "code_tokens": ["def", "conv1x1", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ")", ":", "return", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")"], "idx": 1075}
{"url": "cosqa-train-12643", "docstring_tokens": ["Replace", "masked", "-", "out", "elements", "in", "an", "array", "using", "an", "iterative", "image", "inpainting", "algorithm", "."], "code": "def inpaint(self):\n        \"\"\" Replace masked-out elements in an array using an iterative image inpainting algorithm. \"\"\"\n\n        import inpaint\n        filled = inpaint.replace_nans(np.ma.filled(self.raster_data, np.NAN).astype(np.float32), 3, 0.01, 2)\n        self.raster_data = np.ma.masked_invalid(filled)", "code_tokens": ["def", "inpaint", "(", "self", ")", ":", "import", "inpaint", "filled", "=", "inpaint", ".", "replace_nans", "(", "np", ".", "ma", ".", "filled", "(", "self", ".", "raster_data", ",", "np", ".", "NAN", ")", ".", "astype", "(", "np", ".", "float32", ")", ",", "3", ",", "0.01", ",", "2", ")", "self", ".", "raster_data", "=", "np", ".", "ma", ".", "masked_invalid", "(", "filled", ")"], "idx": 1803}
{"url": "cosqa-train-18628", "docstring_tokens": ["Return", "flattened", "dictionary", "from", "MultiDict", "."], "code": "def flatten_multidict(multidict):\n    \"\"\"Return flattened dictionary from ``MultiDict``.\"\"\"\n    return dict([(key, value if len(value) > 1 else value[0])\n                 for (key, value) in multidict.iterlists()])", "code_tokens": ["def", "flatten_multidict", "(", "multidict", ")", ":", "return", "dict", "(", "[", "(", "key", ",", "value", "if", "len", "(", "value", ")", ">", "1", "else", "value", "[", "0", "]", ")", "for", "(", "key", ",", "value", ")", "in", "multidict", ".", "iterlists", "(", ")", "]", ")"], "idx": 5724}
{"url": "cosqa-train-14216", "docstring_tokens": ["Function", "that", "verify", "if", "the", "header", "parameter", "is", "a", "essential", "header"], "code": "def required_header(header):\n    \"\"\"Function that verify if the header parameter is a essential header\n\n    :param header:  A string represented a header\n    :returns:       A boolean value that represent if the header is required\n    \"\"\"\n    if header in IGNORE_HEADERS:\n        return False\n\n    if header.startswith('HTTP_') or header == 'CONTENT_TYPE':\n        return True\n\n    return False", "code_tokens": ["def", "required_header", "(", "header", ")", ":", "if", "header", "in", "IGNORE_HEADERS", ":", "return", "False", "if", "header", ".", "startswith", "(", "'HTTP_'", ")", "or", "header", "==", "'CONTENT_TYPE'", ":", "return", "True", "return", "False"], "idx": 233}
{"url": "cosqa-train-17647", "docstring_tokens": ["Parses", "hostname", "from", "URL", ".", ":", "param", "url", ":", "URL", ":", "return", ":", "hostname"], "code": "def url_host(url: str) -> str:\n    \"\"\"\n    Parses hostname from URL.\n    :param url: URL\n    :return: hostname\n    \"\"\"\n    from urllib.parse import urlparse\n    res = urlparse(url)\n    return res.netloc.split(':')[0] if res.netloc else ''", "code_tokens": ["def", "url_host", "(", "url", ":", "str", ")", "->", "str", ":", "from", "urllib", ".", "parse", "import", "urlparse", "res", "=", "urlparse", "(", "url", ")", "return", "res", ".", "netloc", ".", "split", "(", "':'", ")", "[", "0", "]", "if", "res", ".", "netloc", "else", "''"], "idx": 5694}
{"url": "cosqa-train-7100", "docstring_tokens": ["Shot", "noise", "corruption", "to", "images", "."], "code": "def shot_noise(x, severity=1):\n  \"\"\"Shot noise corruption to images.\n\n  Args:\n    x: numpy array, uncorrupted image, assumed to have uint8 pixel in [0,255].\n    severity: integer, severity of corruption.\n\n  Returns:\n    numpy array, image with uint8 pixels in [0,255]. Added shot noise.\n  \"\"\"\n  c = [60, 25, 12, 5, 3][severity - 1]\n  x = np.array(x) / 255.\n  x_clip = np.clip(np.random.poisson(x * c) / float(c), 0, 1) * 255\n  return around_and_astype(x_clip)", "code_tokens": ["def", "shot_noise", "(", "x", ",", "severity", "=", "1", ")", ":", "c", "=", "[", "60", ",", "25", ",", "12", ",", "5", ",", "3", "]", "[", "severity", "-", "1", "]", "x", "=", "np", ".", "array", "(", "x", ")", "/", "255.", "x_clip", "=", "np", ".", "clip", "(", "np", ".", "random", ".", "poisson", "(", "x", "*", "c", ")", "/", "float", "(", "c", ")", ",", "0", ",", "1", ")", "*", "255", "return", "around_and_astype", "(", "x_clip", ")"], "idx": 1396}
{"url": "cosqa-train-18082", "docstring_tokens": ["Convert", "a", "CSV", "object", "to", "a", "numpy", "array", "."], "code": "def csv_to_numpy(string_like, dtype=None):  # type: (str) -> np.array\n    \"\"\"Convert a CSV object to a numpy array.\n\n    Args:\n        string_like (str): CSV string.\n        dtype (dtype, optional):  Data type of the resulting array. If None, the dtypes will be determined by the\n                                        contents of each column, individually. This argument can only be used to\n                                        'upcast' the array.  For downcasting, use the .astype(t) method.\n    Returns:\n        (np.array): numpy array\n    \"\"\"\n    stream = StringIO(string_like)\n    return np.genfromtxt(stream, dtype=dtype, delimiter=',')", "code_tokens": ["def", "csv_to_numpy", "(", "string_like", ",", "dtype", "=", "None", ")", ":", "#", "type:", "(str)", "->", "np.array", "stream", "=", "StringIO", "(", "string_like", ")", "return", "np", ".", "genfromtxt", "(", "stream", ",", "dtype", "=", "dtype", ",", "delimiter", "=", "','", ")"], "idx": 5746}
{"url": "cosqa-train-19043", "docstring_tokens": ["Purely", "a", "debugging", "aid", ":", "Ascii", "-", "art", "picture", "of", "a", "tree", "descended", "from", "node"], "code": "def debugTreePrint(node,pfx=\"->\"):\n  \"\"\"Purely a debugging aid: Ascii-art picture of a tree descended from node\"\"\"\n  print pfx,node.item\n  for c in node.children:\n    debugTreePrint(c,\"  \"+pfx)", "code_tokens": ["def", "debugTreePrint", "(", "node", ",", "pfx", "=", "\"->\"", ")", ":", "print", "pfx", ",", "node", ".", "item", "for", "c", "in", "node", ".", "children", ":", "debugTreePrint", "(", "c", ",", "\"", "", "\"", "+", "pfx", ")"], "idx": 5626}
{"url": "cosqa-train-12281", "docstring_tokens": ["Show", "the", "received", "object", "as", "precise", "as", "possible", "."], "code": "def _repr(obj):\n    \"\"\"Show the received object as precise as possible.\"\"\"\n    vals = \", \".join(\"{}={!r}\".format(\n        name, getattr(obj, name)) for name in obj._attribs)\n    if vals:\n        t = \"{}(name={}, {})\".format(obj.__class__.__name__, obj.name, vals)\n    else:\n        t = \"{}(name={})\".format(obj.__class__.__name__, obj.name)\n    return t", "code_tokens": ["def", "_repr", "(", "obj", ")", ":", "vals", "=", "\",", "\"", ".", "join", "(", "\"{}={!r}\"", ".", "format", "(", "name", ",", "getattr", "(", "obj", ",", "name", ")", ")", "for", "name", "in", "obj", ".", "_attribs", ")", "if", "vals", ":", "t", "=", "\"{}(name={},", "{})\"", ".", "format", "(", "obj", ".", "__class__", ".", "__name__", ",", "obj", ".", "name", ",", "vals", ")", "else", ":", "t", "=", "\"{}(name={})\"", ".", "format", "(", "obj", ".", "__class__", ".", "__name__", ",", "obj", ".", "name", ")", "return", "t"], "idx": 1533}
{"url": "cosqa-train-14786", "docstring_tokens": ["Put", "curly", "brackets", "round", "an", "indented", "text"], "code": "def dumped(text, level, indent=2):\n    \"\"\"Put curly brackets round an indented text\"\"\"\n    return indented(\"{\\n%s\\n}\" % indented(text, level + 1, indent) or \"None\", level, indent) + \"\\n\"", "code_tokens": ["def", "dumped", "(", "text", ",", "level", ",", "indent", "=", "2", ")", ":", "return", "indented", "(", "\"{\\n%s\\n}\"", "%", "indented", "(", "text", ",", "level", "+", "1", ",", "indent", ")", "or", "\"None\"", ",", "level", ",", "indent", ")", "+", "\"\\n\""], "idx": 29}
{"url": "cosqa-train-7938", "docstring_tokens": ["Simple", "measure", "of", "similarity", ":", "Number", "of", "letters", "in", "common", "/", "max", "length"], "code": "def basic_word_sim(word1, word2):\n    \"\"\"\n    Simple measure of similarity: Number of letters in common / max length\n    \"\"\"\n    return sum([1 for c in word1 if c in word2]) / max(len(word1), len(word2))", "code_tokens": ["def", "basic_word_sim", "(", "word1", ",", "word2", ")", ":", "return", "sum", "(", "[", "1", "for", "c", "in", "word1", "if", "c", "in", "word2", "]", ")", "/", "max", "(", "len", "(", "word1", ")", ",", "len", "(", "word2", ")", ")"], "idx": 1901}
{"url": "cosqa-train-11713", "docstring_tokens": ["iterator", "for", "JSON", "-", "per", "-", "line", "in", "a", "file", "pattern"], "code": "def json_iter (path):\n    \"\"\"\n    iterator for JSON-per-line in a file pattern\n    \"\"\"\n    with open(path, 'r') as f:\n        for line in f.readlines():\n            yield json.loads(line)", "code_tokens": ["def", "json_iter", "(", "path", ")", ":", "with", "open", "(", "path", ",", "'r'", ")", "as", "f", ":", "for", "line", "in", "f", ".", "readlines", "(", ")", ":", "yield", "json", ".", "loads", "(", "line", ")"], "idx": 983}
{"url": "cosqa-train-3566", "docstring_tokens": ["Show", "the", "x", "-", "axis", "tick", "labels", "for", "a", "subplot", "."], "code": "def show_xticklabels(self, row, column):\n        \"\"\"Show the x-axis tick labels for a subplot.\n\n        :param row,column: specify the subplot.\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.show_xticklabels()", "code_tokens": ["def", "show_xticklabels", "(", "self", ",", "row", ",", "column", ")", ":", "subplot", "=", "self", ".", "get_subplot_at", "(", "row", ",", "column", ")", "subplot", ".", "show_xticklabels", "(", ")"], "idx": 944}
{"url": "cosqa-train-9696", "docstring_tokens": ["read", "an", "image", "from", "file", "-", "PIL", "doesnt", "close", "nicely"], "code": "def load_image(fname):\n    \"\"\" read an image from file - PIL doesnt close nicely \"\"\"\n    with open(fname, \"rb\") as f:\n        i = Image.open(fname)\n        #i.load()\n        return i", "code_tokens": ["def", "load_image", "(", "fname", ")", ":", "with", "open", "(", "fname", ",", "\"rb\"", ")", "as", "f", ":", "i", "=", "Image", ".", "open", "(", "fname", ")", "#i.load()", "return", "i"], "idx": 2485}
{"url": "cosqa-train-6417", "docstring_tokens": ["Sets", "args", "and", "kwargs", "that", "are", "passed", "when", "creating", "a", "subparsers", "group", "in", "an", "argparse", ".", "ArgumentParser", "i", ".", "e", ".", "when", "calling", "argparser", ".", "ArgumentParser", ".", "add_subparsers"], "code": "def set_subparsers_args(self, *args, **kwargs):\n        \"\"\"\n        Sets args and kwargs that are passed when creating a subparsers group\n        in an argparse.ArgumentParser i.e. when calling\n        argparser.ArgumentParser.add_subparsers\n        \"\"\"\n        self.subparsers_args = args\n        self.subparsers_kwargs = kwargs", "code_tokens": ["def", "set_subparsers_args", "(", "self", ",", "*", "args", ",", "*", "*", "kwargs", ")", ":", "self", ".", "subparsers_args", "=", "args", "self", ".", "subparsers_kwargs", "=", "kwargs"], "idx": 2613}
{"url": "cosqa-train-12336", "docstring_tokens": ["Strip", "excess", "spaces", "from", "a", "string"], "code": "def strip_spaces(s):\n    \"\"\" Strip excess spaces from a string \"\"\"\n    return u\" \".join([c for c in s.split(u' ') if c])", "code_tokens": ["def", "strip_spaces", "(", "s", ")", ":", "return", "u\"", "\"", ".", "join", "(", "[", "c", "for", "c", "in", "s", ".", "split", "(", "u'", "'", ")", "if", "c", "]", ")"], "idx": 366}
{"url": "cosqa-train-10020", "docstring_tokens": ["Simple", "function", "to", "convert", "naive", ":", "std", ":", "datetime", ".", "datetime", "object", "containing", "local", "time", "to", "a", "naive", ":", "std", ":", "datetime", ".", "datetime", "object", "with", "UTC", "time", "."], "code": "def datetime_local_to_utc(local):\n    \"\"\"\n    Simple function to convert naive :std:`datetime.datetime` object containing\n    local time to a naive :std:`datetime.datetime` object with UTC time.\n    \"\"\"\n    timestamp = time.mktime(local.timetuple())\n    return datetime.datetime.utcfromtimestamp(timestamp)", "code_tokens": ["def", "datetime_local_to_utc", "(", "local", ")", ":", "timestamp", "=", "time", ".", "mktime", "(", "local", ".", "timetuple", "(", ")", ")", "return", "datetime", ".", "datetime", ".", "utcfromtimestamp", "(", "timestamp", ")"], "idx": 737}
{"url": "cosqa-train-17470", "docstring_tokens": ["Check", "if", "filename", "has", "changed", "since", "the", "last", "check", ".", "If", "this", "is", "the", "first", "check", "assume", "the", "file", "is", "changed", "."], "code": "def has_changed (filename):\n    \"\"\"Check if filename has changed since the last check. If this\n    is the first check, assume the file is changed.\"\"\"\n    key = os.path.abspath(filename)\n    mtime = get_mtime(key)\n    if key not in _mtime_cache:\n        _mtime_cache[key] = mtime\n        return True\n    return mtime > _mtime_cache[key]", "code_tokens": ["def", "has_changed", "(", "filename", ")", ":", "key", "=", "os", ".", "path", ".", "abspath", "(", "filename", ")", "mtime", "=", "get_mtime", "(", "key", ")", "if", "key", "not", "in", "_mtime_cache", ":", "_mtime_cache", "[", "key", "]", "=", "mtime", "return", "True", "return", "mtime", ">", "_mtime_cache", "[", "key", "]"], "idx": 5690}
{"url": "cosqa-train-18570", "docstring_tokens": ["Helper", "function", "returns", "a", "truncated", "repr", "()", "of", "an", "object", "."], "code": "def _short_repr(obj):\n  \"\"\"Helper function returns a truncated repr() of an object.\"\"\"\n  stringified = pprint.saferepr(obj)\n  if len(stringified) > 200:\n    return '%s... (%d bytes)' % (stringified[:200], len(stringified))\n  return stringified", "code_tokens": ["def", "_short_repr", "(", "obj", ")", ":", "stringified", "=", "pprint", ".", "saferepr", "(", "obj", ")", "if", "len", "(", "stringified", ")", ">", "200", ":", "return", "'%s...", "(%d", "bytes)'", "%", "(", "stringified", "[", ":", "200", "]", ",", "len", "(", "stringified", ")", ")", "return", "stringified"], "idx": 5740}
{"url": "cosqa-train-2358", "docstring_tokens": ["Perform", "actions", "before", "parent", "main", "window", "is", "closed"], "code": "def closing_plugin(self, cancelable=False):\n        \"\"\"Perform actions before parent main window is closed\"\"\"\n        self.dialog_manager.close_all()\n        self.shell.exit_interpreter()\n        return True", "code_tokens": ["def", "closing_plugin", "(", "self", ",", "cancelable", "=", "False", ")", ":", "self", ".", "dialog_manager", ".", "close_all", "(", ")", "self", ".", "shell", ".", "exit_interpreter", "(", ")", "return", "True"], "idx": 141}
{"url": "cosqa-train-11705", "docstring_tokens": ["returns", "json", "contents", "as", "string"], "code": "def open_json(file_name):\n    \"\"\"\n    returns json contents as string\n    \"\"\"\n    with open(file_name, \"r\") as json_data:\n        data = json.load(json_data)\n        return data", "code_tokens": ["def", "open_json", "(", "file_name", ")", ":", "with", "open", "(", "file_name", ",", "\"r\"", ")", "as", "json_data", ":", "data", "=", "json", ".", "load", "(", "json_data", ")", "return", "data"], "idx": 977}
{"url": "cosqa-train-11645", "docstring_tokens": ["Returns", "the", "contents", "of", "the", "sql", "file", "from", "the", "given", "filename", "."], "code": "def _get_sql(filename):\n    \"\"\"Returns the contents of the sql file from the given ``filename``.\"\"\"\n    with open(os.path.join(SQL_DIR, filename), 'r') as f:\n        return f.read()", "code_tokens": ["def", "_get_sql", "(", "filename", ")", ":", "with", "open", "(", "os", ".", "path", ".", "join", "(", "SQL_DIR", ",", "filename", ")", ",", "'r'", ")", "as", "f", ":", "return", "f", ".", "read", "(", ")"], "idx": 1052}
{"url": "cosqa-train-12052", "docstring_tokens": ["Yield", "directory", "file", "names", "."], "code": "def directory_files(path):\n    \"\"\"Yield directory file names.\"\"\"\n\n    for entry in os.scandir(path):\n        if not entry.name.startswith('.') and entry.is_file():\n            yield entry.name", "code_tokens": ["def", "directory_files", "(", "path", ")", ":", "for", "entry", "in", "os", ".", "scandir", "(", "path", ")", ":", "if", "not", "entry", ".", "name", ".", "startswith", "(", "'.'", ")", "and", "entry", ".", "is_file", "(", ")", ":", "yield", "entry", ".", "name"], "idx": 665}
{"url": "cosqa-train-1387", "docstring_tokens": ["Sort", "data", "rows", "and", "order", "columns"], "code": "def sort_data(data, cols):\n    \"\"\"Sort `data` rows and order columns\"\"\"\n    return data.sort_values(cols)[cols + ['value']].reset_index(drop=True)", "code_tokens": ["def", "sort_data", "(", "data", ",", "cols", ")", ":", "return", "data", ".", "sort_values", "(", "cols", ")", "[", "cols", "+", "[", "'value'", "]", "]", ".", "reset_index", "(", "drop", "=", "True", ")"], "idx": 1180}
{"url": "cosqa-train-12240", "docstring_tokens": ["Scale", "the", "image", "so", "that", "the", "smallest", "axis", "is", "of", "size", "targ", "."], "code": "def scale_min(im, targ, interpolation=cv2.INTER_AREA):\n    \"\"\" Scale the image so that the smallest axis is of size targ.\n\n    Arguments:\n        im (array): image\n        targ (int): target size\n    \"\"\"\n    r,c,*_ = im.shape\n    ratio = targ/min(r,c)\n    sz = (scale_to(c, ratio, targ), scale_to(r, ratio, targ))\n    return cv2.resize(im, sz, interpolation=interpolation)", "code_tokens": ["def", "scale_min", "(", "im", ",", "targ", ",", "interpolation", "=", "cv2", ".", "INTER_AREA", ")", ":", "r", ",", "c", ",", "", "*", "_", "=", "im", ".", "shape", "ratio", "=", "targ", "/", "min", "(", "r", ",", "c", ")", "sz", "=", "(", "scale_to", "(", "c", ",", "ratio", ",", "targ", ")", ",", "scale_to", "(", "r", ",", "ratio", ",", "targ", ")", ")", "return", "cv2", ".", "resize", "(", "im", ",", "sz", ",", "interpolation", "=", "interpolation", ")"], "idx": 4795}
{"url": "cosqa-train-13591", "docstring_tokens": ["Squash", "self", ".", "out", "into", "string", "."], "code": "def build_output(self, fout):\n        \"\"\"Squash self.out into string.\n\n        Join every line in self.out with a new line and write the\n        result to the output file.\n        \"\"\"\n        fout.write('\\n'.join([s for s in self.out]))", "code_tokens": ["def", "build_output", "(", "self", ",", "fout", ")", ":", "fout", ".", "write", "(", "'\\n'", ".", "join", "(", "[", "s", "for", "s", "in", "self", ".", "out", "]", ")", ")"], "idx": 688}
{"url": "cosqa-train-15027", "docstring_tokens": ["Get", "the", "file", "size", "of", "a", "given", "file"], "code": "def get_file_size(filename):\n    \"\"\"\n    Get the file size of a given file\n\n    :param filename: string: pathname of a file\n    :return: human readable filesize\n    \"\"\"\n    if os.path.isfile(filename):\n        return convert_size(os.path.getsize(filename))\n    return None", "code_tokens": ["def", "get_file_size", "(", "filename", ")", ":", "if", "os", ".", "path", ".", "isfile", "(", "filename", ")", ":", "return", "convert_size", "(", "os", ".", "path", ".", "getsize", "(", "filename", ")", ")", "return", "None"], "idx": 288}
{"url": "cosqa-train-4411", "docstring_tokens": ["Convert", "an", "ARF", "timestamp", "to", "a", "datetime", ".", "datetime", "object", "(", "naive", "local", "time", ")"], "code": "def timestamp_to_datetime(timestamp):\n    \"\"\"Convert an ARF timestamp to a datetime.datetime object (naive local time)\"\"\"\n    from datetime import datetime, timedelta\n    obj = datetime.fromtimestamp(timestamp[0])\n    return obj + timedelta(microseconds=int(timestamp[1]))", "code_tokens": ["def", "timestamp_to_datetime", "(", "timestamp", ")", ":", "from", "datetime", "import", "datetime", ",", "timedelta", "obj", "=", "datetime", ".", "fromtimestamp", "(", "timestamp", "[", "0", "]", ")", "return", "obj", "+", "timedelta", "(", "microseconds", "=", "int", "(", "timestamp", "[", "1", "]", ")", ")"], "idx": 1263}
{"url": "cosqa-train-7635", "docstring_tokens": ["Callback", "for", "comboboxes", ":", "notifies", "us", "that", "a", "combobox", "for", "the", "given", "item", "and", "column", "has", "changed"], "code": "def _updateItemComboBoxIndex(self, item, column, num):\n        \"\"\"Callback for comboboxes: notifies us that a combobox for the given item and column has changed\"\"\"\n        item._combobox_current_index[column] = num\n        item._combobox_current_value[column] = item._combobox_option_list[column][num][0]", "code_tokens": ["def", "_updateItemComboBoxIndex", "(", "self", ",", "item", ",", "column", ",", "num", ")", ":", "item", ".", "_combobox_current_index", "[", "column", "]", "=", "num", "item", ".", "_combobox_current_value", "[", "column", "]", "=", "item", ".", "_combobox_option_list", "[", "column", "]", "[", "num", "]", "[", "0", "]"], "idx": 3358}
{"url": "cosqa-train-19137", "docstring_tokens": ["Converts", "an", "dict", "to", "a", "Enum", "."], "code": "def dict_to_enum_fn(d: Dict[str, Any], enum_class: Type[Enum]) -> Enum:\n    \"\"\"\n    Converts an ``dict`` to a ``Enum``.\n    \"\"\"\n    return enum_class[d['name']]", "code_tokens": ["def", "dict_to_enum_fn", "(", "d", ":", "Dict", "[", "str", ",", "Any", "]", ",", "enum_class", ":", "Type", "[", "Enum", "]", ")", "->", "Enum", ":", "return", "enum_class", "[", "d", "[", "'name'", "]", "]"], "idx": 5688}
{"url": "cosqa-train-578", "docstring_tokens": ["Checks", "whether", "given", "class", "or", "instance", "method", "has", "been", "marked", "with", "the"], "code": "def _is_override(meta, method):\n        \"\"\"Checks whether given class or instance method has been marked\n        with the ``@override`` decorator.\n        \"\"\"\n        from taipan.objective.modifiers import _OverriddenMethod\n        return isinstance(method, _OverriddenMethod)", "code_tokens": ["def", "_is_override", "(", "meta", ",", "method", ")", ":", "from", "taipan", ".", "objective", ".", "modifiers", "import", "_OverriddenMethod", "return", "isinstance", "(", "method", ",", "_OverriddenMethod", ")"], "idx": 531}
{"url": "cosqa-train-2783", "docstring_tokens": ["Return", "the", "value", "of", "each", "QuerySet", "but", "also", "add", "the", "#", "property", "to", "each", "return", "item", "."], "code": "def _unordered_iterator(self):\n        \"\"\"\n        Return the value of each QuerySet, but also add the '#' property to each\n        return item.\n        \"\"\"\n        for i, qs in zip(self._queryset_idxs, self._querysets):\n            for item in qs:\n                setattr(item, '#', i)\n                yield item", "code_tokens": ["def", "_unordered_iterator", "(", "self", ")", ":", "for", "i", ",", "qs", "in", "zip", "(", "self", ".", "_queryset_idxs", ",", "self", ".", "_querysets", ")", ":", "for", "item", "in", "qs", ":", "setattr", "(", "item", ",", "'#'", ",", "i", ")", "yield", "item"], "idx": 2051}
{"url": "cosqa-train-7247", "docstring_tokens": ["Convert", "a", "ctypes", "double", "pointer", "array", "to", "a", "numpy", "array", "."], "code": "def cfloat64_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes double pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_double)):\n        return np.fromiter(cptr, dtype=np.float64, count=length)\n    else:\n        raise RuntimeError('Expected double pointer')", "code_tokens": ["def", "cfloat64_array_to_numpy", "(", "cptr", ",", "length", ")", ":", "if", "isinstance", "(", "cptr", ",", "ctypes", ".", "POINTER", "(", "ctypes", ".", "c_double", ")", ")", ":", "return", "np", ".", "fromiter", "(", "cptr", ",", "dtype", "=", "np", ".", "float64", ",", "count", "=", "length", ")", "else", ":", "raise", "RuntimeError", "(", "'Expected", "double", "pointer'", ")"], "idx": 64}
{"url": "cosqa-train-16947", "docstring_tokens": ["Returns", "the", "index", "of", "the", "earliest", "occurence", "of", "an", "item", "from", "a", "list", "in", "a", "string"], "code": "def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore\n    \"\"\"\n    Returns the index of the earliest occurence of an item from a list in a string\n\n    Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3\n    \"\"\"\n    start = len(txt) + 1\n    for item in str_list:\n        if start > txt.find(item) > -1:\n            start = txt.find(item)\n    return start if len(txt) + 1 > start > -1 else -1", "code_tokens": ["def", "find_first_in_list", "(", "txt", ":", "str", ",", "str_list", ":", "[", "str", "]", ")", "->", "int", ":", "#", "type:", "ignore", "start", "=", "len", "(", "txt", ")", "+", "1", "for", "item", "in", "str_list", ":", "if", "start", ">", "txt", ".", "find", "(", "item", ")", ">", "-", "1", ":", "start", "=", "txt", ".", "find", "(", "item", ")", "return", "start", "if", "len", "(", "txt", ")", "+", "1", ">", "start", ">", "-", "1", "else", "-", "1"], "idx": 5545}
{"url": "cosqa-train-7636", "docstring_tokens": ["Given", "a", "float", "returns", "a", "rounded", "int", ".", "Should", "give", "the", "same", "result", "on", "both", "Py2", "/", "3"], "code": "def intround(value):\n    \"\"\"Given a float returns a rounded int. Should give the same result on\n    both Py2/3\n    \"\"\"\n\n    return int(decimal.Decimal.from_float(\n        value).to_integral_value(decimal.ROUND_HALF_EVEN))", "code_tokens": ["def", "intround", "(", "value", ")", ":", "return", "int", "(", "decimal", ".", "Decimal", ".", "from_float", "(", "value", ")", ".", "to_integral_value", "(", "decimal", ".", "ROUND_HALF_EVEN", ")", ")"], "idx": 323}
{"url": "cosqa-train-9101", "docstring_tokens": [""], "code": "def mouse_get_pos():\n    \"\"\"\n\n    :return:\n    \"\"\"\n    p = POINT()\n    AUTO_IT.AU3_MouseGetPos(ctypes.byref(p))\n    return p.x, p.y", "code_tokens": ["def", "mouse_get_pos", "(", ")", ":", "p", "=", "POINT", "(", ")", "AUTO_IT", ".", "AU3_MouseGetPos", "(", "ctypes", ".", "byref", "(", "p", ")", ")", "return", "p", ".", "x", ",", "p", ".", "y"], "idx": 3715}
{"url": "cosqa-train-9369", "docstring_tokens": ["delete", "all", "the", "eggs", "in", "the", "directory", "specified"], "code": "def delete_all_eggs(self):\n        \"\"\" delete all the eggs in the directory specified \"\"\"\n        path_to_delete = os.path.join(self.egg_directory, \"lib\", \"python\")\n        if os.path.exists(path_to_delete):\n            shutil.rmtree(path_to_delete)", "code_tokens": ["def", "delete_all_eggs", "(", "self", ")", ":", "path_to_delete", "=", "os", ".", "path", ".", "join", "(", "self", ".", "egg_directory", ",", "\"lib\"", ",", "\"python\"", ")", "if", "os", ".", "path", ".", "exists", "(", "path_to_delete", ")", ":", "shutil", ".", "rmtree", "(", "path_to_delete", ")"], "idx": 145}
{"url": "cosqa-train-10769", "docstring_tokens": ["Returns", "a", "generator", "that", "spits", "an", "iteratable", "into", "n", "-", "sized", "chunks", ".", "The", "last", "chunk", "may", "have", "less", "than", "n", "elements", "."], "code": "def split_every(n, iterable):\n    \"\"\"Returns a generator that spits an iteratable into n-sized chunks. The last chunk may have\n    less than n elements.\n\n    See http://stackoverflow.com/a/22919323/503377.\"\"\"\n    items = iter(iterable)\n    return itertools.takewhile(bool, (list(itertools.islice(items, n)) for _ in itertools.count()))", "code_tokens": ["def", "split_every", "(", "n", ",", "iterable", ")", ":", "items", "=", "iter", "(", "iterable", ")", "return", "itertools", ".", "takewhile", "(", "bool", ",", "(", "list", "(", "itertools", ".", "islice", "(", "items", ",", "n", ")", ")", "for", "_", "in", "itertools", ".", "count", "(", ")", ")", ")"], "idx": 663}
{"url": "cosqa-train-7158", "docstring_tokens": ["Searches", "for", "the", "specified", "method", "and", "returns", "its", "descriptor", "."], "code": "def FindMethodByName(self, name):\n    \"\"\"Searches for the specified method, and returns its descriptor.\"\"\"\n    for method in self.methods:\n      if name == method.name:\n        return method\n    return None", "code_tokens": ["def", "FindMethodByName", "(", "self", ",", "name", ")", ":", "for", "method", "in", "self", ".", "methods", ":", "if", "name", "==", "method", ".", "name", ":", "return", "method", "return", "None"], "idx": 1374}
{"url": "cosqa-dev-1", "docstring_tokens": ["Split", "a", "multiline", "string", "into", "a", "list", "excluding", "blank", "lines", "."], "code": "def split_multiline(value):\n    \"\"\"Split a multiline string into a list, excluding blank lines.\"\"\"\n    return [element for element in (line.strip() for line in value.split('\\n'))\n            if element]", "code_tokens": ["def", "split_multiline", "(", "value", ")", ":", "return", "[", "element", "for", "element", "in", "(", "line", ".", "strip", "(", ")", "for", "line", "in", "value", ".", "split", "(", "'\\n'", ")", ")", "if", "element", "]"], "idx": 2133}
{"url": "cosqa-train-11225", "docstring_tokens": ["Convert", "column", "name", "to", "index", "."], "code": "def _get_col_index(name):\n    \"\"\"Convert column name to index.\"\"\"\n\n    index = string.ascii_uppercase.index\n    col = 0\n    for c in name.upper():\n        col = col * 26 + index(c) + 1\n    return col", "code_tokens": ["def", "_get_col_index", "(", "name", ")", ":", "index", "=", "string", ".", "ascii_uppercase", ".", "index", "col", "=", "0", "for", "c", "in", "name", ".", "upper", "(", ")", ":", "col", "=", "col", "*", "26", "+", "index", "(", "c", ")", "+", "1", "return", "col"], "idx": 4617}
{"url": "cosqa-train-19344", "docstring_tokens": ["Read", "and", "return", "a", "view", "of", "size", "bytes", "from", "memory", "starting", "at", "start_position", "."], "code": "def memory_read(self, start_position: int, size: int) -> memoryview:\n        \"\"\"\n        Read and return a view of ``size`` bytes from memory starting at ``start_position``.\n        \"\"\"\n        return self._memory.read(start_position, size)", "code_tokens": ["def", "memory_read", "(", "self", ",", "start_position", ":", "int", ",", "size", ":", "int", ")", "->", "memoryview", ":", "return", "self", ".", "_memory", ".", "read", "(", "start_position", ",", "size", ")"], "idx": 6189}
{"url": "cosqa-train-13411", "docstring_tokens": ["Purge", "the", "named", "cache", "of", "all", "values", ".", "If", "no", "cache", "exists", "for", "object_type", "nothing", "is", "done"], "code": "def purge_cache(self, object_type):\n        \"\"\" Purge the named cache of all values. If no cache exists for object_type, nothing is done \"\"\"\n        if object_type in self.mapping:\n            cache = self.mapping[object_type]\n            log.debug(\"Purging [{}] cache of {} values.\".format(object_type, len(cache)))\n            cache.purge()", "code_tokens": ["def", "purge_cache", "(", "self", ",", "object_type", ")", ":", "if", "object_type", "in", "self", ".", "mapping", ":", "cache", "=", "self", ".", "mapping", "[", "object_type", "]", "log", ".", "debug", "(", "\"Purging", "[{}]", "cache", "of", "{}", "values.\"", ".", "format", "(", "object_type", ",", "len", "(", "cache", ")", ")", ")", "cache", ".", "purge", "(", ")"], "idx": 5001}
{"url": "cosqa-train-8828", "docstring_tokens": ["Determine", "if", "a", "year", "is", "leap", "year", "."], "code": "def _is_leap_year(year):\n    \"\"\"Determine if a year is leap year.\n\n    Parameters\n    ----------\n    year : numeric\n\n    Returns\n    -------\n    isleap : array of bools\n    \"\"\"\n    isleap = ((np.mod(year, 4) == 0) &\n              ((np.mod(year, 100) != 0) | (np.mod(year, 400) == 0)))\n    return isleap", "code_tokens": ["def", "_is_leap_year", "(", "year", ")", ":", "isleap", "=", "(", "(", "np", ".", "mod", "(", "year", ",", "4", ")", "==", "0", ")", "&", "(", "(", "np", ".", "mod", "(", "year", ",", "100", ")", "!=", "0", ")", "|", "(", "np", ".", "mod", "(", "year", ",", "400", ")", "==", "0", ")", ")", ")", "return", "isleap"], "idx": 1475}
{"url": "cosqa-train-12428", "docstring_tokens": ["Gets", "the", "login", "credentials", "from", "the", "user", "if", "not", "specified", "while", "invoking", "the", "script", "."], "code": "def get_login_credentials(args):\n  \"\"\"\n    Gets the login credentials from the user, if not specified while invoking\n    the script.\n    @param args: arguments provided to the script.\n    \"\"\"\n  if not args.username:\n    args.username = raw_input(\"Enter Username: \")\n  if not args.password:\n    args.password = getpass.getpass(\"Enter Password: \")", "code_tokens": ["def", "get_login_credentials", "(", "args", ")", ":", "if", "not", "args", ".", "username", ":", "args", ".", "username", "=", "raw_input", "(", "\"Enter", "Username:", "\"", ")", "if", "not", "args", ".", "password", ":", "args", ".", "password", "=", "getpass", ".", "getpass", "(", "\"Enter", "Password:", "\"", ")"], "idx": 3994}
{"url": "cosqa-train-13351", "docstring_tokens": ["Check", "if", "an", "element", "from", "a", "list", "is", "in", "a", "string", "."], "code": "def isin(elems, line):\n    \"\"\"Check if an element from a list is in a string.\n\n    :type elems: list\n    :type line: str\n\n    \"\"\"\n    found = False\n    for e in elems:\n        if e in line.lower():\n            found = True\n            break\n    return found", "code_tokens": ["def", "isin", "(", "elems", ",", "line", ")", ":", "found", "=", "False", "for", "e", "in", "elems", ":", "if", "e", "in", "line", ".", "lower", "(", ")", ":", "found", "=", "True", "break", "return", "found"], "idx": 648}
{"url": "cosqa-train-18899", "docstring_tokens": ["Matrix", "multiplication", "using", "binary"], "code": "def __rmatmul__(self, other):\n        \"\"\"\n        Matrix multiplication using binary `@` operator in Python>=3.5.\n        \"\"\"\n        return self.T.dot(np.transpose(other)).T", "code_tokens": ["def", "__rmatmul__", "(", "self", ",", "other", ")", ":", "return", "self", ".", "T", ".", "dot", "(", "np", ".", "transpose", "(", "other", ")", ")", ".", "T"], "idx": 5730}
{"url": "cosqa-train-18302", "docstring_tokens": ["Convert", "a", "string", "to", "a", "list", "with", "sanitization", "."], "code": "def _str_to_list(value, separator):\n    \"\"\"Convert a string to a list with sanitization.\"\"\"\n    value_list = [item.strip() for item in value.split(separator)]\n    value_list_sanitized = builtins.list(filter(None, value_list))\n    if len(value_list_sanitized) > 0:\n        return value_list_sanitized\n    else:\n        raise ValueError('Invalid list variable.')", "code_tokens": ["def", "_str_to_list", "(", "value", ",", "separator", ")", ":", "value_list", "=", "[", "item", ".", "strip", "(", ")", "for", "item", "in", "value", ".", "split", "(", "separator", ")", "]", "value_list_sanitized", "=", "builtins", ".", "list", "(", "filter", "(", "None", ",", "value_list", ")", ")", "if", "len", "(", "value_list_sanitized", ")", ">", "0", ":", "return", "value_list_sanitized", "else", ":", "raise", "ValueError", "(", "'Invalid", "list", "variable.'", ")"], "idx": 5723}
{"url": "cosqa-train-9146", "docstring_tokens": ["Get", "adjacency", "matrix", "."], "code": "def get_adjacent_matrix(self):\n        \"\"\"Get adjacency matrix.\n\n        Returns:\n            :param adj: adjacency matrix\n            :type adj: np.ndarray\n        \"\"\"\n        edges = self.edges\n        num_edges = len(edges) + 1\n        adj = np.zeros([num_edges, num_edges])\n\n        for k in range(num_edges - 1):\n            adj[edges[k].L, edges[k].R] = 1\n            adj[edges[k].R, edges[k].L] = 1\n\n        return adj", "code_tokens": ["def", "get_adjacent_matrix", "(", "self", ")", ":", "edges", "=", "self", ".", "edges", "num_edges", "=", "len", "(", "edges", ")", "+", "1", "adj", "=", "np", ".", "zeros", "(", "[", "num_edges", ",", "num_edges", "]", ")", "for", "k", "in", "range", "(", "num_edges", "-", "1", ")", ":", "adj", "[", "edges", "[", "k", "]", ".", "L", ",", "edges", "[", "k", "]", ".", "R", "]", "=", "1", "adj", "[", "edges", "[", "k", "]", ".", "R", ",", "edges", "[", "k", "]", ".", "L", "]", "=", "1", "return", "adj"], "idx": 2149}
{"url": "cosqa-train-918", "docstring_tokens": ["Return", "the", "largest", "real", "value", "h", "such", "that", "all", "elements", "in", "x", "are", "integer", "multiples", "of", "h", "."], "code": "def _gcd_array(X):\n    \"\"\"\n    Return the largest real value h such that all elements in x are integer\n    multiples of h.\n    \"\"\"\n    greatest_common_divisor = 0.0\n    for x in X:\n        greatest_common_divisor = _gcd(greatest_common_divisor, x)\n\n    return greatest_common_divisor", "code_tokens": ["def", "_gcd_array", "(", "X", ")", ":", "greatest_common_divisor", "=", "0.0", "for", "x", "in", "X", ":", "greatest_common_divisor", "=", "_gcd", "(", "greatest_common_divisor", ",", "x", ")", "return", "greatest_common_divisor"], "idx": 302}
{"url": "cosqa-train-11708", "docstring_tokens": ["Move", "the", "cursor", "up", "a", "number", "of", "lines", "."], "code": "def move_up(lines=1, file=sys.stdout):\n    \"\"\" Move the cursor up a number of lines.\n\n        Esc[ValueA:\n        Moves the cursor up by the specified number of lines without changing\n        columns. If the cursor is already on the top line, ANSI.SYS ignores\n        this sequence.\n    \"\"\"\n    move.up(lines).write(file=file)", "code_tokens": ["def", "move_up", "(", "lines", "=", "1", ",", "file", "=", "sys", ".", "stdout", ")", ":", "move", ".", "up", "(", "lines", ")", ".", "write", "(", "file", "=", "file", ")"], "idx": 2129}
{"url": "cosqa-train-12867", "docstring_tokens": ["Output", "data", "as", "a", "nicely", "-", "formatted", "python", "data", "structure"], "code": "def py(self, output):\n        \"\"\"Output data as a nicely-formatted python data structure\"\"\"\n        import pprint\n        pprint.pprint(output, stream=self.outfile)", "code_tokens": ["def", "py", "(", "self", ",", "output", ")", ":", "import", "pprint", "pprint", ".", "pprint", "(", "output", ",", "stream", "=", "self", ".", "outfile", ")"], "idx": 925}
{"url": "cosqa-train-13054", "docstring_tokens": ["Return", "a", "copy", "of", "the", "tuple", "as", "a", "list"], "code": "def to_json(value, **kwargs):\n        \"\"\"Return a copy of the tuple as a list\n\n        If the tuple contains HasProperties instances, they are serialized.\n        \"\"\"\n        serial_list = [\n            val.serialize(**kwargs) if isinstance(val, HasProperties)\n            else val for val in value\n        ]\n        return serial_list", "code_tokens": ["def", "to_json", "(", "value", ",", "*", "*", "kwargs", ")", ":", "serial_list", "=", "[", "val", ".", "serialize", "(", "*", "*", "kwargs", ")", "if", "isinstance", "(", "val", ",", "HasProperties", ")", "else", "val", "for", "val", "in", "value", "]", "return", "serial_list"], "idx": 4919}
{"url": "cosqa-train-885", "docstring_tokens": ["Generates", "a", "LaTeX", "table", "from", "parameter", "summaries", "."], "code": "def get_latex_table(self, parameters=None, transpose=False, caption=None,\n                        label=\"tab:model_params\", hlines=True, blank_fill=\"--\"):  # pragma: no cover\n        \"\"\" Generates a LaTeX table from parameter summaries.\n\n        Parameters\n        ----------\n        parameters : list[str], optional\n            A list of what parameters to include in the table. By default, includes all parameters\n        transpose : bool, optional\n            Defaults to False, which gives each column as a parameter, each chain (framework)\n            as a row. You can swap it so that you have a parameter each row and a framework\n            each column by setting this to True\n        caption : str, optional\n            If you want to generate a caption for the table through Python, use this.\n            Defaults to an empty string\n        label : str, optional\n            If you want to generate a label for the table through Python, use this.\n            Defaults to an empty string\n        hlines : bool, optional\n            Inserts ``\\\\hline`` before and after the header, and at the end of table.\n        blank_fill : str, optional\n            If a framework does not have a particular parameter, will fill that cell of\n            the table with this string.\n\n        Returns\n        -------\n        str\n            the LaTeX table.\n        \"\"\"\n        if parameters is None:\n            parameters = self.parent._all_parameters\n        for p in parameters:\n            assert isinstance(p, str), \\\n                \"Generating a LaTeX table requires all parameters have labels\"\n        num_parameters = len(parameters)\n        num_chains = len(self.parent.chains)\n        fit_values = self.get_summary(squeeze=False)\n        if label is None:\n            label = \"\"\n        if caption is None:\n            caption = \"\"\n\n        end_text = \" \\\\\\\\ \\n\"\n        if transpose:\n            column_text = \"c\" * (num_chains + 1)\n        else:\n            column_text = \"c\" * (num_parameters + 1)\n\n        center_text = \"\"\n        hline_text = \"\\\\hline\\n\"\n        if hlines:\n            center_text += hline_text + \"\\t\\t\"\n        if transpose:\n            center_text += \" & \".join([\"Parameter\"] + [c.name for c in self.parent.chains]) + end_text\n            if hlines:\n                center_text += \"\\t\\t\" + hline_text\n            for p in parameters:\n                arr = [\"\\t\\t\" + p]\n                for chain_res in fit_values:\n                    if p in chain_res:\n                        arr.append(self.get_parameter_text(*chain_res[p], wrap=True))\n                    else:\n                        arr.append(blank_fill)\n                center_text += \" & \".join(arr) + end_text\n        else:\n            center_text += \" & \".join([\"Model\"] + parameters) + end_text\n            if hlines:\n                center_text += \"\\t\\t\" + hline_text\n            for name, chain_res in zip([c.name for c in self.parent.chains], fit_values):\n                arr = [\"\\t\\t\" + name]\n                for p in parameters:\n                    if p in chain_res:\n                        arr.append(self.get_parameter_text(*chain_res[p], wrap=True))\n                    else:\n                        arr.append(blank_fill)\n                center_text += \" & \".join(arr) + end_text\n        if hlines:\n            center_text += \"\\t\\t\" + hline_text\n        final_text = get_latex_table_frame(caption, label) % (column_text, center_text)\n\n        return final_text", "code_tokens": ["def", "get_latex_table", "(", "self", ",", "parameters", "=", "None", ",", "transpose", "=", "False", ",", "caption", "=", "None", ",", "label", "=", "\"tab:model_params\"", ",", "hlines", "=", "True", ",", "blank_fill", "=", "\"--\"", ")", ":", "#", "pragma:", "no", "cover", "if", "parameters", "is", "None", ":", "parameters", "=", "self", ".", "parent", ".", "_all_parameters", "for", "p", "in", "parameters", ":", "assert", "isinstance", "(", "p", ",", "str", ")", ",", "\"Generating", "a", "LaTeX", "table", "requires", "all", "parameters", "have", "labels\"", "num_parameters", "=", "len", "(", "parameters", ")", "num_chains", "=", "len", "(", "self", ".", "parent", ".", "chains", ")", "fit_values", "=", "self", ".", "get_summary", "(", "squeeze", "=", "False", ")", "if", "label", "is", "None", ":", "label", "=", "\"\"", "if", "caption", "is", "None", ":", "caption", "=", "\"\"", "end_text", "=", "\"", "\\\\\\\\", "\\n\"", "if", "transpose", ":", "column_text", "=", "\"c\"", "*", "(", "num_chains", "+", "1", ")", "else", ":", "column_text", "=", "\"c\"", "*", "(", "num_parameters", "+", "1", ")", "center_text", "=", "\"\"", "hline_text", "=", "\"\\\\hline\\n\"", "if", "hlines", ":", "center_text", "+=", "hline_text", "+", "\"\\t\\t\"", "if", "transpose", ":", "center_text", "+=", "\"", "&", "\"", ".", "join", "(", "[", "\"Parameter\"", "]", "+", "[", "c", ".", "name", "for", "c", "in", "self", ".", "parent", ".", "chains", "]", ")", "+", "end_text", "if", "hlines", ":", "center_text", "+=", "\"\\t\\t\"", "+", "hline_text", "for", "p", "in", "parameters", ":", "arr", "=", "[", "\"\\t\\t\"", "+", "p", "]", "for", "chain_res", "in", "fit_values", ":", "if", "p", "in", "chain_res", ":", "arr", ".", "append", "(", "self", ".", "get_parameter_text", "(", "*", "chain_res", "[", "p", "]", ",", "wrap", "=", "True", ")", ")", "else", ":", "arr", ".", "append", "(", "blank_fill", ")", "center_text", "+=", "\"", "&", "\"", ".", "join", "(", "arr", ")", "+", "end_text", "else", ":", "center_text", "+=", "\"", "&", "\"", ".", "join", "(", "[", "\"Model\"", "]", "+", "parameters", ")", "+", "end_text", "if", "hlines", ":", "center_text", "+=", "\"\\t\\t\"", "+", "hline_text", "for", "name", ",", "chain_res", "in", "zip", "(", "[", "c", ".", "name", "for", "c", "in", "self", ".", "parent", ".", "chains", "]", ",", "fit_values", ")", ":", "arr", "=", "[", "\"\\t\\t\"", "+", "name", "]", "for", "p", "in", "parameters", ":", "if", "p", "in", "chain_res", ":", "arr", ".", "append", "(", "self", ".", "get_parameter_text", "(", "*", "chain_res", "[", "p", "]", ",", "wrap", "=", "True", ")", ")", "else", ":", "arr", ".", "append", "(", "blank_fill", ")", "center_text", "+=", "\"", "&", "\"", ".", "join", "(", "arr", ")", "+", "end_text", "if", "hlines", ":", "center_text", "+=", "\"\\t\\t\"", "+", "hline_text", "final_text", "=", "get_latex_table_frame", "(", "caption", ",", "label", ")", "%", "(", "column_text", ",", "center_text", ")", "return", "final_text"], "idx": 789}
{"url": "cosqa-train-9080", "docstring_tokens": ["Display", "both", "SQLAlchemy", "and", "Python", "help", "statements"], "code": "def _help():\n    \"\"\" Display both SQLAlchemy and Python help statements \"\"\"\n\n    statement = '%s%s' % (shelp, phelp % ', '.join(cntx_.keys()))\n    print statement.strip()", "code_tokens": ["def", "_help", "(", ")", ":", "statement", "=", "'%s%s'", "%", "(", "shelp", ",", "phelp", "%", "',", "'", ".", "join", "(", "cntx_", ".", "keys", "(", ")", ")", ")", "print", "statement", ".", "strip", "(", ")"], "idx": 2266}
{"url": "cosqa-train-10090", "docstring_tokens": ["Push", "item", "onto", "heap", "maintaining", "the", "heap", "invariant", "."], "code": "def heappush_max(heap, item):\n    \"\"\"Push item onto heap, maintaining the heap invariant.\"\"\"\n    heap.append(item)\n    _siftdown_max(heap, 0, len(heap) - 1)", "code_tokens": ["def", "heappush_max", "(", "heap", ",", "item", ")", ":", "heap", ".", "append", "(", "item", ")", "_siftdown_max", "(", "heap", ",", "0", ",", "len", "(", "heap", ")", "-", "1", ")"], "idx": 508}
{"url": "cosqa-train-9261", "docstring_tokens": [":", "type", "s", ":", "str", ":", "rtype", ":", "int"], "code": "def first_unique_char(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if (len(s) == 1):\n        return 0\n    ban = []\n    for i in range(len(s)):\n        if all(s[i] != s[k] for k in range(i + 1, len(s))) == True and s[i] not in ban:\n            return i\n        else:\n            ban.append(s[i])\n    return -1", "code_tokens": ["def", "first_unique_char", "(", "s", ")", ":", "if", "(", "len", "(", "s", ")", "==", "1", ")", ":", "return", "0", "ban", "=", "[", "]", "for", "i", "in", "range", "(", "len", "(", "s", ")", ")", ":", "if", "all", "(", "s", "[", "i", "]", "!=", "s", "[", "k", "]", "for", "k", "in", "range", "(", "i", "+", "1", ",", "len", "(", "s", ")", ")", ")", "==", "True", "and", "s", "[", "i", "]", "not", "in", "ban", ":", "return", "i", "else", ":", "ban", ".", "append", "(", "s", "[", "i", "]", ")", "return", "-", "1"], "idx": 3503}
{"url": "cosqa-train-15810", "docstring_tokens": ["Pick", "an", "unused", "port", ".", "There", "is", "a", "slight", "chance", "that", "this", "wont", "work", "."], "code": "def pick_unused_port(self):\n    \"\"\" Pick an unused port. There is a slight chance that this wont work. \"\"\"\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.bind(('127.0.0.1', 0))\n    _, port = s.getsockname()\n    s.close()\n    return port", "code_tokens": ["def", "pick_unused_port", "(", "self", ")", ":", "s", "=", "socket", ".", "socket", "(", "socket", ".", "AF_INET", ",", "socket", ".", "SOCK_STREAM", ")", "s", ".", "bind", "(", "(", "'127.0.0.1'", ",", "0", ")", ")", "_", ",", "port", "=", "s", ".", "getsockname", "(", ")", "s", ".", "close", "(", ")", "return", "port"], "idx": 2379}
{"url": "cosqa-train-4418", "docstring_tokens": ["Validate", "the", "configuration", "file", "."], "code": "def validate(self):\n        \"\"\"Validate the configuration file.\"\"\"\n        validator = Draft4Validator(self.SCHEMA)\n        if not validator.is_valid(self.config):\n            for err in validator.iter_errors(self.config):\n                LOGGER.error(str(err.message))\n            validator.validate(self.config)", "code_tokens": ["def", "validate", "(", "self", ")", ":", "validator", "=", "Draft4Validator", "(", "self", ".", "SCHEMA", ")", "if", "not", "validator", ".", "is_valid", "(", "self", ".", "config", ")", ":", "for", "err", "in", "validator", ".", "iter_errors", "(", "self", ".", "config", ")", ":", "LOGGER", ".", "error", "(", "str", "(", "err", ".", "message", ")", ")", "validator", ".", "validate", "(", "self", ".", "config", ")"], "idx": 2808}
{"url": "cosqa-train-11185", "docstring_tokens": ["Get", "the", "number", "of", "rows", "in", "a", "particular", "table", "."], "code": "def count_rows(self, table, cols='*'):\n        \"\"\"Get the number of rows in a particular table.\"\"\"\n        query = 'SELECT COUNT({0}) FROM {1}'.format(join_cols(cols), wrap(table))\n        result = self.fetch(query)\n        return result if result is not None else 0", "code_tokens": ["def", "count_rows", "(", "self", ",", "table", ",", "cols", "=", "'*'", ")", ":", "query", "=", "'SELECT", "COUNT({0})", "FROM", "{1}'", ".", "format", "(", "join_cols", "(", "cols", ")", ",", "wrap", "(", "table", ")", ")", "result", "=", "self", ".", "fetch", "(", "query", ")", "return", "result", "if", "result", "is", "not", "None", "else", "0"], "idx": 4609}
{"url": "cosqa-train-6382", "docstring_tokens": ["Create", "an", "index", "field", "from", "this", "field"], "code": "def to_index(self, index_type, index_name, includes=None):\n        \"\"\" Create an index field from this field \"\"\"\n        return IndexField(self.name, self.data_type, index_type, index_name, includes)", "code_tokens": ["def", "to_index", "(", "self", ",", "index_type", ",", "index_name", ",", "includes", "=", "None", ")", ":", "return", "IndexField", "(", "self", ".", "name", ",", "self", ".", "data_type", ",", "index_type", ",", "index_name", ",", "includes", ")"], "idx": 3472}
{"url": "cosqa-train-17114", "docstring_tokens": ["Return", "a", "tuple", "from", "parsing", "a", "b", "c", "d", "-", ">", "(", "a", "b", "c", "d", ")"], "code": "def _parse_tuple_string(argument):\n        \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"\n        if isinstance(argument, str):\n            return tuple(int(p.strip()) for p in argument.split(','))\n        return argument", "code_tokens": ["def", "_parse_tuple_string", "(", "argument", ")", ":", "if", "isinstance", "(", "argument", ",", "str", ")", ":", "return", "tuple", "(", "int", "(", "p", ".", "strip", "(", ")", ")", "for", "p", "in", "argument", ".", "split", "(", "','", ")", ")", "return", "argument"], "idx": 5669}
{"url": "cosqa-train-11447", "docstring_tokens": ["Strips", "a", "figure", "into", "multiple", "figures", "with", "a", "trace", "on", "each", "of", "them"], "code": "def strip_figures(figure):\n\t\"\"\"\n\tStrips a figure into multiple figures with a trace on each of them\n\n\tParameters:\n\t-----------\n\t\tfigure : Figure\n\t\t\tPlotly Figure\n\t\"\"\"\n\tfig=[]\n\tfor trace in figure['data']:\n\t\tfig.append(dict(data=[trace],layout=figure['layout']))\n\treturn fig", "code_tokens": ["def", "strip_figures", "(", "figure", ")", ":", "fig", "=", "[", "]", "for", "trace", "in", "figure", "[", "'data'", "]", ":", "fig", ".", "append", "(", "dict", "(", "data", "=", "[", "trace", "]", ",", "layout", "=", "figure", "[", "'layout'", "]", ")", ")", "return", "fig"], "idx": 1715}
{"url": "cosqa-train-14293", "docstring_tokens": ["Check", "the", "syntax", "of", "the", "given", "URL", "."], "code": "def url_syntax_check(url):  # pragma: no cover\n    \"\"\"\n    Check the syntax of the given URL.\n\n    :param url: The URL to check the syntax for.\n    :type url: str\n\n    :return: The syntax validity.\n    :rtype: bool\n\n    .. warning::\n        If an empty or a non-string :code:`url` is given, we return :code:`None`.\n    \"\"\"\n\n    if url and isinstance(url, str):\n        # The given URL is not empty nor None.\n        # and\n        # * The given URL is a string.\n\n        # We silently load the configuration.\n        load_config(True)\n\n        return Check(url).is_url_valid()\n\n    # We return None, there is nothing to check.\n    return None", "code_tokens": ["def", "url_syntax_check", "(", "url", ")", ":", "#", "pragma:", "no", "cover", "if", "url", "and", "isinstance", "(", "url", ",", "str", ")", ":", "#", "The", "given", "URL", "is", "not", "empty", "nor", "None.", "#", "and", "#", "*", "The", "given", "URL", "is", "a", "string.", "#", "We", "silently", "load", "the", "configuration.", "load_config", "(", "True", ")", "return", "Check", "(", "url", ")", ".", "is_url_valid", "(", ")", "#", "We", "return", "None,", "there", "is", "nothing", "to", "check.", "return", "None"], "idx": 4006}
{"url": "cosqa-train-8457", "docstring_tokens": ["This", "is", "a", "compatibility", "function", "that", "takes", "a", "C", "{", "float", "}", "and", "converts", "it", "to", "an", "C", "{", "int", "}", "if", "the", "values", "are", "equal", "."], "code": "def _check_for_int(x):\n    \"\"\"\n    This is a compatibility function that takes a C{float} and converts it to an\n    C{int} if the values are equal.\n    \"\"\"\n    try:\n        y = int(x)\n    except (OverflowError, ValueError):\n        pass\n    else:\n        # There is no way in AMF0 to distinguish between integers and floats\n        if x == x and y == x:\n            return y\n\n    return x", "code_tokens": ["def", "_check_for_int", "(", "x", ")", ":", "try", ":", "y", "=", "int", "(", "x", ")", "except", "(", "OverflowError", ",", "ValueError", ")", ":", "pass", "else", ":", "#", "There", "is", "no", "way", "in", "AMF0", "to", "distinguish", "between", "integers", "and", "floats", "if", "x", "==", "x", "and", "y", "==", "x", ":", "return", "y", "return", "x"], "idx": 289}
{"url": "cosqa-train-11585", "docstring_tokens": ["Start", "a", "Pdb", "instance", "at", "the", "calling", "frame", "with", "stdout", "routed", "to", "sys", ".", "__stdout__", "."], "code": "def set_trace():\n    \"\"\"Start a Pdb instance at the calling frame, with stdout routed to sys.__stdout__.\"\"\"\n    # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py\n    pdb.Pdb(stdout=sys.__stdout__).set_trace(sys._getframe().f_back)", "code_tokens": ["def", "set_trace", "(", ")", ":", "#", "https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py", "pdb", ".", "Pdb", "(", "stdout", "=", "sys", ".", "__stdout__", ")", ".", "set_trace", "(", "sys", ".", "_getframe", "(", ")", ".", "f_back", ")"], "idx": 900}
{"url": "cosqa-train-7568", "docstring_tokens": ["Returns", "the", "result", "of", "a", "number", "raised", "to", "a", "power"], "code": "def _power(ctx, number, power):\n    \"\"\"\n    Returns the result of a number raised to a power\n    \"\"\"\n    return decimal_pow(conversions.to_decimal(number, ctx), conversions.to_decimal(power, ctx))", "code_tokens": ["def", "_power", "(", "ctx", ",", "number", ",", "power", ")", ":", "return", "decimal_pow", "(", "conversions", ".", "to_decimal", "(", "number", ",", "ctx", ")", ",", "conversions", ".", "to_decimal", "(", "power", ",", "ctx", ")", ")"], "idx": 3816}
{"url": "cosqa-train-7677", "docstring_tokens": ["Make", "bars", "in", "horizontal", "bar", "chart", "thinner"], "code": "def _change_height(self, ax, new_value):\n        \"\"\"Make bars in horizontal bar chart thinner\"\"\"\n        for patch in ax.patches:\n            current_height = patch.get_height()\n            diff = current_height - new_value\n\n            # we change the bar height\n            patch.set_height(new_value)\n\n            # we recenter the bar\n            patch.set_y(patch.get_y() + diff * .5)", "code_tokens": ["def", "_change_height", "(", "self", ",", "ax", ",", "new_value", ")", ":", "for", "patch", "in", "ax", ".", "patches", ":", "current_height", "=", "patch", ".", "get_height", "(", ")", "diff", "=", "current_height", "-", "new_value", "#", "we", "change", "the", "bar", "height", "patch", ".", "set_height", "(", "new_value", ")", "#", "we", "recenter", "the", "bar", "patch", ".", "set_y", "(", "patch", ".", "get_y", "(", ")", "+", "diff", "*", ".5", ")"], "idx": 1996}
{"url": "cosqa-train-14814", "docstring_tokens": ["Add", "an", "object", "to", "Javascript", "."], "code": "def add_to_js(self, name, var):\n        \"\"\"Add an object to Javascript.\"\"\"\n        frame = self.page().mainFrame()\n        frame.addToJavaScriptWindowObject(name, var)", "code_tokens": ["def", "add_to_js", "(", "self", ",", "name", ",", "var", ")", ":", "frame", "=", "self", ".", "page", "(", ")", ".", "mainFrame", "(", ")", "frame", ".", "addToJavaScriptWindowObject", "(", "name", ",", "var", ")"], "idx": 128}
{"url": "cosqa-train-9979", "docstring_tokens": ["Return", "the", "dot", "product", "of", "two", "vectors"], "code": "def dot_v2(vec1, vec2):\n    \"\"\"Return the dot product of two vectors\"\"\"\n\n    return vec1.x * vec2.x + vec1.y * vec2.y", "code_tokens": ["def", "dot_v2", "(", "vec1", ",", "vec2", ")", ":", "return", "vec1", ".", "x", "*", "vec2", ".", "x", "+", "vec1", ".", "y", "*", "vec2", ".", "y"], "idx": 3581}
{"url": "cosqa-train-12860", "docstring_tokens": [""], "code": "def parsed_args():\n    parser = argparse.ArgumentParser(description=\"\"\"python runtime functions\"\"\", epilog=\"\")\n    parser.add_argument('command',nargs='*',\n        help=\"Name of the function to run with arguments\")\n    args = parser.parse_args()\n    return (args, parser)", "code_tokens": ["def", "parsed_args", "(", ")", ":", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"\"\"python", "runtime", "functions\"\"\"", ",", "epilog", "=", "\"\"", ")", "parser", ".", "add_argument", "(", "'command'", ",", "nargs", "=", "'*'", ",", "help", "=", "\"Name", "of", "the", "function", "to", "run", "with", "arguments\"", ")", "args", "=", "parser", ".", "parse_args", "(", ")", "return", "(", "args", ",", "parser", ")"], "idx": 3283}
{"url": "cosqa-train-8681", "docstring_tokens": ["Draw", "a", "vertical", "line", "up", "to", "a", "given", "length", "."], "code": "def vline(self, x, y, height, color):\n        \"\"\"Draw a vertical line up to a given length.\"\"\"\n        self.rect(x, y, 1, height, color, fill=True)", "code_tokens": ["def", "vline", "(", "self", ",", "x", ",", "y", ",", "height", ",", "color", ")", ":", "self", ".", "rect", "(", "x", ",", "y", ",", "1", ",", "height", ",", "color", ",", "fill", "=", "True", ")"], "idx": 3875}
{"url": "cosqa-train-13176", "docstring_tokens": ["Convenience", "function", "for", "loading", "yaml", "-", "encoded", "data", "from", "disk", "."], "code": "def load_yaml(filepath):\n    \"\"\"Convenience function for loading yaml-encoded data from disk.\"\"\"\n    with open(filepath) as f:\n        txt = f.read()\n    return yaml.load(txt)", "code_tokens": ["def", "load_yaml", "(", "filepath", ")", ":", "with", "open", "(", "filepath", ")", "as", "f", ":", "txt", "=", "f", ".", "read", "(", ")", "return", "yaml", ".", "load", "(", "txt", ")"], "idx": 1096}
{"url": "cosqa-train-15044", "docstring_tokens": ["Whether", "this", "path", "is", "a", "symbolic", "link", "."], "code": "def is_symlink(self):\n        \"\"\"\n        Whether this path is a symbolic link.\n        \"\"\"\n        try:\n            return S_ISLNK(self.lstat().st_mode)\n        except OSError as e:\n            if e.errno != ENOENT:\n                raise\n            # Path doesn't exist\n            return False", "code_tokens": ["def", "is_symlink", "(", "self", ")", ":", "try", ":", "return", "S_ISLNK", "(", "self", ".", "lstat", "(", ")", ".", "st_mode", ")", "except", "OSError", "as", "e", ":", "if", "e", ".", "errno", "!=", "ENOENT", ":", "raise", "#", "Path", "doesn't", "exist", "return", "False"], "idx": 1607}
{"url": "cosqa-train-10452", "docstring_tokens": ["Whether", "the", "item", "is", "a", "placeholder", "or", "contains", "a", "placeholder", "."], "code": "def _not_none(items):\n    \"\"\"Whether the item is a placeholder or contains a placeholder.\"\"\"\n    if not isinstance(items, (tuple, list)):\n        items = (items,)\n    return all(item is not _none for item in items)", "code_tokens": ["def", "_not_none", "(", "items", ")", ":", "if", "not", "isinstance", "(", "items", ",", "(", "tuple", ",", "list", ")", ")", ":", "items", "=", "(", "items", ",", ")", "return", "all", "(", "item", "is", "not", "_none", "for", "item", "in", "items", ")"], "idx": 208}
{"url": "cosqa-train-18500", "docstring_tokens": ["Drops", "(", "deletes", ")", "a", "column", "from", "an", "existing", "table", "."], "code": "def drop_column(self, tablename: str, fieldname: str) -> int:\n        \"\"\"Drops (deletes) a column from an existing table.\"\"\"\n        sql = \"ALTER TABLE {} DROP COLUMN {}\".format(tablename, fieldname)\n        log.info(sql)\n        return self.db_exec_literal(sql)", "code_tokens": ["def", "drop_column", "(", "self", ",", "tablename", ":", "str", ",", "fieldname", ":", "str", ")", "->", "int", ":", "sql", "=", "\"ALTER", "TABLE", "{}", "DROP", "COLUMN", "{}\"", ".", "format", "(", "tablename", ",", "fieldname", ")", "log", ".", "info", "(", "sql", ")", "return", "self", ".", "db_exec_literal", "(", "sql", ")"], "idx": 6069}
{"url": "cosqa-train-8600", "docstring_tokens": ["Compute", "the", "eigvals", "of", "mat", "and", "then", "find", "the", "center", "eigval", "difference", "."], "code": "def center_eigenvalue_diff(mat):\n    \"\"\"Compute the eigvals of mat and then find the center eigval difference.\"\"\"\n    N = len(mat)\n    evals = np.sort(la.eigvals(mat))\n    diff = np.abs(evals[N/2] - evals[N/2-1])\n    return diff", "code_tokens": ["def", "center_eigenvalue_diff", "(", "mat", ")", ":", "N", "=", "len", "(", "mat", ")", "evals", "=", "np", ".", "sort", "(", "la", ".", "eigvals", "(", "mat", ")", ")", "diff", "=", "np", ".", "abs", "(", "evals", "[", "N", "/", "2", "]", "-", "evals", "[", "N", "/", "2", "-", "1", "]", ")", "return", "diff"], "idx": 445}
{"url": "cosqa-train-19250", "docstring_tokens": ["List", "the", "usb", "id", "of", "all", "android", "devices", "connected", "to", "the", "computer", "that", "are", "detected", "by", "adb", "."], "code": "def list_adb_devices_by_usb_id():\n    \"\"\"List the usb id of all android devices connected to the computer that\n    are detected by adb.\n\n    Returns:\n        A list of strings that are android device usb ids. Empty if there's\n        none.\n    \"\"\"\n    out = adb.AdbProxy().devices(['-l'])\n    clean_lines = new_str(out, 'utf-8').strip().split('\\n')\n    results = []\n    for line in clean_lines:\n        tokens = line.strip().split()\n        if len(tokens) > 2 and tokens[1] == 'device':\n            results.append(tokens[2])\n    return results", "code_tokens": ["def", "list_adb_devices_by_usb_id", "(", ")", ":", "out", "=", "adb", ".", "AdbProxy", "(", ")", ".", "devices", "(", "[", "'-l'", "]", ")", "clean_lines", "=", "new_str", "(", "out", ",", "'utf-8'", ")", ".", "strip", "(", ")", ".", "split", "(", "'\\n'", ")", "results", "=", "[", "]", "for", "line", "in", "clean_lines", ":", "tokens", "=", "line", ".", "strip", "(", ")", ".", "split", "(", ")", "if", "len", "(", "tokens", ")", ">", "2", "and", "tokens", "[", "1", "]", "==", "'device'", ":", "results", ".", "append", "(", "tokens", "[", "2", "]", ")", "return", "results"], "idx": 6061}
{"url": "cosqa-train-5000", "docstring_tokens": ["Convert", "a", "string", "from", "snake", "case", "to", "camel", "case", "with", "the", "first", "letter", "capitalized", ".", "For", "example", "some_var", "would", "become", "SomeVar", "."], "code": "def to_capitalized_camel_case(snake_case_string):\n    \"\"\"\n    Convert a string from snake case to camel case with the first letter capitalized. For example, \"some_var\"\n    would become \"SomeVar\".\n\n    :param snake_case_string: Snake-cased string to convert to camel case.\n    :returns: Camel-cased version of snake_case_string.\n    \"\"\"\n    parts = snake_case_string.split('_')\n    return ''.join([i.title() for i in parts])", "code_tokens": ["def", "to_capitalized_camel_case", "(", "snake_case_string", ")", ":", "parts", "=", "snake_case_string", ".", "split", "(", "'_'", ")", "return", "''", ".", "join", "(", "[", "i", ".", "title", "(", ")", "for", "i", "in", "parts", "]", ")"], "idx": 1625}
{"url": "cosqa-train-6678", "docstring_tokens": ["Try", "to", "get", "a", "number", "out", "of", "a", "string", "and", "cast", "it", "."], "code": "def get_number(s, cast=int):\n    \"\"\"\n    Try to get a number out of a string, and cast it.\n    \"\"\"\n    import string\n    d = \"\".join(x for x in str(s) if x in string.digits)\n    return cast(d)", "code_tokens": ["def", "get_number", "(", "s", ",", "cast", "=", "int", ")", ":", "import", "string", "d", "=", "\"\"", ".", "join", "(", "x", "for", "x", "in", "str", "(", "s", ")", "if", "x", "in", "string", ".", "digits", ")", "return", "cast", "(", "d", ")"], "idx": 40}
{"url": "cosqa-train-15687", "docstring_tokens": ["A", "messy", "way", "to", "import", "library", "-", "specific", "classes", ".", "TODO", ":", "I", "should", "really", "make", "a", "factory", "class", "or", "something", "but", "I", "m", "lazy", ".", "Plus", "factories", "remind", "me", "a", "lot", "of", "java", "..."], "code": "def _import(module, cls):\n    \"\"\"\n    A messy way to import library-specific classes.\n    TODO: I should really make a factory class or something, but I'm lazy.\n    Plus, factories remind me a lot of java...\n    \"\"\"\n    global Scanner\n\n    try:\n        cls = str(cls)\n        mod = __import__(str(module), globals(), locals(), [cls], 1)\n        Scanner = getattr(mod, cls)\n    except ImportError:\n        pass", "code_tokens": ["def", "_import", "(", "module", ",", "cls", ")", ":", "global", "Scanner", "try", ":", "cls", "=", "str", "(", "cls", ")", "mod", "=", "__import__", "(", "str", "(", "module", ")", ",", "globals", "(", ")", ",", "locals", "(", ")", ",", "[", "cls", "]", ",", "1", ")", "Scanner", "=", "getattr", "(", "mod", ",", "cls", ")", "except", "ImportError", ":", "pass"], "idx": 3089}
{"url": "cosqa-train-17221", "docstring_tokens": ["Applies", "maspy", ".", "xml", ".", "clearTag", "()", "to", "the", "tag", "attribute", "of", "the", "element", "and", "recursively", "to", "all", "child", "elements", "."], "code": "def recClearTag(element):\n    \"\"\"Applies maspy.xml.clearTag() to the tag attribute of the \"element\" and\n    recursively to all child elements.\n\n    :param element: an :instance:`xml.etree.Element`\n    \"\"\"\n    children = element.getchildren()\n    if len(children) > 0:\n        for child in children:\n            recClearTag(child)\n    element.tag = clearTag(element.tag)", "code_tokens": ["def", "recClearTag", "(", "element", ")", ":", "children", "=", "element", ".", "getchildren", "(", ")", "if", "len", "(", "children", ")", ">", "0", ":", "for", "child", "in", "children", ":", "recClearTag", "(", "child", ")", "element", ".", "tag", "=", "clearTag", "(", "element", ".", "tag", ")"], "idx": 5570}
{"url": "cosqa-train-10541", "docstring_tokens": ["Store", "the", "user", "session", "for", "a", "client", "."], "code": "def save_session(self, sid, session, namespace=None):\n        \"\"\"Store the user session for a client.\n\n        The only difference with the :func:`socketio.Server.save_session`\n        method is that when the ``namespace`` argument is not given the\n        namespace associated with the class is used.\n        \"\"\"\n        return self.server.save_session(\n            sid, session, namespace=namespace or self.namespace)", "code_tokens": ["def", "save_session", "(", "self", ",", "sid", ",", "session", ",", "namespace", "=", "None", ")", ":", "return", "self", ".", "server", ".", "save_session", "(", "sid", ",", "session", ",", "namespace", "=", "namespace", "or", "self", ".", "namespace", ")"], "idx": 1242}
{"url": "cosqa-train-10553", "docstring_tokens": ["A", "decorator", "for", "providing", "a", "unittest", "with", "a", "library", "and", "have", "it", "called", "only", "once", "."], "code": "def library(func):\n    \"\"\"\n    A decorator for providing a unittest with a library and have it called only\n    once.\n    \"\"\"\n    @wraps(func)\n    def wrapped(*args, **kwargs):\n        \"\"\"Transparent wrapper.\"\"\"\n        return func(*args, **kwargs)\n    SINGLES.append(wrapped)\n    return wrapped", "code_tokens": ["def", "library", "(", "func", ")", ":", "@", "wraps", "(", "func", ")", "def", "wrapped", "(", "*", "args", ",", "*", "*", "kwargs", ")", ":", "\"\"\"Transparent", "wrapper.\"\"\"", "return", "func", "(", "*", "args", ",", "*", "*", "kwargs", ")", "SINGLES", ".", "append", "(", "wrapped", ")", "return", "wrapped"], "idx": 4501}
{"url": "cosqa-train-10858", "docstring_tokens": ["Returns", "a", "character", "delimited", "version", "of", "the", "provided", "list", "as", "a", "Python", "string"], "code": "def delimited(items, character='|'):\n    \"\"\"Returns a character delimited version of the provided list as a Python string\"\"\"\n    return '|'.join(items) if type(items) in (list, tuple, set) else items", "code_tokens": ["def", "delimited", "(", "items", ",", "character", "=", "'|'", ")", ":", "return", "'|'", ".", "join", "(", "items", ")", "if", "type", "(", "items", ")", "in", "(", "list", ",", "tuple", ",", "set", ")", "else", "items"], "idx": 1295}
{"url": "cosqa-train-7049", "docstring_tokens": ["Returns", "symbol", "instances", "corresponding", "to", "variables", "of", "the", "current", "scope", "."], "code": "def vars_(self):\n        \"\"\" Returns symbol instances corresponding to variables\n        of the current scope.\n        \"\"\"\n        return [x for x in self[self.current_scope].values() if x.class_ == CLASS.var]", "code_tokens": ["def", "vars_", "(", "self", ")", ":", "return", "[", "x", "for", "x", "in", "self", "[", "self", ".", "current_scope", "]", ".", "values", "(", ")", "if", "x", ".", "class_", "==", "CLASS", ".", "var", "]"], "idx": 3654}
{"url": "cosqa-train-9857", "docstring_tokens": ["Stop", "stream", "."], "code": "def stop(self):\n        \"\"\"Stop stream.\"\"\"\n        if self.stream and self.stream.session.state != STATE_STOPPED:\n            self.stream.stop()", "code_tokens": ["def", "stop", "(", "self", ")", ":", "if", "self", ".", "stream", "and", "self", ".", "stream", ".", "session", ".", "state", "!=", "STATE_STOPPED", ":", "self", ".", "stream", ".", "stop", "(", ")"], "idx": 4342}
{"url": "cosqa-train-6411", "docstring_tokens": ["Upload", "a", "local", "file", "on", "the", "remote", "host", "."], "code": "def send_file(self, local_path, remote_path, user='root', unix_mode=None):\n        \"\"\"Upload a local file on the remote host.\n        \"\"\"\n        self.enable_user(user)\n        return self.ssh_pool.send_file(user, local_path, remote_path, unix_mode=unix_mode)", "code_tokens": ["def", "send_file", "(", "self", ",", "local_path", ",", "remote_path", ",", "user", "=", "'root'", ",", "unix_mode", "=", "None", ")", ":", "self", ".", "enable_user", "(", "user", ")", "return", "self", ".", "ssh_pool", ".", "send_file", "(", "user", ",", "local_path", ",", "remote_path", ",", "unix_mode", "=", "unix_mode", ")"], "idx": 2924}
{"url": "cosqa-train-13354", "docstring_tokens": ["Aggregation", "function", "to", "get", "the", "first", "non", "-", "zero", "value", "."], "code": "def reduce_fn(x):\n    \"\"\"\n    Aggregation function to get the first non-zero value.\n    \"\"\"\n    values = x.values if pd and isinstance(x, pd.Series) else x\n    for v in values:\n        if not is_nan(v):\n            return v\n    return np.NaN", "code_tokens": ["def", "reduce_fn", "(", "x", ")", ":", "values", "=", "x", ".", "values", "if", "pd", "and", "isinstance", "(", "x", ",", "pd", ".", "Series", ")", "else", "x", "for", "v", "in", "values", ":", "if", "not", "is_nan", "(", "v", ")", ":", "return", "v", "return", "np", ".", "NaN"], "idx": 621}
{"url": "cosqa-train-6848", "docstring_tokens": ["Get", "resource", "variable", "."], "code": "def _get_var_from_string(item):\n    \"\"\" Get resource variable. \"\"\"\n    modname, varname = _split_mod_var_names(item)\n    if modname:\n        mod = __import__(modname, globals(), locals(), [varname], -1)\n        return getattr(mod, varname)\n    else:\n        return globals()[varname]", "code_tokens": ["def", "_get_var_from_string", "(", "item", ")", ":", "modname", ",", "varname", "=", "_split_mod_var_names", "(", "item", ")", "if", "modname", ":", "mod", "=", "__import__", "(", "modname", ",", "globals", "(", ")", ",", "locals", "(", ")", ",", "[", "varname", "]", ",", "-", "1", ")", "return", "getattr", "(", "mod", ",", "varname", ")", "else", ":", "return", "globals", "(", ")", "[", "varname", "]"], "idx": 3596}
{"url": "cosqa-train-15681", "docstring_tokens": ["Set", "the", "terminal", "window", "size", "of", "the", "child", "tty", "."], "code": "def setwinsize(self, rows, cols):\n        \"\"\"Set the terminal window size of the child tty.\n        \"\"\"\n        self._winsize = (rows, cols)\n        self.pty.set_size(cols, rows)", "code_tokens": ["def", "setwinsize", "(", "self", ",", "rows", ",", "cols", ")", ":", "self", ".", "_winsize", "=", "(", "rows", ",", "cols", ")", "self", ".", "pty", ".", "set_size", "(", "cols", ",", "rows", ")"], "idx": 2629}
{"url": "cosqa-train-7234", "docstring_tokens": ["Convert", "a", "dict", "of", "1d", "array", "to", "a", "numpy", "recarray"], "code": "def dict_to_numpy_array(d):\n    \"\"\"\n    Convert a dict of 1d array to a numpy recarray\n    \"\"\"\n    return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))", "code_tokens": ["def", "dict_to_numpy_array", "(", "d", ")", ":", "return", "fromarrays", "(", "d", ".", "values", "(", ")", ",", "np", ".", "dtype", "(", "[", "(", "str", "(", "k", ")", ",", "v", ".", "dtype", ")", "for", "k", ",", "v", "in", "d", ".", "items", "(", ")", "]", ")", ")"], "idx": 1583}
{"url": "cosqa-train-10130", "docstring_tokens": ["Determine", "if", "two", "revisions", "have", "actually", "changed", "."], "code": "def default_diff(latest_config, current_config):\n    \"\"\"Determine if two revisions have actually changed.\"\"\"\n    # Pop off the fields we don't care about:\n    pop_no_diff_fields(latest_config, current_config)\n\n    diff = DeepDiff(\n        latest_config,\n        current_config,\n        ignore_order=True\n    )\n    return diff", "code_tokens": ["def", "default_diff", "(", "latest_config", ",", "current_config", ")", ":", "#", "Pop", "off", "the", "fields", "we", "don't", "care", "about:", "pop_no_diff_fields", "(", "latest_config", ",", "current_config", ")", "diff", "=", "DeepDiff", "(", "latest_config", ",", "current_config", ",", "ignore_order", "=", "True", ")", "return", "diff"], "idx": 4047}
{"url": "cosqa-train-12663", "docstring_tokens": ["Get", "terminal", "width"], "code": "def get_width():\n    \"\"\"Get terminal width\"\"\"\n    # Get terminal size\n    ws = struct.pack(\"HHHH\", 0, 0, 0, 0)\n    ws = fcntl.ioctl(sys.stdout.fileno(), termios.TIOCGWINSZ, ws)\n    lines, columns, x, y = struct.unpack(\"HHHH\", ws)\n    width = min(columns * 39 // 40, columns - 2)\n    return width", "code_tokens": ["def", "get_width", "(", ")", ":", "#", "Get", "terminal", "size", "ws", "=", "struct", ".", "pack", "(", "\"HHHH\"", ",", "0", ",", "0", ",", "0", ",", "0", ")", "ws", "=", "fcntl", ".", "ioctl", "(", "sys", ".", "stdout", ".", "fileno", "(", ")", ",", "termios", ".", "TIOCGWINSZ", ",", "ws", ")", "lines", ",", "columns", ",", "x", ",", "y", "=", "struct", ".", "unpack", "(", "\"HHHH\"", ",", "ws", ")", "width", "=", "min", "(", "columns", "*", "39", "//", "40", ",", "columns", "-", "2", ")", "return", "width"], "idx": 1907}
{"url": "cosqa-train-17053", "docstring_tokens": ["Get", "a", "list", "of", "the", "top", "topn", "features", "in", "this", ":", "class", ":", ".", "Feature", "\\", "."], "code": "def top(self, topn=10):\n        \"\"\"\n        Get a list of the top ``topn`` features in this :class:`.Feature`\\.\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n        >>> myFeature = Feature([('the', 2), ('pine', 1), ('trapezoid', 5)])\n        >>> myFeature.top(1)\n        [('trapezoid', 5)]\n\n        Parameters\n        ----------\n        topn : int\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self[i] for i in argsort(list(zip(*self))[1])[::-1][:topn]]", "code_tokens": ["def", "top", "(", "self", ",", "topn", "=", "10", ")", ":", "return", "[", "self", "[", "i", "]", "for", "i", "in", "argsort", "(", "list", "(", "zip", "(", "*", "self", ")", ")", "[", "1", "]", ")", "[", ":", ":", "-", "1", "]", "[", ":", "topn", "]", "]"], "idx": 5556}
{"url": "cosqa-train-16531", "docstring_tokens": ["Calculate", "the", "MD5", "hash", "for", "a", "file", "."], "code": "def get_file_md5sum(path):\n    \"\"\"Calculate the MD5 hash for a file.\"\"\"\n    with open(path, 'rb') as fh:\n        h = str(hashlib.md5(fh.read()).hexdigest())\n    return h", "code_tokens": ["def", "get_file_md5sum", "(", "path", ")", ":", "with", "open", "(", "path", ",", "'rb'", ")", "as", "fh", ":", "h", "=", "str", "(", "hashlib", ".", "md5", "(", "fh", ".", "read", "(", ")", ")", ".", "hexdigest", "(", ")", ")", "return", "h"], "idx": 1881}
{"url": "cosqa-train-2363", "docstring_tokens": ["Create", "directory", "with", "template", "for", "topic", "of", "the", "current", "environment"], "code": "def mkdir(dir, enter):\n    \"\"\"Create directory with template for topic of the current environment\n\n    \"\"\"\n\n    if not os.path.exists(dir):\n        os.makedirs(dir)", "code_tokens": ["def", "mkdir", "(", "dir", ",", "enter", ")", ":", "if", "not", "os", ".", "path", ".", "exists", "(", "dir", ")", ":", "os", ".", "makedirs", "(", "dir", ")"], "idx": 54}
{"url": "cosqa-train-17907", "docstring_tokens": ["tool", "to", "ensure", "input", "and", "output", "data", "have", "the", "same", "number", "of", "samples"], "code": "def check_lengths(*arrays):\n    \"\"\"\n    tool to ensure input and output data have the same number of samples\n\n    Parameters\n    ----------\n    *arrays : iterable of arrays to be checked\n\n    Returns\n    -------\n    None\n    \"\"\"\n    lengths = [len(array) for array in arrays]\n    if len(np.unique(lengths)) > 1:\n        raise ValueError('Inconsistent data lengths: {}'.format(lengths))", "code_tokens": ["def", "check_lengths", "(", "*", "arrays", ")", ":", "lengths", "=", "[", "len", "(", "array", ")", "for", "array", "in", "arrays", "]", "if", "len", "(", "np", ".", "unique", "(", "lengths", ")", ")", ">", "1", ":", "raise", "ValueError", "(", "'Inconsistent", "data", "lengths:", "{}'", ".", "format", "(", "lengths", ")", ")"], "idx": 5934}
{"url": "cosqa-train-15552", "docstring_tokens": ["Yield", "num_chars", "-", "character", "chunks", "from", "string", "."], "code": "def generate_chunks(string, num_chars):\n    \"\"\"Yield num_chars-character chunks from string.\"\"\"\n    for start in range(0, len(string), num_chars):\n        yield string[start:start+num_chars]", "code_tokens": ["def", "generate_chunks", "(", "string", ",", "num_chars", ")", ":", "for", "start", "in", "range", "(", "0", ",", "len", "(", "string", ")", ",", "num_chars", ")", ":", "yield", "string", "[", "start", ":", "start", "+", "num_chars", "]"], "idx": 5338}
{"url": "cosqa-train-15711", "docstring_tokens": ["Validates", "the", "returned", "positional", "object"], "code": "def _validate_pos(df):\n    \"\"\"Validates the returned positional object\n    \"\"\"\n    assert isinstance(df, pd.DataFrame)\n    assert [\"seqname\", \"position\", \"strand\"] == df.columns.tolist()\n    assert df.position.dtype == np.dtype(\"int64\")\n    assert df.strand.dtype == np.dtype(\"O\")\n    assert df.seqname.dtype == np.dtype(\"O\")\n    return df", "code_tokens": ["def", "_validate_pos", "(", "df", ")", ":", "assert", "isinstance", "(", "df", ",", "pd", ".", "DataFrame", ")", "assert", "[", "\"seqname\"", ",", "\"position\"", ",", "\"strand\"", "]", "==", "df", ".", "columns", ".", "tolist", "(", ")", "assert", "df", ".", "position", ".", "dtype", "==", "np", ".", "dtype", "(", "\"int64\"", ")", "assert", "df", ".", "strand", ".", "dtype", "==", "np", ".", "dtype", "(", "\"O\"", ")", "assert", "df", ".", "seqname", ".", "dtype", "==", "np", ".", "dtype", "(", "\"O\"", ")", "return", "df"], "idx": 740}
{"url": "cosqa-train-6730", "docstring_tokens": ["Return", "first", "occurrence", "matching", "f", "otherwise", "None"], "code": "def findfirst(f, coll):\n    \"\"\"Return first occurrence matching f, otherwise None\"\"\"\n    result = list(dropwhile(f, coll))\n    return result[0] if result else None", "code_tokens": ["def", "findfirst", "(", "f", ",", "coll", ")", ":", "result", "=", "list", "(", "dropwhile", "(", "f", ",", "coll", ")", ")", "return", "result", "[", "0", "]", "if", "result", "else", "None"], "idx": 598}
{"url": "cosqa-train-4464", "docstring_tokens": ["Extracts", "all", "integers", "from", "a", "string", "an", "return", "them", "in", "a", "list"], "code": "def get_numbers(s):\n    \"\"\"Extracts all integers from a string an return them in a list\"\"\"\n\n    result = map(int, re.findall(r'[0-9]+', unicode(s)))\n    return result + [1] * (2 - len(result))", "code_tokens": ["def", "get_numbers", "(", "s", ")", ":", "result", "=", "map", "(", "int", ",", "re", ".", "findall", "(", "r'[0-9]+'", ",", "unicode", "(", "s", ")", ")", ")", "return", "result", "+", "[", "1", "]", "*", "(", "2", "-", "len", "(", "result", ")", ")"], "idx": 2828}
{"url": "cosqa-train-7906", "docstring_tokens": ["Raises", "an", "AssertionError", "if", "expected", "is", "actual", "."], "code": "def assert_is_not(expected, actual, message=None, extra=None):\n    \"\"\"Raises an AssertionError if expected is actual.\"\"\"\n    assert expected is not actual, _assert_fail_message(\n        message, expected, actual, \"is\", extra\n    )", "code_tokens": ["def", "assert_is_not", "(", "expected", ",", "actual", ",", "message", "=", "None", ",", "extra", "=", "None", ")", ":", "assert", "expected", "is", "not", "actual", ",", "_assert_fail_message", "(", "message", ",", "expected", ",", "actual", ",", "\"is\"", ",", "extra", ")"], "idx": 1307}
{"url": "cosqa-train-16444", "docstring_tokens": ["Starts", "connection", "to", "server", "if", "not", "existent", "."], "code": "def start(self, test_connection=True):\n        \"\"\"Starts connection to server if not existent.\n\n        NO-OP if connection is already established.\n        Makes ping-pong test as well if desired.\n\n        \"\"\"\n        if self._context is None:\n            self._logger.debug('Starting Client')\n            self._context = zmq.Context()\n            self._poll = zmq.Poller()\n            self._start_socket()\n            if test_connection:\n                self.test_ping()", "code_tokens": ["def", "start", "(", "self", ",", "test_connection", "=", "True", ")", ":", "if", "self", ".", "_context", "is", "None", ":", "self", ".", "_logger", ".", "debug", "(", "'Starting", "Client'", ")", "self", ".", "_context", "=", "zmq", ".", "Context", "(", ")", "self", ".", "_poll", "=", "zmq", ".", "Poller", "(", ")", "self", ".", "_start_socket", "(", ")", "if", "test_connection", ":", "self", ".", "test_ping", "(", ")"], "idx": 5466}
{"url": "cosqa-train-17529", "docstring_tokens": ["Creates", "a", "datetime", "from", "GnuCash", "2", ".", "6", "date", "string"], "code": "def get_from_gnucash26_date(date_str: str) -> date:\n    \"\"\" Creates a datetime from GnuCash 2.6 date string \"\"\"\n    date_format = \"%Y%m%d\"\n    result = datetime.strptime(date_str, date_format).date()\n    return result", "code_tokens": ["def", "get_from_gnucash26_date", "(", "date_str", ":", "str", ")", "->", "date", ":", "date_format", "=", "\"%Y%m%d\"", "result", "=", "datetime", ".", "strptime", "(", "date_str", ",", "date_format", ")", ".", "date", "(", ")", "return", "result"], "idx": 5766}
{"url": "cosqa-train-19388", "docstring_tokens": ["takes", "a", "list", "of", "lists", "l", "and", "returns", "a", "flat", "list"], "code": "def flatten_list(l: List[list]) -> list:\n    \"\"\" takes a list of lists, l and returns a flat list\n    \"\"\"\n    return [v for inner_l in l for v in inner_l]", "code_tokens": ["def", "flatten_list", "(", "l", ":", "List", "[", "list", "]", ")", "->", "list", ":", "return", "[", "v", "for", "inner_l", "in", "l", "for", "v", "in", "inner_l", "]"], "idx": 5705}
{"url": "cosqa-train-8434", "docstring_tokens": ["Create", "unique", "labels", "."], "code": "def get_labels(labels):\n    \"\"\"Create unique labels.\"\"\"\n    label_u = unique_labels(labels)\n    label_u_line = [i + \"_line\" for i in label_u]\n    return label_u, label_u_line", "code_tokens": ["def", "get_labels", "(", "labels", ")", ":", "label_u", "=", "unique_labels", "(", "labels", ")", "label_u_line", "=", "[", "i", "+", "\"_line\"", "for", "i", "in", "label_u", "]", "return", "label_u", ",", "label_u_line"], "idx": 4033}
{"url": "cosqa-train-13389", "docstring_tokens": ["Set", "limits", "for", "the", "point", "meta", "(", "colormap", ")", "."], "code": "def set_mlimits(self, row, column, min=None, max=None):\n        \"\"\"Set limits for the point meta (colormap).\n\n        Point meta values outside this range will be clipped.\n\n        :param min: value for start of the colormap.\n        :param max: value for end of the colormap.\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.set_mlimits(min, max)", "code_tokens": ["def", "set_mlimits", "(", "self", ",", "row", ",", "column", ",", "min", "=", "None", ",", "max", "=", "None", ")", ":", "subplot", "=", "self", ".", "get_subplot_at", "(", "row", ",", "column", ")", "subplot", ".", "set_mlimits", "(", "min", ",", "max", ")"], "idx": 4994}
{"url": "cosqa-train-19863", "docstring_tokens": ["r", "Like", "rotate", "but", "modifies", "l", "in", "-", "place", "."], "code": "def iprotate(l, steps=1):\n    r\"\"\"Like rotate, but modifies `l` in-place.\n\n    >>> l = [1,2,3]\n    >>> iprotate(l) is l\n    True\n    >>> l\n    [2, 3, 1]\n    >>> iprotate(iprotate(l, 2), -3)\n    [1, 2, 3]\n\n    \"\"\"\n    if len(l):\n        steps %= len(l)\n        if steps:\n            firstPart = l[:steps]\n            del l[:steps]\n            l.extend(firstPart)\n    return l", "code_tokens": ["def", "iprotate", "(", "l", ",", "steps", "=", "1", ")", ":", "if", "len", "(", "l", ")", ":", "steps", "%=", "len", "(", "l", ")", "if", "steps", ":", "firstPart", "=", "l", "[", ":", "steps", "]", "del", "l", "[", ":", "steps", "]", "l", ".", "extend", "(", "firstPart", ")", "return", "l"], "idx": 5735}
{"url": "cosqa-train-15897", "docstring_tokens": ["Removes", "object", "obj", "from", "the", "index", "."], "code": "def _remove_from_index(index, obj):\n    \"\"\"Removes object ``obj`` from the ``index``.\"\"\"\n    try:\n        index.value_map[indexed_value(index, obj)].remove(obj.id)\n    except KeyError:\n        pass", "code_tokens": ["def", "_remove_from_index", "(", "index", ",", "obj", ")", ":", "try", ":", "index", ".", "value_map", "[", "indexed_value", "(", "index", ",", "obj", ")", "]", ".", "remove", "(", "obj", ".", "id", ")", "except", "KeyError", ":", "pass"], "idx": 2482}
{"url": "cosqa-train-5961", "docstring_tokens": ["Generate", "a", "list", "of", "words", "given", "text", "removing", "punctuation", "."], "code": "def wordify(text):\n    \"\"\"Generate a list of words given text, removing punctuation.\n\n    Parameters\n    ----------\n    text : unicode\n        A piece of english text.\n\n    Returns\n    -------\n    words : list\n        List of words.\n    \"\"\"\n    stopset = set(nltk.corpus.stopwords.words('english'))\n    tokens = nltk.WordPunctTokenizer().tokenize(text)\n    return [w for w in tokens if w not in stopset]", "code_tokens": ["def", "wordify", "(", "text", ")", ":", "stopset", "=", "set", "(", "nltk", ".", "corpus", ".", "stopwords", ".", "words", "(", "'english'", ")", ")", "tokens", "=", "nltk", ".", "WordPunctTokenizer", "(", ")", ".", "tokenize", "(", "text", ")", "return", "[", "w", "for", "w", "in", "tokens", "if", "w", "not", "in", "stopset", "]"], "idx": 844}
{"url": "cosqa-train-6180", "docstring_tokens": ["Strip", "whitespace", "from", "string", "columns", "."], "code": "def strip_columns(tab):\n    \"\"\"Strip whitespace from string columns.\"\"\"\n    for colname in tab.colnames:\n        if tab[colname].dtype.kind in ['S', 'U']:\n            tab[colname] = np.core.defchararray.strip(tab[colname])", "code_tokens": ["def", "strip_columns", "(", "tab", ")", ":", "for", "colname", "in", "tab", ".", "colnames", ":", "if", "tab", "[", "colname", "]", ".", "dtype", ".", "kind", "in", "[", "'S'", ",", "'U'", "]", ":", "tab", "[", "colname", "]", "=", "np", ".", "core", ".", "defchararray", ".", "strip", "(", "tab", "[", "colname", "]", ")"], "idx": 1437}
{"url": "cosqa-train-17060", "docstring_tokens": ["Returns", "day", "number", "of", "the", "last", "day", "of", "the", "month", ":", "param", "t", ":", "datetime", ":", "return", ":", "int"], "code": "def get_last_day_of_month(t: datetime) -> int:\n    \"\"\"\n    Returns day number of the last day of the month\n    :param t: datetime\n    :return: int\n    \"\"\"\n    tn = t + timedelta(days=32)\n    tn = datetime(year=tn.year, month=tn.month, day=1)\n    tt = tn - timedelta(hours=1)\n    return tt.day", "code_tokens": ["def", "get_last_day_of_month", "(", "t", ":", "datetime", ")", "->", "int", ":", "tn", "=", "t", "+", "timedelta", "(", "days", "=", "32", ")", "tn", "=", "datetime", "(", "year", "=", "tn", ".", "year", ",", "month", "=", "tn", ".", "month", ",", "day", "=", "1", ")", "tt", "=", "tn", "-", "timedelta", "(", "hours", "=", "1", ")", "return", "tt", ".", "day"], "idx": 5645}
{"url": "cosqa-train-8210", "docstring_tokens": ["Raises", "an", "AssertionError", "if", "expected", "is", "actual", "."], "code": "def assert_is_not(expected, actual, message=None, extra=None):\n    \"\"\"Raises an AssertionError if expected is actual.\"\"\"\n    assert expected is not actual, _assert_fail_message(\n        message, expected, actual, \"is\", extra\n    )", "code_tokens": ["def", "assert_is_not", "(", "expected", ",", "actual", ",", "message", "=", "None", ",", "extra", "=", "None", ")", ":", "assert", "expected", "is", "not", "actual", ",", "_assert_fail_message", "(", "message", ",", "expected", ",", "actual", ",", "\"is\"", ",", "extra", ")"], "idx": 1307}
{"url": "cosqa-train-13784", "docstring_tokens": ["Compute", "the", "angle", "between", "vector", "x", "and", "y"], "code": "def angle_between_vectors(x, y):\n    \"\"\" Compute the angle between vector x and y \"\"\"\n    dp = dot_product(x, y)\n    if dp == 0:\n        return 0\n    xm = magnitude(x)\n    ym = magnitude(y)\n    return math.acos(dp / (xm*ym)) * (180. / math.pi)", "code_tokens": ["def", "angle_between_vectors", "(", "x", ",", "y", ")", ":", "dp", "=", "dot_product", "(", "x", ",", "y", ")", "if", "dp", "==", "0", ":", "return", "0", "xm", "=", "magnitude", "(", "x", ")", "ym", "=", "magnitude", "(", "y", ")", "return", "math", ".", "acos", "(", "dp", "/", "(", "xm", "*", "ym", ")", ")", "*", "(", "180.", "/", "math", ".", "pi", ")"], "idx": 1665}
{"url": "cosqa-train-7686", "docstring_tokens": ["Yield", "a", "series", "of", "batches", "from", "iterable", "each", "size", "elements", "long", "."], "code": "def ibatch(iterable, size):\n    \"\"\"Yield a series of batches from iterable, each size elements long.\"\"\"\n    source = iter(iterable)\n    while True:\n        batch = itertools.islice(source, size)\n        yield itertools.chain([next(batch)], batch)", "code_tokens": ["def", "ibatch", "(", "iterable", ",", "size", ")", ":", "source", "=", "iter", "(", "iterable", ")", "while", "True", ":", "batch", "=", "itertools", ".", "islice", "(", "source", ",", "size", ")", "yield", "itertools", ".", "chain", "(", "[", "next", "(", "batch", ")", "]", ",", "batch", ")"], "idx": 2638}
{"url": "cosqa-train-2587", "docstring_tokens": ["disassemble", "Python", "byte", "-", "code", "file", "(", ".", "pyc", ")"], "code": "def disassemble_file(filename, outstream=None):\n    \"\"\"\n    disassemble Python byte-code file (.pyc)\n\n    If given a Python source file (\".py\") file, we'll\n    try to find the corresponding compiled object.\n    \"\"\"\n    filename = check_object_path(filename)\n    (version, timestamp, magic_int, co, is_pypy,\n     source_size) = load_module(filename)\n    if type(co) == list:\n        for con in co:\n            disco(version, con, outstream)\n    else:\n        disco(version, co, outstream, is_pypy=is_pypy)\n    co = None", "code_tokens": ["def", "disassemble_file", "(", "filename", ",", "outstream", "=", "None", ")", ":", "filename", "=", "check_object_path", "(", "filename", ")", "(", "version", ",", "timestamp", ",", "magic_int", ",", "co", ",", "is_pypy", ",", "source_size", ")", "=", "load_module", "(", "filename", ")", "if", "type", "(", "co", ")", "==", "list", ":", "for", "con", "in", "co", ":", "disco", "(", "version", ",", "con", ",", "outstream", ")", "else", ":", "disco", "(", "version", ",", "co", ",", "outstream", ",", "is_pypy", "=", "is_pypy", ")", "co", "=", "None"], "idx": 1951}
{"url": "cosqa-train-6620", "docstring_tokens": ["Closes", "and", "waits", "for", "subprocess", "to", "exit", "."], "code": "def _finish(self):\n        \"\"\"\n        Closes and waits for subprocess to exit.\n        \"\"\"\n        if self._process.returncode is None:\n            self._process.stdin.flush()\n            self._process.stdin.close()\n            self._process.wait()\n            self.closed = True", "code_tokens": ["def", "_finish", "(", "self", ")", ":", "if", "self", ".", "_process", ".", "returncode", "is", "None", ":", "self", ".", "_process", ".", "stdin", ".", "flush", "(", ")", "self", ".", "_process", ".", "stdin", ".", "close", "(", ")", "self", ".", "_process", ".", "wait", "(", ")", "self", ".", "closed", "=", "True"], "idx": 3531}
{"url": "cosqa-train-3852", "docstring_tokens": ["Returns", "a", "copy", "of", "dct", "without", "keys", "keys"], "code": "def _delete_keys(dct, keys):\n    \"\"\"Returns a copy of dct without `keys` keys\n    \"\"\"\n    c = deepcopy(dct)\n    assert isinstance(keys, list)\n    for k in keys:\n        c.pop(k)\n    return c", "code_tokens": ["def", "_delete_keys", "(", "dct", ",", "keys", ")", ":", "c", "=", "deepcopy", "(", "dct", ")", "assert", "isinstance", "(", "keys", ",", "list", ")", "for", "k", "in", "keys", ":", "c", ".", "pop", "(", "k", ")", "return", "c"], "idx": 2569}
{"url": "cosqa-train-4324", "docstring_tokens": [""], "code": "def process_instance(self, instance):\n        self.log.debug(\"e = mc^2\")\n        self.log.info(\"About to fail..\")\n        self.log.warning(\"Failing.. soooon..\")\n        self.log.critical(\"Ok, you're done.\")\n        assert False, \"\"\"ValidateFailureMock was destined to fail..\n\nHere's some extended information about what went wrong.\n\nIt has quite the long string associated with it, including\na few newlines and a list.\n\n- Item 1\n- Item 2\n\n\"\"\"", "code_tokens": ["def", "process_instance", "(", "self", ",", "instance", ")", ":", "self", ".", "log", ".", "debug", "(", "\"e", "=", "mc^2\"", ")", "self", ".", "log", ".", "info", "(", "\"About", "to", "fail..\"", ")", "self", ".", "log", ".", "warning", "(", "\"Failing..", "soooon..\"", ")", "self", ".", "log", ".", "critical", "(", "\"Ok,", "you're", "done.\"", ")", "assert", "False", ",", "\"\"\"ValidateFailureMock", "was", "destined", "to", "fail..\n\nHere's", "some", "extended", "information", "about", "what", "went", "wrong.\n\nIt", "has", "quite", "the", "long", "string", "associated", "with", "it,", "including\na", "few", "newlines", "and", "a", "list.\n\n-", "Item", "1\n-", "Item", "2\n\n\"\"\""], "idx": 2102}
{"url": "cosqa-train-17009", "docstring_tokens": ["Remove", "empty", "utterances", "from", "a", "list", "of", "utterances", "Args", ":", "utterances", ":", "The", "list", "of", "utterance", "we", "are", "processing"], "code": "def remove_empty_text(utterances: List[Utterance]) -> List[Utterance]:\n    \"\"\"Remove empty utterances from a list of utterances\n    Args:\n        utterances: The list of utterance we are processing\n    \"\"\"\n    return [utter for utter in utterances if utter.text.strip() != \"\"]", "code_tokens": ["def", "remove_empty_text", "(", "utterances", ":", "List", "[", "Utterance", "]", ")", "->", "List", "[", "Utterance", "]", ":", "return", "[", "utter", "for", "utter", "in", "utterances", "if", "utter", ".", "text", ".", "strip", "(", ")", "!=", "\"\"", "]"], "idx": 5557}
{"url": "cosqa-train-9177", "docstring_tokens": ["Apply", "re", ".", "sub", "to", "bunch", "of", "(", "pattern", "repl", ")"], "code": "def _sub_patterns(patterns, text):\n    \"\"\"\n    Apply re.sub to bunch of (pattern, repl)\n    \"\"\"\n    for pattern, repl in patterns:\n        text = re.sub(pattern, repl, text)\n    return text", "code_tokens": ["def", "_sub_patterns", "(", "patterns", ",", "text", ")", ":", "for", "pattern", ",", "repl", "in", "patterns", ":", "text", "=", "re", ".", "sub", "(", "pattern", ",", "repl", ",", "text", ")", "return", "text"], "idx": 773}
{"url": "cosqa-train-11440", "docstring_tokens": ["validate", "that", "we", "can", "store", "the", "multi", "-", "index", ";", "reset", "and", "return", "the", "new", "object"], "code": "def validate_multiindex(self, obj):\n        \"\"\"validate that we can store the multi-index; reset and return the\n        new object\n        \"\"\"\n        levels = [l if l is not None else \"level_{0}\".format(i)\n                  for i, l in enumerate(obj.index.names)]\n        try:\n            return obj.reset_index(), levels\n        except ValueError:\n            raise ValueError(\"duplicate names/columns in the multi-index when \"\n                             \"storing as a table\")", "code_tokens": ["def", "validate_multiindex", "(", "self", ",", "obj", ")", ":", "levels", "=", "[", "l", "if", "l", "is", "not", "None", "else", "\"level_{0}\"", ".", "format", "(", "i", ")", "for", "i", ",", "l", "in", "enumerate", "(", "obj", ".", "index", ".", "names", ")", "]", "try", ":", "return", "obj", ".", "reset_index", "(", ")", ",", "levels", "except", "ValueError", ":", "raise", "ValueError", "(", "\"duplicate", "names/columns", "in", "the", "multi-index", "when", "\"", "\"storing", "as", "a", "table\"", ")"], "idx": 998}
{"url": "cosqa-train-9977", "docstring_tokens": ["Return", "the", "union", "of", "two", "RangeSets", "as", "a", "new", "RangeSet", "."], "code": "def __or__(self, other):\n        \"\"\"Return the union of two RangeSets as a new RangeSet.\n\n        (I.e. all elements that are in either set.)\n        \"\"\"\n        if not isinstance(other, set):\n            return NotImplemented\n        return self.union(other)", "code_tokens": ["def", "__or__", "(", "self", ",", "other", ")", ":", "if", "not", "isinstance", "(", "other", ",", "set", ")", ":", "return", "NotImplemented", "return", "self", ".", "union", "(", "other", ")"], "idx": 3372}
{"url": "cosqa-train-15226", "docstring_tokens": ["Get", "the", "python", "representation", "of", "the", "obj"], "code": "def _decode(self, obj, context):\n        \"\"\"\n        Get the python representation of the obj\n        \"\"\"\n        return b''.join(map(int2byte, [c + 0x60 for c in bytearray(obj)])).decode(\"utf8\")", "code_tokens": ["def", "_decode", "(", "self", ",", "obj", ",", "context", ")", ":", "return", "b''", ".", "join", "(", "map", "(", "int2byte", ",", "[", "c", "+", "0x60", "for", "c", "in", "bytearray", "(", "obj", ")", "]", ")", ")", ".", "decode", "(", "\"utf8\"", ")"], "idx": 4067}
{"url": "cosqa-train-14266", "docstring_tokens": ["round", "to", "closest", "resolution"], "code": "def roundClosestValid(val, res, decimals=None):\n        \"\"\" round to closest resolution \"\"\"\n        if decimals is None and \".\" in str(res):\n            decimals = len(str(res).split('.')[1])\n\n        return round(round(val / res) * res, decimals)", "code_tokens": ["def", "roundClosestValid", "(", "val", ",", "res", ",", "decimals", "=", "None", ")", ":", "if", "decimals", "is", "None", "and", "\".\"", "in", "str", "(", "res", ")", ":", "decimals", "=", "len", "(", "str", "(", "res", ")", ".", "split", "(", "'.'", ")", "[", "1", "]", ")", "return", "round", "(", "round", "(", "val", "/", "res", ")", "*", "res", ",", "decimals", ")"], "idx": 3832}
{"url": "cosqa-train-17640", "docstring_tokens": ["Remove", "the", "element", "from", "a", "set", "lists", "or", "dict", ".", ">>>", "L", "=", "[", "Lucy", "]", ";", "S", "=", "set", "(", "[", "Sky", "]", ")", ";", "D", "=", "{", "Diamonds", ":", "True", "}", ";", ">>>", "remove_once", "(", "L", "Lucy", ")", ";", "remove_once", "(", "S", "Sky", ")", ";", "remove_once", "(", "D", "Diamonds", ")", ";", ">>>", "print", "L", "S", "D", "[]", "set", "(", "[]", ")", "{}"], "code": "def remove_once(gset, elem):\n    \"\"\"Remove the element from a set, lists or dict.\n    \n        >>> L = [\"Lucy\"]; S = set([\"Sky\"]); D = { \"Diamonds\": True };\n        >>> remove_once(L, \"Lucy\"); remove_once(S, \"Sky\"); remove_once(D, \"Diamonds\");\n        >>> print L, S, D\n        [] set([]) {}\n\n    Returns the element if it was removed. Raises one of the exceptions in \n    :obj:`RemoveError` otherwise.\n    \"\"\"\n    remove = getattr(gset, 'remove', None)\n    if remove is not None: remove(elem)\n    else: del gset[elem]\n    return elem", "code_tokens": ["def", "remove_once", "(", "gset", ",", "elem", ")", ":", "remove", "=", "getattr", "(", "gset", ",", "'remove'", ",", "None", ")", "if", "remove", "is", "not", "None", ":", "remove", "(", "elem", ")", "else", ":", "del", "gset", "[", "elem", "]", "return", "elem"], "idx": 5741}
{"url": "cosqa-train-12232", "docstring_tokens": ["Generate", "unique", "document", "id", "for", "ElasticSearch", "."], "code": "def generate_id(self, obj):\n        \"\"\"Generate unique document id for ElasticSearch.\"\"\"\n        object_type = type(obj).__name__.lower()\n        return '{}_{}'.format(object_type, self.get_object_id(obj))", "code_tokens": ["def", "generate_id", "(", "self", ",", "obj", ")", ":", "object_type", "=", "type", "(", "obj", ")", ".", "__name__", ".", "lower", "(", ")", "return", "'{}_{}'", ".", "format", "(", "object_type", ",", "self", ".", "get_object_id", "(", "obj", ")", ")"], "idx": 4302}
{"url": "cosqa-train-18797", "docstring_tokens": ["Return", "a", "new", "copied", "dictionary", "without", "the", "keys", "with", "None", "values", "from", "the", "given", "Mapping", "object", "."], "code": "def clean_map(obj: Mapping[Any, Any]) -> Mapping[Any, Any]:\n    \"\"\"\n    Return a new copied dictionary without the keys with ``None`` values from\n    the given Mapping object.\n    \"\"\"\n    return {k: v for k, v in obj.items() if v is not None}", "code_tokens": ["def", "clean_map", "(", "obj", ":", "Mapping", "[", "Any", ",", "Any", "]", ")", "->", "Mapping", "[", "Any", ",", "Any", "]", ":", "return", "{", "k", ":", "v", "for", "k", ",", "v", "in", "obj", ".", "items", "(", ")", "if", "v", "is", "not", "None", "}"], "idx": 5748}
{"url": "cosqa-train-6195", "docstring_tokens": ["Whether", "path", "is", "a", "directory", "to", "which", "the", "user", "has", "write", "access", "."], "code": "def _writable_dir(path):\n    \"\"\"Whether `path` is a directory, to which the user has write access.\"\"\"\n    return os.path.isdir(path) and os.access(path, os.W_OK)", "code_tokens": ["def", "_writable_dir", "(", "path", ")", ":", "return", "os", ".", "path", ".", "isdir", "(", "path", ")", "and", "os", ".", "access", "(", "path", ",", "os", ".", "W_OK", ")"], "idx": 651}
{"url": "cosqa-train-15054", "docstring_tokens": ["When", "converting", "Spark", "SQL", "records", "to", "Pandas", "DataFrame", "the", "inferred", "data", "type", "may", "be", "wrong", ".", "This", "method", "gets", "the", "corrected", "data", "type", "for", "Pandas", "if", "that", "type", "may", "be", "inferred", "uncorrectly", "."], "code": "def _to_corrected_pandas_type(dt):\n    \"\"\"\n    When converting Spark SQL records to Pandas DataFrame, the inferred data type may be wrong.\n    This method gets the corrected data type for Pandas if that type may be inferred uncorrectly.\n    \"\"\"\n    import numpy as np\n    if type(dt) == ByteType:\n        return np.int8\n    elif type(dt) == ShortType:\n        return np.int16\n    elif type(dt) == IntegerType:\n        return np.int32\n    elif type(dt) == FloatType:\n        return np.float32\n    else:\n        return None", "code_tokens": ["def", "_to_corrected_pandas_type", "(", "dt", ")", ":", "import", "numpy", "as", "np", "if", "type", "(", "dt", ")", "==", "ByteType", ":", "return", "np", ".", "int8", "elif", "type", "(", "dt", ")", "==", "ShortType", ":", "return", "np", ".", "int16", "elif", "type", "(", "dt", ")", "==", "IntegerType", ":", "return", "np", ".", "int32", "elif", "type", "(", "dt", ")", "==", "FloatType", ":", "return", "np", ".", "float32", "else", ":", "return", "None"], "idx": 170}
{"url": "cosqa-train-11747", "docstring_tokens": ["Saves", "the", "dictionary", "in", "json", "format", ":", "param", "fname", ":", "file", "to", "save", "to"], "code": "def save(self, fname):\n        \"\"\" Saves the dictionary in json format\n        :param fname: file to save to\n        \"\"\"\n        with open(fname, 'wb') as f:\n            json.dump(self, f)", "code_tokens": ["def", "save", "(", "self", ",", "fname", ")", ":", "with", "open", "(", "fname", ",", "'wb'", ")", "as", "f", ":", "json", ".", "dump", "(", "self", ",", "f", ")"], "idx": 686}
{"url": "cosqa-train-14568", "docstring_tokens": ["Sets", "the", "window", "bounds", "from", "a", "tuple", "of", "(", "x", "y", "w", "h", ")"], "code": "def setRect(self, rect):\n\t\t\"\"\"\n\t\tSets the window bounds from a tuple of (x,y,w,h)\n\t\t\"\"\"\n\t\tself.x, self.y, self.w, self.h = rect", "code_tokens": ["def", "setRect", "(", "self", ",", "rect", ")", ":", "self", ".", "x", ",", "self", ".", "y", ",", "self", ".", "w", ",", "self", ".", "h", "=", "rect"], "idx": 5190}
{"url": "cosqa-train-16821", "docstring_tokens": ["Wrap", "vertical", "table", "in", "a", "function", "for", "TabularOutputFormatter", "."], "code": "def adapter(data, headers, **kwargs):\n    \"\"\"Wrap vertical table in a function for TabularOutputFormatter.\"\"\"\n    keys = ('sep_title', 'sep_character', 'sep_length')\n    return vertical_table(data, headers, **filter_dict_by_key(kwargs, keys))", "code_tokens": ["def", "adapter", "(", "data", ",", "headers", ",", "*", "*", "kwargs", ")", ":", "keys", "=", "(", "'sep_title'", ",", "'sep_character'", ",", "'sep_length'", ")", "return", "vertical_table", "(", "data", ",", "headers", ",", "*", "*", "filter_dict_by_key", "(", "kwargs", ",", "keys", ")", ")"], "idx": 2196}
{"url": "cosqa-train-16226", "docstring_tokens": ["Return", "a", "region", "from", "a", "numpy", "array", ".", ":", "param", "array", ":", ":", "class", ":", "numpy", ".", "ndarray", ":", "param", "identifier", ":", "value", "representing", "the", "region", "to", "select", "in", "the", "array", ":", "returns", ":", ":", "class", ":", "jicimagelib", ".", "region", ".", "Region"], "code": "def select_from_array(cls, array, identifier):\n        \"\"\"Return a region from a numpy array.\n        \n        :param array: :class:`numpy.ndarray`\n        :param identifier: value representing the region to select in the array\n        :returns: :class:`jicimagelib.region.Region`\n        \"\"\"\n\n        base_array = np.zeros(array.shape)\n        array_coords = np.where(array == identifier)\n        base_array[array_coords] = 1\n\n        return cls(base_array)", "code_tokens": ["def", "select_from_array", "(", "cls", ",", "array", ",", "identifier", ")", ":", "base_array", "=", "np", ".", "zeros", "(", "array", ".", "shape", ")", "array_coords", "=", "np", ".", "where", "(", "array", "==", "identifier", ")", "base_array", "[", "array_coords", "]", "=", "1", "return", "cls", "(", "base_array", ")"], "idx": 3783}
{"url": "cosqa-train-9169", "docstring_tokens": ["Idempotent", "and", "None", "-", "safe", "version", "of", "strict_bool", "."], "code": "def less_strict_bool(x):\n    \"\"\"Idempotent and None-safe version of strict_bool.\"\"\"\n    if x is None:\n        return False\n    elif x is True or x is False:\n        return x\n    else:\n        return strict_bool(x)", "code_tokens": ["def", "less_strict_bool", "(", "x", ")", ":", "if", "x", "is", "None", ":", "return", "False", "elif", "x", "is", "True", "or", "x", "is", "False", ":", "return", "x", "else", ":", "return", "strict_bool", "(", "x", ")"], "idx": 908}
{"url": "cosqa-train-12818", "docstring_tokens": ["Check", "if", "file", "or", "directory", "is", "world", "writable", "."], "code": "def is_writable_by_others(filename):\n    \"\"\"Check if file or directory is world writable.\"\"\"\n    mode = os.stat(filename)[stat.ST_MODE]\n    return mode & stat.S_IWOTH", "code_tokens": ["def", "is_writable_by_others", "(", "filename", ")", ":", "mode", "=", "os", ".", "stat", "(", "filename", ")", "[", "stat", ".", "ST_MODE", "]", "return", "mode", "&", "stat", ".", "S_IWOTH"], "idx": 3186}
{"url": "cosqa-train-12797", "docstring_tokens": ["Ensure", "the", "widget", "is", "shown", ".", "Calling", "this", "method", "will", "also", "set", "the", "widget", "visibility", "to", "True", "."], "code": "def show(self):\n        \"\"\" Ensure the widget is shown.\n        Calling this method will also set the widget visibility to True.\n        \"\"\"\n        self.visible = True\n        if self.proxy_is_active:\n            self.proxy.ensure_visible()", "code_tokens": ["def", "show", "(", "self", ")", ":", "self", ".", "visible", "=", "True", "if", "self", ".", "proxy_is_active", ":", "self", ".", "proxy", ".", "ensure_visible", "(", ")"], "idx": 4884}
{"url": "cosqa-train-2191", "docstring_tokens": ["Takes", "two", "clicks", "and", "returns", "the", "slope", "."], "code": "def click_estimate_slope():\n    \"\"\"\n    Takes two clicks and returns the slope.\n\n    Right-click aborts.\n    \"\"\"\n\n    c1 = _pylab.ginput()\n    if len(c1)==0:\n        return None\n\n    c2 = _pylab.ginput()\n    if len(c2)==0:\n        return None\n\n    return (c1[0][1]-c2[0][1])/(c1[0][0]-c2[0][0])", "code_tokens": ["def", "click_estimate_slope", "(", ")", ":", "c1", "=", "_pylab", ".", "ginput", "(", ")", "if", "len", "(", "c1", ")", "==", "0", ":", "return", "None", "c2", "=", "_pylab", ".", "ginput", "(", ")", "if", "len", "(", "c2", ")", "==", "0", ":", "return", "None", "return", "(", "c1", "[", "0", "]", "[", "1", "]", "-", "c2", "[", "0", "]", "[", "1", "]", ")", "/", "(", "c1", "[", "0", "]", "[", "0", "]", "-", "c2", "[", "0", "]", "[", "0", "]", ")"], "idx": 1724}
{"url": "cosqa-train-7844", "docstring_tokens": ["Wrapper", "to", "uncheck", "a", "checkbox"], "code": "def checkbox_uncheck(self, force_check=False):\n        \"\"\"\n        Wrapper to uncheck a checkbox\n        \"\"\"\n        if self.get_attribute('checked'):\n            self.click(force_click=force_check)", "code_tokens": ["def", "checkbox_uncheck", "(", "self", ",", "force_check", "=", "False", ")", ":", "if", "self", ".", "get_attribute", "(", "'checked'", ")", ":", "self", ".", "click", "(", "force_click", "=", "force_check", ")"], "idx": 1582}
{"url": "cosqa-train-11288", "docstring_tokens": ["Deserializes", "a", "JSONified", ":", "obj", ":", "numpy", ".", "ndarray", "that", "was", "created", "using", "numpy", "s", ":", "obj", ":", "save", "function", "."], "code": "def deserialize_ndarray_npy(d):\n    \"\"\"\n    Deserializes a JSONified :obj:`numpy.ndarray` that was created using numpy's\n    :obj:`save` function.\n\n    Args:\n        d (:obj:`dict`): A dictionary representation of an :obj:`ndarray` object, created\n            using :obj:`numpy.save`.\n\n    Returns:\n        An :obj:`ndarray` object.\n    \"\"\"\n    with io.BytesIO() as f:\n        f.write(json.loads(d['npy']).encode('latin-1'))\n        f.seek(0)\n        return np.load(f)", "code_tokens": ["def", "deserialize_ndarray_npy", "(", "d", ")", ":", "with", "io", ".", "BytesIO", "(", ")", "as", "f", ":", "f", ".", "write", "(", "json", ".", "loads", "(", "d", "[", "'npy'", "]", ")", ".", "encode", "(", "'latin-1'", ")", ")", "f", ".", "seek", "(", "0", ")", "return", "np", ".", "load", "(", "f", ")"], "idx": 231}
{"url": "cosqa-train-11349", "docstring_tokens": ["helper", "to", "clean", "up", "an", "input", "string"], "code": "def clean(some_string, uppercase=False):\n    \"\"\"\n    helper to clean up an input string\n    \"\"\"\n    if uppercase:\n        return some_string.strip().upper()\n    else:\n        return some_string.strip().lower()", "code_tokens": ["def", "clean", "(", "some_string", ",", "uppercase", "=", "False", ")", ":", "if", "uppercase", ":", "return", "some_string", ".", "strip", "(", ")", ".", "upper", "(", ")", "else", ":", "return", "some_string", ".", "strip", "(", ")", ".", "lower", "(", ")"], "idx": 3327}
{"url": "cosqa-train-13590", "docstring_tokens": ["Extract", "tag", "s", "attributes", "into", "a", "dict", "."], "code": "def tag_to_dict(html):\n    \"\"\"Extract tag's attributes into a `dict`.\"\"\"\n\n    element = document_fromstring(html).xpath(\"//html/body/child::*\")[0]\n    attributes = dict(element.attrib)\n    attributes[\"text\"] = element.text_content()\n    return attributes", "code_tokens": ["def", "tag_to_dict", "(", "html", ")", ":", "element", "=", "document_fromstring", "(", "html", ")", ".", "xpath", "(", "\"//html/body/child::*\"", ")", "[", "0", "]", "attributes", "=", "dict", "(", "element", ".", "attrib", ")", "attributes", "[", "\"text\"", "]", "=", "element", ".", "text_content", "(", ")", "return", "attributes"], "idx": 5031}
{"url": "cosqa-train-11787", "docstring_tokens": ["Normalize", "s", "into", "ASCII", "and", "replace", "non", "-", "word", "characters", "with", "delimiter", "."], "code": "def slugify(s, delimiter='-'):\n    \"\"\"\n    Normalize `s` into ASCII and replace non-word characters with `delimiter`.\n    \"\"\"\n    s = unicodedata.normalize('NFKD', to_unicode(s)).encode('ascii', 'ignore').decode('ascii')\n    return RE_SLUG.sub(delimiter, s).strip(delimiter).lower()", "code_tokens": ["def", "slugify", "(", "s", ",", "delimiter", "=", "'-'", ")", ":", "s", "=", "unicodedata", ".", "normalize", "(", "'NFKD'", ",", "to_unicode", "(", "s", ")", ")", ".", "encode", "(", "'ascii'", ",", "'ignore'", ")", ".", "decode", "(", "'ascii'", ")", "return", "RE_SLUG", ".", "sub", "(", "delimiter", ",", "s", ")", ".", "strip", "(", "delimiter", ")", ".", "lower", "(", ")"], "idx": 4718}
{"url": "cosqa-train-12625", "docstring_tokens": ["Redraw", "event", "handler", "for", "the", "figure", "panel"], "code": "def OnUpdateFigurePanel(self, event):\n        \"\"\"Redraw event handler for the figure panel\"\"\"\n\n        if self.updating:\n            return\n\n        self.updating = True\n        self.figure_panel.update(self.get_figure(self.code))\n        self.updating = False", "code_tokens": ["def", "OnUpdateFigurePanel", "(", "self", ",", "event", ")", ":", "if", "self", ".", "updating", ":", "return", "self", ".", "updating", "=", "True", "self", ".", "figure_panel", ".", "update", "(", "self", ".", "get_figure", "(", "self", ".", "code", ")", ")", "self", ".", "updating", "=", "False"], "idx": 1999}
{"url": "cosqa-dev-398", "docstring_tokens": ["Helper", "function", "for", "creating", "hash", "functions", "."], "code": "def _hash_the_file(hasher, filename):\n    \"\"\"Helper function for creating hash functions.\n\n    See implementation of :func:`dtoolcore.filehasher.shasum`\n    for more usage details.\n    \"\"\"\n    BUF_SIZE = 65536\n    with open(filename, 'rb') as f:\n        buf = f.read(BUF_SIZE)\n        while len(buf) > 0:\n            hasher.update(buf)\n            buf = f.read(BUF_SIZE)\n    return hasher", "code_tokens": ["def", "_hash_the_file", "(", "hasher", ",", "filename", ")", ":", "BUF_SIZE", "=", "65536", "with", "open", "(", "filename", ",", "'rb'", ")", "as", "f", ":", "buf", "=", "f", ".", "read", "(", "BUF_SIZE", ")", "while", "len", "(", "buf", ")", ">", "0", ":", "hasher", ".", "update", "(", "buf", ")", "buf", "=", "f", ".", "read", "(", "BUF_SIZE", ")", "return", "hasher"], "idx": 5995}
{"url": "cosqa-train-9109", "docstring_tokens": ["Check", "if", "the", "device", "is", "on", "."], "code": "def get_power(self):\n        \"\"\"Check if the device is on.\"\"\"\n        power = (yield from self.handle_int(self.API.get('power')))\n        return bool(power)", "code_tokens": ["def", "get_power", "(", "self", ")", ":", "power", "=", "(", "yield", "from", "self", ".", "handle_int", "(", "self", ".", "API", ".", "get", "(", "'power'", ")", ")", ")", "return", "bool", "(", "power", ")"], "idx": 4170}
{"url": "cosqa-train-13087", "docstring_tokens": ["Return", "the", "hash", "."], "code": "def get_hash(self, handle):\n        \"\"\"Return the hash.\"\"\"\n        fpath = self._fpath_from_handle(handle)\n        return DiskStorageBroker.hasher(fpath)", "code_tokens": ["def", "get_hash", "(", "self", ",", "handle", ")", ":", "fpath", "=", "self", ".", "_fpath_from_handle", "(", "handle", ")", "return", "DiskStorageBroker", ".", "hasher", "(", "fpath", ")"], "idx": 4926}
{"url": "cosqa-train-19257", "docstring_tokens": ["Returns", "the", "number", "of", "processors", "on", "this", "machine", "."], "code": "def cpu_count() -> int:\n    \"\"\"Returns the number of processors on this machine.\"\"\"\n    if multiprocessing is None:\n        return 1\n    try:\n        return multiprocessing.cpu_count()\n    except NotImplementedError:\n        pass\n    try:\n        return os.sysconf(\"SC_NPROCESSORS_CONF\")\n    except (AttributeError, ValueError):\n        pass\n    gen_log.error(\"Could not detect number of processors; assuming 1\")\n    return 1", "code_tokens": ["def", "cpu_count", "(", ")", "->", "int", ":", "if", "multiprocessing", "is", "None", ":", "return", "1", "try", ":", "return", "multiprocessing", ".", "cpu_count", "(", ")", "except", "NotImplementedError", ":", "pass", "try", ":", "return", "os", ".", "sysconf", "(", "\"SC_NPROCESSORS_CONF\"", ")", "except", "(", "AttributeError", ",", "ValueError", ")", ":", "pass", "gen_log", ".", "error", "(", "\"Could", "not", "detect", "number", "of", "processors;", "assuming", "1\"", ")", "return", "1"], "idx": 5653}
{"url": "cosqa-train-7630", "docstring_tokens": ["If", "pair", "is", "in", "search_list", "return", "the", "index", ".", "Otherwise", "return", "-", "1"], "code": "def is_in(self, search_list, pair):\n        \"\"\"\n        If pair is in search_list, return the index. Otherwise return -1\n        \"\"\"\n        index = -1\n        for nr, i in enumerate(search_list):\n            if(np.all(i == pair)):\n                return nr\n        return index", "code_tokens": ["def", "is_in", "(", "self", ",", "search_list", ",", "pair", ")", ":", "index", "=", "-", "1", "for", "nr", ",", "i", "in", "enumerate", "(", "search_list", ")", ":", "if", "(", "np", ".", "all", "(", "i", "==", "pair", ")", ")", ":", "return", "nr", "return", "index"], "idx": 2444}
{"url": "cosqa-train-15644", "docstring_tokens": ["Returns", ":"], "code": "def getAllTriples(self):\n        \"\"\"Returns:\n\n        list of tuples : Each tuple holds a subject, predicate, object triple\n\n        \"\"\"\n        return [(str(s), str(p), str(o)) for s, p, o in self]", "code_tokens": ["def", "getAllTriples", "(", "self", ")", ":", "return", "[", "(", "str", "(", "s", ")", ",", "str", "(", "p", ")", ",", "str", "(", "o", ")", ")", "for", "s", ",", "p", ",", "o", "in", "self", "]"], "idx": 5351}
{"url": "cosqa-train-15556", "docstring_tokens": ["Generate", "all", "matches", "found", "within", "a", "string", "for", "a", "regex", "and", "yield", "each", "match", "as", "a", "string"], "code": "def iter_finds(regex_obj, s):\n    \"\"\"Generate all matches found within a string for a regex and yield each match as a string\"\"\"\n    if isinstance(regex_obj, str):\n        for m in re.finditer(regex_obj, s):\n            yield m.group()\n    else:\n        for m in regex_obj.finditer(s):\n            yield m.group()", "code_tokens": ["def", "iter_finds", "(", "regex_obj", ",", "s", ")", ":", "if", "isinstance", "(", "regex_obj", ",", "str", ")", ":", "for", "m", "in", "re", ".", "finditer", "(", "regex_obj", ",", "s", ")", ":", "yield", "m", ".", "group", "(", ")", "else", ":", "for", "m", "in", "regex_obj", ".", "finditer", "(", "s", ")", ":", "yield", "m", ".", "group", "(", ")"], "idx": 326}
{"url": "cosqa-train-6760", "docstring_tokens": ["Strip", "comments", "from", "json", "string", "."], "code": "def strip_comments(string, comment_symbols=frozenset(('#', '//'))):\n    \"\"\"Strip comments from json string.\n\n    :param string: A string containing json with comments started by comment_symbols.\n    :param comment_symbols: Iterable of symbols that start a line comment (default # or //).\n    :return: The string with the comments removed.\n    \"\"\"\n    lines = string.splitlines()\n    for k in range(len(lines)):\n        for symbol in comment_symbols:\n            lines[k] = strip_comment_line_with_symbol(lines[k], start=symbol)\n    return '\\n'.join(lines)", "code_tokens": ["def", "strip_comments", "(", "string", ",", "comment_symbols", "=", "frozenset", "(", "(", "'#'", ",", "'//'", ")", ")", ")", ":", "lines", "=", "string", ".", "splitlines", "(", ")", "for", "k", "in", "range", "(", "len", "(", "lines", ")", ")", ":", "for", "symbol", "in", "comment_symbols", ":", "lines", "[", "k", "]", "=", "strip_comment_line_with_symbol", "(", "lines", "[", "k", "]", ",", "start", "=", "symbol", ")", "return", "'\\n'", ".", "join", "(", "lines", ")"], "idx": 3569}
{"url": "cosqa-train-19008", "docstring_tokens": ["Detects", "whether", "a", "line", "is", "present", "within", "a", "file", "."], "code": "def is_line_in_file(filename: str, line: str) -> bool:\n    \"\"\"\n    Detects whether a line is present within a file.\n\n    Args:\n        filename: file to check\n        line: line to search for (as an exact match)\n    \"\"\"\n    assert \"\\n\" not in line\n    with open(filename, \"r\") as file:\n        for fileline in file:\n            if fileline == line:\n                return True\n        return False", "code_tokens": ["def", "is_line_in_file", "(", "filename", ":", "str", ",", "line", ":", "str", ")", "->", "bool", ":", "assert", "\"\\n\"", "not", "in", "line", "with", "open", "(", "filename", ",", "\"r\"", ")", "as", "file", ":", "for", "fileline", "in", "file", ":", "if", "fileline", "==", "line", ":", "return", "True", "return", "False"], "idx": 5707}
{"url": "cosqa-train-17655", "docstring_tokens": ["Asynchronously", "run", "the", "worker", "does", "not", "close", "connections", ".", "Useful", "when", "testing", "."], "code": "async def async_run(self) -> None:\n        \"\"\"\n        Asynchronously run the worker, does not close connections. Useful when testing.\n        \"\"\"\n        self.main_task = self.loop.create_task(self.main())\n        await self.main_task", "code_tokens": ["async", "def", "async_run", "(", "self", ")", "->", "None", ":", "self", ".", "main_task", "=", "self", ".", "loop", ".", "create_task", "(", "self", ".", "main", "(", ")", ")", "await", "self", ".", "main_task"], "idx": 5728}
{"url": "cosqa-train-12713", "docstring_tokens": ["Whether", "the", "item", "is", "a", "placeholder", "or", "contains", "a", "placeholder", "."], "code": "def _not_none(items):\n    \"\"\"Whether the item is a placeholder or contains a placeholder.\"\"\"\n    if not isinstance(items, (tuple, list)):\n        items = (items,)\n    return all(item is not _none for item in items)", "code_tokens": ["def", "_not_none", "(", "items", ")", ":", "if", "not", "isinstance", "(", "items", ",", "(", "tuple", ",", "list", ")", ")", ":", "items", "=", "(", "items", ",", ")", "return", "all", "(", "item", "is", "not", "_none", "for", "item", "in", "items", ")"], "idx": 208}
{"url": "cosqa-train-10777", "docstring_tokens": ["Is", "this", "attribute", "present?"], "code": "def has_attribute(module_name, attribute_name):\n    \"\"\"Is this attribute present?\"\"\"\n    init_file = '%s/__init__.py' % module_name\n    return any(\n        [attribute_name in init_line for init_line in open(init_file).readlines()]\n    )", "code_tokens": ["def", "has_attribute", "(", "module_name", ",", "attribute_name", ")", ":", "init_file", "=", "'%s/__init__.py'", "%", "module_name", "return", "any", "(", "[", "attribute_name", "in", "init_line", "for", "init_line", "in", "open", "(", "init_file", ")", ".", "readlines", "(", ")", "]", ")"], "idx": 1239}
{"url": "cosqa-train-7485", "docstring_tokens": ["Takes", "a", "text", "and", "drops", "all", "non", "-", "printable", "and", "non", "-", "ascii", "characters", "and", "also", "any", "whitespace", "characters", "that", "aren", "t", "space", "."], "code": "def drop_bad_characters(text):\n    \"\"\"Takes a text and drops all non-printable and non-ascii characters and\n    also any whitespace characters that aren't space.\n\n    :arg str text: the text to fix\n\n    :returns: text with all bad characters dropped\n\n    \"\"\"\n    # Strip all non-ascii and non-printable characters\n    text = ''.join([c for c in text if c in ALLOWED_CHARS])\n    return text", "code_tokens": ["def", "drop_bad_characters", "(", "text", ")", ":", "#", "Strip", "all", "non-ascii", "and", "non-printable", "characters", "text", "=", "''", ".", "join", "(", "[", "c", "for", "c", "in", "text", "if", "c", "in", "ALLOWED_CHARS", "]", ")", "return", "text"], "idx": 1217}
{"url": "cosqa-train-13755", "docstring_tokens": ["Like", "map", "but", "also", "chains", "the", "results", "."], "code": "def imapchain(*a, **kwa):\n    \"\"\" Like map but also chains the results. \"\"\"\n\n    imap_results = map( *a, **kwa )\n    return itertools.chain( *imap_results )", "code_tokens": ["def", "imapchain", "(", "*", "a", ",", "*", "*", "kwa", ")", ":", "imap_results", "=", "map", "(", "*", "a", ",", "*", "*", "kwa", ")", "return", "itertools", ".", "chain", "(", "*", "imap_results", ")"], "idx": 3696}
{"url": "cosqa-train-6799", "docstring_tokens": ["Clean", "a", "pandas", "dataframe", "by", ":", "1", ".", "Filling", "empty", "values", "with", "Nan", "2", ".", "Dropping", "columns", "with", "all", "empty", "values"], "code": "def clean_df(df, fill_nan=True, drop_empty_columns=True):\n    \"\"\"Clean a pandas dataframe by:\n        1. Filling empty values with Nan\n        2. Dropping columns with all empty values\n\n    Args:\n        df: Pandas DataFrame\n        fill_nan (bool): If any empty values (strings, None, etc) should be replaced with NaN\n        drop_empty_columns (bool): If columns whose values are all empty should be dropped\n\n    Returns:\n        DataFrame: cleaned DataFrame\n\n    \"\"\"\n    if fill_nan:\n        df = df.fillna(value=np.nan)\n    if drop_empty_columns:\n        df = df.dropna(axis=1, how='all')\n    return df.sort_index()", "code_tokens": ["def", "clean_df", "(", "df", ",", "fill_nan", "=", "True", ",", "drop_empty_columns", "=", "True", ")", ":", "if", "fill_nan", ":", "df", "=", "df", ".", "fillna", "(", "value", "=", "np", ".", "nan", ")", "if", "drop_empty_columns", ":", "df", "=", "df", ".", "dropna", "(", "axis", "=", "1", ",", "how", "=", "'all'", ")", "return", "df", ".", "sort_index", "(", ")"], "idx": 2333}
{"url": "cosqa-train-12555", "docstring_tokens": ["Determine", "if", "end", "-", "of", "-", "file", "is", "reached", "for", "file", "fd", "."], "code": "def eof(fd):\n    \"\"\"Determine if end-of-file is reached for file fd.\"\"\"\n    b = fd.read(1)\n    end = len(b) == 0\n    if not end:\n        curpos = fd.tell()\n        fd.seek(curpos - 1)\n    return end", "code_tokens": ["def", "eof", "(", "fd", ")", ":", "b", "=", "fd", ".", "read", "(", "1", ")", "end", "=", "len", "(", "b", ")", "==", "0", "if", "not", "end", ":", "curpos", "=", "fd", ".", "tell", "(", ")", "fd", ".", "seek", "(", "curpos", "-", "1", ")", "return", "end"], "idx": 2556}
{"url": "cosqa-train-14576", "docstring_tokens": ["Return", "the", "width", "of", "the", "table", "including", "padding", "and", "borders", "."], "code": "def table_width(self):\n        \"\"\"Return the width of the table including padding and borders.\"\"\"\n        outer_widths = max_dimensions(self.table_data, self.padding_left, self.padding_right)[2]\n        outer_border = 2 if self.outer_border else 0\n        inner_border = 1 if self.inner_column_border else 0\n        return table_width(outer_widths, outer_border, inner_border)", "code_tokens": ["def", "table_width", "(", "self", ")", ":", "outer_widths", "=", "max_dimensions", "(", "self", ".", "table_data", ",", "self", ".", "padding_left", ",", "self", ".", "padding_right", ")", "[", "2", "]", "outer_border", "=", "2", "if", "self", ".", "outer_border", "else", "0", "inner_border", "=", "1", "if", "self", ".", "inner_column_border", "else", "0", "return", "table_width", "(", "outer_widths", ",", "outer_border", ",", "inner_border", ")"], "idx": 2671}
{"url": "cosqa-train-9012", "docstring_tokens": ["Takes", "JSON", "formatted", "data", "converting", "it", "into", "native", "Python", "objects"], "code": "def json(body, charset='utf-8', **kwargs):\n    \"\"\"Takes JSON formatted data, converting it into native Python objects\"\"\"\n    return json_converter.loads(text(body, charset=charset))", "code_tokens": ["def", "json", "(", "body", ",", "charset", "=", "'utf-8'", ",", "*", "*", "kwargs", ")", ":", "return", "json_converter", ".", "loads", "(", "text", "(", "body", ",", "charset", "=", "charset", ")", ")"], "idx": 2057}
{"url": "cosqa-train-8054", "docstring_tokens": ["Returns", "the", "length", "of", "the", "list", "."], "code": "def llen(self, name):\n        \"\"\"\n        Returns the length of the list.\n\n        :param name: str     the name of the redis key\n        :return: Future()\n        \"\"\"\n        with self.pipe as pipe:\n            return pipe.llen(self.redis_key(name))", "code_tokens": ["def", "llen", "(", "self", ",", "name", ")", ":", "with", "self", ".", "pipe", "as", "pipe", ":", "return", "pipe", ".", "llen", "(", "self", ".", "redis_key", "(", "name", ")", ")"], "idx": 3940}
{"url": "cosqa-train-14439", "docstring_tokens": ["Establish", "tunnel", "connection", "early", "because", "otherwise", "httplib", "would", "improperly", "set", "Host", ":", "header", "to", "proxy", "s", "IP", ":", "port", "."], "code": "def _prepare_proxy(self, conn):\n        \"\"\"\n        Establish tunnel connection early, because otherwise httplib\n        would improperly set Host: header to proxy's IP:port.\n        \"\"\"\n        conn.set_tunnel(self._proxy_host, self.port, self.proxy_headers)\n        conn.connect()", "code_tokens": ["def", "_prepare_proxy", "(", "self", ",", "conn", ")", ":", "conn", ".", "set_tunnel", "(", "self", ".", "_proxy_host", ",", "self", ".", "port", ",", "self", ".", "proxy_headers", ")", "conn", ".", "connect", "(", ")"], "idx": 2519}
{"url": "cosqa-train-12630", "docstring_tokens": ["Method", "to", "validate", "if", "the", "value", "is", "valid", "for", "exact", "match", "type", "evaluation", "."], "code": "def is_value_type_valid_for_exact_conditions(self, value):\n    \"\"\" Method to validate if the value is valid for exact match type evaluation.\n\n    Args:\n      value: Value to validate.\n\n    Returns:\n      Boolean: True if value is a string, boolean, or number. Otherwise False.\n    \"\"\"\n    # No need to check for bool since bool is a subclass of int\n    if isinstance(value, string_types) or isinstance(value, (numbers.Integral, float)):\n      return True\n\n    return False", "code_tokens": ["def", "is_value_type_valid_for_exact_conditions", "(", "self", ",", "value", ")", ":", "#", "No", "need", "to", "check", "for", "bool", "since", "bool", "is", "a", "subclass", "of", "int", "if", "isinstance", "(", "value", ",", "string_types", ")", "or", "isinstance", "(", "value", ",", "(", "numbers", ".", "Integral", ",", "float", ")", ")", ":", "return", "True", "return", "False"], "idx": 3056}
{"url": "cosqa-train-9617", "docstring_tokens": [":", "param", "list_of_points", ":", ":", "return", ":", "list_of_points", "with", "None", "s", "removed"], "code": "def filter_none(list_of_points):\n    \"\"\"\n    \n    :param list_of_points: \n    :return: list_of_points with None's removed\n    \"\"\"\n    remove_elementnone = filter(lambda p: p is not None, list_of_points)\n    remove_sublistnone = filter(lambda p: not contains_none(p), remove_elementnone)\n    return list(remove_sublistnone)", "code_tokens": ["def", "filter_none", "(", "list_of_points", ")", ":", "remove_elementnone", "=", "filter", "(", "lambda", "p", ":", "p", "is", "not", "None", ",", "list_of_points", ")", "remove_sublistnone", "=", "filter", "(", "lambda", "p", ":", "not", "contains_none", "(", "p", ")", ",", "remove_elementnone", ")", "return", "list", "(", "remove_sublistnone", ")"], "idx": 1219}
{"url": "cosqa-train-9776", "docstring_tokens": ["Get", "the", "local", "variables", "in", "the", "caller", "s", "frame", "."], "code": "def caller_locals():\n    \"\"\"Get the local variables in the caller's frame.\"\"\"\n    import inspect\n    frame = inspect.currentframe()\n    try:\n        return frame.f_back.f_back.f_locals\n    finally:\n        del frame", "code_tokens": ["def", "caller_locals", "(", ")", ":", "import", "inspect", "frame", "=", "inspect", ".", "currentframe", "(", ")", "try", ":", "return", "frame", ".", "f_back", ".", "f_back", ".", "f_locals", "finally", ":", "del", "frame"], "idx": 4156}
{"url": "cosqa-train-8493", "docstring_tokens": ["http", ":", "//", "www", ".", "swharden", ".", "com", "/", "blog", "/", "2009", "-", "01", "-", "21", "-", "signal", "-", "filtering", "-", "with", "-", "python", "/", "#comment", "-", "16801"], "code": "def fft_bandpassfilter(data, fs, lowcut, highcut):\n    \"\"\"\n    http://www.swharden.com/blog/2009-01-21-signal-filtering-with-python/#comment-16801\n    \"\"\"\n    fft = np.fft.fft(data)\n    # n = len(data)\n    # timestep = 1.0 / fs\n    # freq = np.fft.fftfreq(n, d=timestep)\n    bp = fft.copy()\n\n    # Zero out fft coefficients\n    # bp[10:-10] = 0\n\n    # Normalise\n    # bp *= real(fft.dot(fft))/real(bp.dot(bp))\n\n    bp *= fft.dot(fft) / bp.dot(bp)\n\n    # must multipy by 2 to get the correct amplitude\n    ibp = 12 * np.fft.ifft(bp)\n    return ibp", "code_tokens": ["def", "fft_bandpassfilter", "(", "data", ",", "fs", ",", "lowcut", ",", "highcut", ")", ":", "fft", "=", "np", ".", "fft", ".", "fft", "(", "data", ")", "#", "n", "=", "len(data)", "#", "timestep", "=", "1.0", "/", "fs", "#", "freq", "=", "np.fft.fftfreq(n,", "d=timestep)", "bp", "=", "fft", ".", "copy", "(", ")", "#", "Zero", "out", "fft", "coefficients", "#", "bp[10:-10]", "=", "0", "#", "Normalise", "#", "bp", "*=", "real(fft.dot(fft))/real(bp.dot(bp))", "bp", "*=", "fft", ".", "dot", "(", "fft", ")", "/", "bp", ".", "dot", "(", "bp", ")", "#", "must", "multipy", "by", "2", "to", "get", "the", "correct", "amplitude", "ibp", "=", "12", "*", "np", ".", "fft", ".", "ifft", "(", "bp", ")", "return", "ibp"], "idx": 1552}
{"url": "cosqa-train-17070", "docstring_tokens": ["Reshuffle", "the", "indicies", "of", "a", "bipartite", "matrix", "A", "[", "ij", "kl", "]", "-", ">", "A", "[", "lj", "ki", "]", "."], "code": "def _reshuffle(mat, shape):\n    \"\"\"Reshuffle the indicies of a bipartite matrix A[ij,kl] -> A[lj,ki].\"\"\"\n    return np.reshape(\n        np.transpose(np.reshape(mat, shape), (3, 1, 2, 0)),\n        (shape[3] * shape[1], shape[0] * shape[2]))", "code_tokens": ["def", "_reshuffle", "(", "mat", ",", "shape", ")", ":", "return", "np", ".", "reshape", "(", "np", ".", "transpose", "(", "np", ".", "reshape", "(", "mat", ",", "shape", ")", ",", "(", "3", ",", "1", ",", "2", ",", "0", ")", ")", ",", "(", "shape", "[", "3", "]", "*", "shape", "[", "1", "]", ",", "shape", "[", "0", "]", "*", "shape", "[", "2", "]", ")", ")"], "idx": 5652}
{"url": "cosqa-train-12756", "docstring_tokens": ["Return", "a", "list", "where", "the", "duplicates", "have", "been", "removed", "."], "code": "def distinct(l):\n    \"\"\"\n    Return a list where the duplicates have been removed.\n\n    Args:\n        l (list): the list to filter.\n\n    Returns:\n        list: the same list without duplicates.\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    return (_ for _ in l if not (_ in seen or seen_add(_)))", "code_tokens": ["def", "distinct", "(", "l", ")", ":", "seen", "=", "set", "(", ")", "seen_add", "=", "seen", ".", "add", "return", "(", "_", "for", "_", "in", "l", "if", "not", "(", "_", "in", "seen", "or", "seen_add", "(", "_", ")", ")", ")"], "idx": 2294}
{"url": "cosqa-train-14531", "docstring_tokens": ["arr_out", "=", "round_array", "(", "array_in", ")"], "code": "def round_array(array_in):\n    \"\"\"\n    arr_out = round_array(array_in)\n\n    Rounds an array and recasts it to int. Also works on scalars.\n    \"\"\"\n    if isinstance(array_in, ndarray):\n        return np.round(array_in).astype(int)\n    else:\n        return int(np.round(array_in))", "code_tokens": ["def", "round_array", "(", "array_in", ")", ":", "if", "isinstance", "(", "array_in", ",", "ndarray", ")", ":", "return", "np", ".", "round", "(", "array_in", ")", ".", "astype", "(", "int", ")", "else", ":", "return", "int", "(", "np", ".", "round", "(", "array_in", ")", ")"], "idx": 1487}
{"url": "cosqa-train-12901", "docstring_tokens": ["Simple", "function", "to", "convert", "naive", ":", "std", ":", "datetime", ".", "datetime", "object", "containing", "local", "time", "to", "a", "naive", ":", "std", ":", "datetime", ".", "datetime", "object", "with", "UTC", "time", "."], "code": "def datetime_local_to_utc(local):\n    \"\"\"\n    Simple function to convert naive :std:`datetime.datetime` object containing\n    local time to a naive :std:`datetime.datetime` object with UTC time.\n    \"\"\"\n    timestamp = time.mktime(local.timetuple())\n    return datetime.datetime.utcfromtimestamp(timestamp)", "code_tokens": ["def", "datetime_local_to_utc", "(", "local", ")", ":", "timestamp", "=", "time", ".", "mktime", "(", "local", ".", "timetuple", "(", ")", ")", "return", "datetime", ".", "datetime", ".", "utcfromtimestamp", "(", "timestamp", ")"], "idx": 737}
{"url": "cosqa-train-9276", "docstring_tokens": ["Determine", "if", "a", "file", "is", "empty", "or", "not", "."], "code": "def file_empty(fp):\n    \"\"\"Determine if a file is empty or not.\"\"\"\n    # for python 2 we need to use a homemade peek()\n    if six.PY2:\n        contents = fp.read()\n        fp.seek(0)\n        return not bool(contents)\n\n    else:\n        return not fp.peek()", "code_tokens": ["def", "file_empty", "(", "fp", ")", ":", "#", "for", "python", "2", "we", "need", "to", "use", "a", "homemade", "peek()", "if", "six", ".", "PY2", ":", "contents", "=", "fp", ".", "read", "(", ")", "fp", ".", "seek", "(", "0", ")", "return", "not", "bool", "(", "contents", ")", "else", ":", "return", "not", "fp", ".", "peek", "(", ")"], "idx": 286}
{"url": "cosqa-train-10655", "docstring_tokens": ["Given", "a", "list", "of", "coords", "for", "3", "points", "Compute", "the", "area", "of", "this", "triangle", "."], "code": "def get_tri_area(pts):\n    \"\"\"\n    Given a list of coords for 3 points,\n    Compute the area of this triangle.\n\n    Args:\n        pts: [a, b, c] three points\n    \"\"\"\n    a, b, c = pts[0], pts[1], pts[2]\n    v1 = np.array(b) - np.array(a)\n    v2 = np.array(c) - np.array(a)\n    area_tri = abs(sp.linalg.norm(sp.cross(v1, v2)) / 2)\n    return area_tri", "code_tokens": ["def", "get_tri_area", "(", "pts", ")", ":", "a", ",", "b", ",", "c", "=", "pts", "[", "0", "]", ",", "pts", "[", "1", "]", ",", "pts", "[", "2", "]", "v1", "=", "np", ".", "array", "(", "b", ")", "-", "np", ".", "array", "(", "a", ")", "v2", "=", "np", ".", "array", "(", "c", ")", "-", "np", ".", "array", "(", "a", ")", "area_tri", "=", "abs", "(", "sp", ".", "linalg", ".", "norm", "(", "sp", ".", "cross", "(", "v1", ",", "v2", ")", ")", "/", "2", ")", "return", "area_tri"], "idx": 58}
{"url": "cosqa-train-13534", "docstring_tokens": [""], "code": "def copy(obj):\n    def copy(self):\n        \"\"\"\n        Copy self to a new object.\n        \"\"\"\n        from copy import deepcopy\n\n        return deepcopy(self)\n    obj.copy = copy\n    return obj", "code_tokens": ["def", "copy", "(", "obj", ")", ":", "def", "copy", "(", "self", ")", ":", "\"\"\"\n", "", "", "", "", "", "", "", "Copy", "self", "to", "a", "new", "object.\n", "", "", "", "", "", "", "", "\"\"\"", "from", "copy", "import", "deepcopy", "return", "deepcopy", "(", "self", ")", "obj", ".", "copy", "=", "copy", "return", "obj"], "idx": 1395}
{"url": "cosqa-train-4709", "docstring_tokens": ["Transform", "list", "into", "a", "maxheap", "in", "-", "place", "in", "O", "(", "len", "(", "x", "))", "time", "."], "code": "def _heapify_max(x):\n    \"\"\"Transform list into a maxheap, in-place, in O(len(x)) time.\"\"\"\n    n = len(x)\n    for i in reversed(range(n//2)):\n        _siftup_max(x, i)", "code_tokens": ["def", "_heapify_max", "(", "x", ")", ":", "n", "=", "len", "(", "x", ")", "for", "i", "in", "reversed", "(", "range", "(", "n", "//", "2", ")", ")", ":", "_siftup_max", "(", "x", ",", "i", ")"], "idx": 511}
{"url": "cosqa-train-5880", "docstring_tokens": ["Returns", "the", "file", "exif"], "code": "def information(filename):\n    \"\"\"Returns the file exif\"\"\"\n    check_if_this_file_exist(filename)\n    filename = os.path.abspath(filename)\n    result = get_json(filename)\n    result = result[0]\n    return result", "code_tokens": ["def", "information", "(", "filename", ")", ":", "check_if_this_file_exist", "(", "filename", ")", "filename", "=", "os", ".", "path", ".", "abspath", "(", "filename", ")", "result", "=", "get_json", "(", "filename", ")", "result", "=", "result", "[", "0", "]", "return", "result"], "idx": 2145}
{"url": "cosqa-train-12563", "docstring_tokens": ["Check", "if", "file", "is", "a", "regular", "file", "and", "is", "readable", "."], "code": "def is_readable(filename):\n    \"\"\"Check if file is a regular file and is readable.\"\"\"\n    return os.path.isfile(filename) and os.access(filename, os.R_OK)", "code_tokens": ["def", "is_readable", "(", "filename", ")", ":", "return", "os", ".", "path", ".", "isfile", "(", "filename", ")", "and", "os", ".", "access", "(", "filename", ",", "os", ".", "R_OK", ")"], "idx": 2445}
{"url": "cosqa-train-17092", "docstring_tokens": ["Get", "the", "last", "weekday", "in", "a", "given", "month", ".", "e", ".", "g", ":"], "code": "def get_last_weekday_in_month(year, month, weekday):\n        \"\"\"Get the last weekday in a given month. e.g:\n\n        >>> # the last monday in Jan 2013\n        >>> Calendar.get_last_weekday_in_month(2013, 1, MON)\n        datetime.date(2013, 1, 28)\n        \"\"\"\n        day = date(year, month, monthrange(year, month)[1])\n        while True:\n            if day.weekday() == weekday:\n                break\n            day = day - timedelta(days=1)\n        return day", "code_tokens": ["def", "get_last_weekday_in_month", "(", "year", ",", "month", ",", "weekday", ")", ":", "day", "=", "date", "(", "year", ",", "month", ",", "monthrange", "(", "year", ",", "month", ")", "[", "1", "]", ")", "while", "True", ":", "if", "day", ".", "weekday", "(", ")", "==", "weekday", ":", "break", "day", "=", "day", "-", "timedelta", "(", "days", "=", "1", ")", "return", "day"], "idx": 5667}
{"url": "cosqa-train-19483", "docstring_tokens": ["Takes", "a", "list", "of", "rows", "and", "a", "column", "name", "and", "returns", "a", "list", "containing", "a", "single", "row", "(", "dict", "from", "columns", "to", "cells", ")", "that", "has", "the", "maximum", "numerical", "value", "in", "the", "given", "column", ".", "We", "return", "a", "list", "instead", "of", "a", "single", "dict", "to", "be", "consistent", "with", "the", "return", "type", "of", "select", "and", "all_rows", "."], "code": "def argmax(self, rows: List[Row], column: ComparableColumn) -> List[Row]:\n        \"\"\"\n        Takes a list of rows and a column name and returns a list containing a single row (dict from\n        columns to cells) that has the maximum numerical value in the given column. We return a list\n        instead of a single dict to be consistent with the return type of ``select`` and\n        ``all_rows``.\n        \"\"\"\n        if not rows:\n            return []\n        value_row_pairs = [(row.values[column.name], row) for row in rows]\n        if not value_row_pairs:\n            return []\n        # Returns a list containing the row with the max cell value.\n        return [sorted(value_row_pairs, key=lambda x: x[0], reverse=True)[0][1]]", "code_tokens": ["def", "argmax", "(", "self", ",", "rows", ":", "List", "[", "Row", "]", ",", "column", ":", "ComparableColumn", ")", "->", "List", "[", "Row", "]", ":", "if", "not", "rows", ":", "return", "[", "]", "value_row_pairs", "=", "[", "(", "row", ".", "values", "[", "column", ".", "name", "]", ",", "row", ")", "for", "row", "in", "rows", "]", "if", "not", "value_row_pairs", ":", "return", "[", "]", "#", "Returns", "a", "list", "containing", "the", "row", "with", "the", "max", "cell", "value.", "return", "[", "sorted", "(", "value_row_pairs", ",", "key", "=", "lambda", "x", ":", "x", "[", "0", "]", ",", "reverse", "=", "True", ")", "[", "0", "]", "[", "1", "]", "]"], "idx": 5799}
{"url": "cosqa-train-12296", "docstring_tokens": ["Reverse", "the", "range"], "code": "def negate(self):\n        \"\"\"Reverse the range\"\"\"\n        self.from_value, self.to_value = self.to_value, self.from_value\n        self.include_lower, self.include_upper = self.include_upper, self.include_lower", "code_tokens": ["def", "negate", "(", "self", ")", ":", "self", ".", "from_value", ",", "self", ".", "to_value", "=", "self", ".", "to_value", ",", "self", ".", "from_value", "self", ".", "include_lower", ",", "self", ".", "include_upper", "=", "self", ".", "include_upper", ",", "self", ".", "include_lower"], "idx": 1685}
{"url": "cosqa-train-11045", "docstring_tokens": ["Pass", "in", "a", "dictionary", "that", "has", "unsafe", "characters", "as", "the", "keys", "and", "the", "percent", "encoded", "value", "as", "the", "value", "."], "code": "def quote(s, unsafe='/'):\n    \"\"\"Pass in a dictionary that has unsafe characters as the keys, and the percent\n    encoded value as the value.\"\"\"\n    res = s.replace('%', '%25')\n    for c in unsafe:\n        res = res.replace(c, '%' + (hex(ord(c)).upper())[2:])\n    return res", "code_tokens": ["def", "quote", "(", "s", ",", "unsafe", "=", "'/'", ")", ":", "res", "=", "s", ".", "replace", "(", "'%'", ",", "'%25'", ")", "for", "c", "in", "unsafe", ":", "res", "=", "res", ".", "replace", "(", "c", ",", "'%'", "+", "(", "hex", "(", "ord", "(", "c", ")", ")", ".", "upper", "(", ")", ")", "[", "2", ":", "]", ")", "return", "res"], "idx": 905}
{"url": "cosqa-train-12263", "docstring_tokens": ["Plot", "a", "smoothed", "(", "by", "kernel", "density", "estimate", ")", "histogram", ".", ":", "type", "data", ":", "numpy", "array", ":", "param", "data", ":", "An", "array", "containing", "the", "data", "to", "be", "plotted"], "code": "def plot_kde(data, ax, title=None, color='r', fill_bt=True):\n    \"\"\"\n    Plot a smoothed (by kernel density estimate) histogram.\n    :type data: numpy array\n    :param data: An array containing the data to be plotted\n\n    :type ax: matplotlib.Axes\n    :param ax: The Axes object to draw to\n\n    :type title: str\n    :param title: The plot title\n\n    :type color: str\n    :param color: The color of the histogram line and fill. Note that the fill\n                  will be plotted with an alpha of 0.35.\n\n    :type fill_bt: bool\n    :param fill_bt: Specify whether to fill the area beneath the histogram line\n    \"\"\"\n    if isinstance(data, list):\n        data = np.asarray(data)\n    e = kde.KDEUnivariate(data.astype(np.float))\n    e.fit()\n    ax.plot(e.support, e.density, color=color, alpha=0.9, linewidth=2.25)\n    if fill_bt:\n        ax.fill_between(e.support, e.density, alpha=.35, zorder=1,\n                        antialiased=True, color=color)\n    if title is not None:\n        t = ax.set_title(title)\n        t.set_y(1.05)", "code_tokens": ["def", "plot_kde", "(", "data", ",", "ax", ",", "title", "=", "None", ",", "color", "=", "'r'", ",", "fill_bt", "=", "True", ")", ":", "if", "isinstance", "(", "data", ",", "list", ")", ":", "data", "=", "np", ".", "asarray", "(", "data", ")", "e", "=", "kde", ".", "KDEUnivariate", "(", "data", ".", "astype", "(", "np", ".", "float", ")", ")", "e", ".", "fit", "(", ")", "ax", ".", "plot", "(", "e", ".", "support", ",", "e", ".", "density", ",", "color", "=", "color", ",", "alpha", "=", "0.9", ",", "linewidth", "=", "2.25", ")", "if", "fill_bt", ":", "ax", ".", "fill_between", "(", "e", ".", "support", ",", "e", ".", "density", ",", "alpha", "=", ".35", ",", "zorder", "=", "1", ",", "antialiased", "=", "True", ",", "color", "=", "color", ")", "if", "title", "is", "not", "None", ":", "t", "=", "ax", ".", "set_title", "(", "title", ")", "t", ".", "set_y", "(", "1.05", ")"], "idx": 4630}
{"url": "cosqa-train-17585", "docstring_tokens": ["Multiply", "each", "number", "by", "a", "constant", "such", "that", "the", "sum", "is", "1", ".", "0", ">>>", "normalize", "(", "[", "1", "2", "1", "]", ")", "[", "0", ".", "25", "0", ".", "5", "0", ".", "25", "]"], "code": "def normalize(numbers):\n    \"\"\"Multiply each number by a constant such that the sum is 1.0\n    >>> normalize([1,2,1])\n    [0.25, 0.5, 0.25]\n    \"\"\"\n    total = float(sum(numbers))\n    return [n / total for n in numbers]", "code_tokens": ["def", "normalize", "(", "numbers", ")", ":", "total", "=", "float", "(", "sum", "(", "numbers", ")", ")", "return", "[", "n", "/", "total", "for", "n", "in", "numbers", "]"], "idx": 5632}
{"url": "cosqa-train-11245", "docstring_tokens": ["Linear", "oldstyle", "interpolation", "of", "the", "transform", "matrix", "."], "code": "def _linearInterpolationTransformMatrix(matrix1, matrix2, value):\n    \"\"\" Linear, 'oldstyle' interpolation of the transform matrix.\"\"\"\n    return tuple(_interpolateValue(matrix1[i], matrix2[i], value) for i in range(len(matrix1)))", "code_tokens": ["def", "_linearInterpolationTransformMatrix", "(", "matrix1", ",", "matrix2", ",", "value", ")", ":", "return", "tuple", "(", "_interpolateValue", "(", "matrix1", "[", "i", "]", ",", "matrix2", "[", "i", "]", ",", "value", ")", "for", "i", "in", "range", "(", "len", "(", "matrix1", ")", ")", ")"], "idx": 1274}
{"url": "cosqa-train-14554", "docstring_tokens": ["Retrieves", "a", "list", "of", "member", "-", "like", "objects", "(", "members", "or", "properties", ")", "that", "are", "publically", "exposed", "."], "code": "def get_public_members(obj):\n    \"\"\"\n    Retrieves a list of member-like objects (members or properties) that are\n    publically exposed.\n\n    :param obj: The object to probe.\n    :return:    A list of strings.\n    \"\"\"\n    return {attr: getattr(obj, attr) for attr in dir(obj)\n            if not attr.startswith(\"_\")\n            and not hasattr(getattr(obj, attr), '__call__')}", "code_tokens": ["def", "get_public_members", "(", "obj", ")", ":", "return", "{", "attr", ":", "getattr", "(", "obj", ",", "attr", ")", "for", "attr", "in", "dir", "(", "obj", ")", "if", "not", "attr", ".", "startswith", "(", "\"_\"", ")", "and", "not", "hasattr", "(", "getattr", "(", "obj", ",", "attr", ")", ",", "'__call__'", ")", "}"], "idx": 433}
{"url": "cosqa-train-11387", "docstring_tokens": ["Check", "to", "see", "if", "we", "are", "colliding", "with", "the", "player", "."], "code": "def check_player_collision(self):\n        \"\"\"Check to see if we are colliding with the player.\"\"\"\n        player_tiles = r.TileMapManager.active_map.grab_collisions(self.char.coords)\n        enemy_tiles = r.TileMapManager.active_map.grab_collisions(self.coords)\n\n        #Check to see if any of the tiles are the same. If so, there is a collision.\n        for ptile in player_tiles:\n            for etile in enemy_tiles:\n                if r.TileMapManager.active_map.pixels_to_tiles(ptile.coords) == r.TileMapManager.active_map.pixels_to_tiles(etile.coords):\n                    return True\n\n        return False", "code_tokens": ["def", "check_player_collision", "(", "self", ")", ":", "player_tiles", "=", "r", ".", "TileMapManager", ".", "active_map", ".", "grab_collisions", "(", "self", ".", "char", ".", "coords", ")", "enemy_tiles", "=", "r", ".", "TileMapManager", ".", "active_map", ".", "grab_collisions", "(", "self", ".", "coords", ")", "#Check", "to", "see", "if", "any", "of", "the", "tiles", "are", "the", "same.", "If", "so,", "there", "is", "a", "collision.", "for", "ptile", "in", "player_tiles", ":", "for", "etile", "in", "enemy_tiles", ":", "if", "r", ".", "TileMapManager", ".", "active_map", ".", "pixels_to_tiles", "(", "ptile", ".", "coords", ")", "==", "r", ".", "TileMapManager", ".", "active_map", ".", "pixels_to_tiles", "(", "etile", ".", "coords", ")", ":", "return", "True", "return", "False"], "idx": 4646}
{"url": "cosqa-train-15249", "docstring_tokens": ["Get", "object", "if", "child", "already", "been", "read", "or", "get", "child", "."], "code": "def get_object_or_child_by_type(self, *types):\n        \"\"\" Get object if child already been read or get child.\n\n        Use this method for fast access to objects in case of static configurations.\n\n        :param types: requested object types.\n        :return: all children of the specified types.\n        \"\"\"\n\n        objects = self.get_objects_or_children_by_type(*types)\n        return objects[0] if any(objects) else None", "code_tokens": ["def", "get_object_or_child_by_type", "(", "self", ",", "*", "types", ")", ":", "objects", "=", "self", ".", "get_objects_or_children_by_type", "(", "*", "types", ")", "return", "objects", "[", "0", "]", "if", "any", "(", "objects", ")", "else", "None"], "idx": 4577}
{"url": "cosqa-train-7142", "docstring_tokens": ["Convert", "to", "float", "if", "object", "is", "a", "float", "string", "."], "code": "def _tofloat(obj):\n    \"\"\"Convert to float if object is a float string.\"\"\"\n    if \"inf\" in obj.lower().strip():\n        return obj\n    try:\n        return int(obj)\n    except ValueError:\n        try:\n            return float(obj)\n        except ValueError:\n            return obj", "code_tokens": ["def", "_tofloat", "(", "obj", ")", ":", "if", "\"inf\"", "in", "obj", ".", "lower", "(", ")", ".", "strip", "(", ")", ":", "return", "obj", "try", ":", "return", "int", "(", "obj", ")", "except", "ValueError", ":", "try", ":", "return", "float", "(", "obj", ")", "except", "ValueError", ":", "return", "obj"], "idx": 2120}
{"url": "cosqa-train-1141", "docstring_tokens": ["Closes", "the", "connection"], "code": "def exit(self):\n        \"\"\"\n        Closes the connection\n        \"\"\"\n        self.pubsub.unsubscribe()\n        self.client.connection_pool.disconnect()\n\n        logger.info(\"Connection to Redis closed\")", "code_tokens": ["def", "exit", "(", "self", ")", ":", "self", ".", "pubsub", ".", "unsubscribe", "(", ")", "self", ".", "client", ".", "connection_pool", ".", "disconnect", "(", ")", "logger", ".", "info", "(", "\"Connection", "to", "Redis", "closed\"", ")"], "idx": 985}
{"url": "cosqa-train-6492", "docstring_tokens": ["A", "dialog", "to", "get", "a", "directory", "name", ".", "Returns", "the", "name", "of", "a", "directory", "or", "None", "if", "user", "chose", "to", "cancel", ".", "If", "the", "default", "argument", "specifies", "a", "directory", "name", "and", "that", "directory", "exists", "then", "the", "dialog", "box", "will", "start", "with", "that", "directory", "."], "code": "def ask_folder(message='Select folder.', default='', title=''):\n    \"\"\"\n    A dialog to get a directory name.\n    Returns the name of a directory, or None if user chose to cancel.\n    If the \"default\" argument specifies a directory name, and that\n    directory exists, then the dialog box will start with that directory.\n\n    :param message: message to be displayed.\n    :param title: window title\n    :param default: default folder path\n    :rtype: None or string\n    \"\"\"\n    return backend_api.opendialog(\"ask_folder\", dict(message=message, default=default, title=title))", "code_tokens": ["def", "ask_folder", "(", "message", "=", "'Select", "folder.'", ",", "default", "=", "''", ",", "title", "=", "''", ")", ":", "return", "backend_api", ".", "opendialog", "(", "\"ask_folder\"", ",", "dict", "(", "message", "=", "message", ",", "default", "=", "default", ",", "title", "=", "title", ")", ")"], "idx": 3504}
{"url": "cosqa-train-11163", "docstring_tokens": ["Debug", "a", "single", "doctest", "docstring", "in", "argument", "src"], "code": "def debug_src(src, pm=False, globs=None):\n    \"\"\"Debug a single doctest docstring, in argument `src`'\"\"\"\n    testsrc = script_from_examples(src)\n    debug_script(testsrc, pm, globs)", "code_tokens": ["def", "debug_src", "(", "src", ",", "pm", "=", "False", ",", "globs", "=", "None", ")", ":", "testsrc", "=", "script_from_examples", "(", "src", ")", "debug_script", "(", "testsrc", ",", "pm", ",", "globs", ")"], "idx": 586}
{"url": "cosqa-train-12144", "docstring_tokens": ["Normalizes", "the", "given", "vector", ".", "The", "vector", "given", "may", "have", "any", "number", "of", "dimensions", "."], "code": "def v_normalize(v):\n    \"\"\"\n    Normalizes the given vector.\n    \n    The vector given may have any number of dimensions.\n    \"\"\"\n    vmag = v_magnitude(v)\n    return [ v[i]/vmag  for i in range(len(v)) ]", "code_tokens": ["def", "v_normalize", "(", "v", ")", ":", "vmag", "=", "v_magnitude", "(", "v", ")", "return", "[", "v", "[", "i", "]", "/", "vmag", "for", "i", "in", "range", "(", "len", "(", "v", ")", ")", "]"], "idx": 2497}
{"url": "cosqa-train-5909", "docstring_tokens": ["Flags", "that", "a", "function", "is", "linear", "wrt", "all", "args"], "code": "def def_linear(fun):\n    \"\"\"Flags that a function is linear wrt all args\"\"\"\n    defjvp_argnum(fun, lambda argnum, g, ans, args, kwargs:\n                  fun(*subval(args, argnum, g), **kwargs))", "code_tokens": ["def", "def_linear", "(", "fun", ")", ":", "defjvp_argnum", "(", "fun", ",", "lambda", "argnum", ",", "g", ",", "ans", ",", "args", ",", "kwargs", ":", "fun", "(", "*", "subval", "(", "args", ",", "argnum", ",", "g", ")", ",", "*", "*", "kwargs", ")", ")"], "idx": 1433}
{"url": "cosqa-train-1982", "docstring_tokens": [""], "code": "def __next__(self):\n        \"\"\"\n\n        :return: a pair (1-based line number in the input, row)\n        \"\"\"\n        # Retrieve the row, thereby incrementing the line number:\n        row = super(UnicodeReaderWithLineNumber, self).__next__()\n        return self.lineno + 1, row", "code_tokens": ["def", "__next__", "(", "self", ")", ":", "#", "Retrieve", "the", "row,", "thereby", "incrementing", "the", "line", "number:", "row", "=", "super", "(", "UnicodeReaderWithLineNumber", ",", "self", ")", ".", "__next__", "(", ")", "return", "self", ".", "lineno", "+", "1", ",", "row"], "idx": 1590}
{"url": "cosqa-train-17749", "docstring_tokens": ["Get", "all", "the", "database", "column", "names", "for", "the", "specified", "table", "."], "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": ["def", "get_column_names", "(", "engine", ":", "Engine", ",", "tablename", ":", "str", ")", "->", "List", "[", "str", "]", ":", "return", "[", "info", ".", "name", "for", "info", "in", "gen_columns_info", "(", "engine", ",", "tablename", ")", "]"], "idx": 5550}
{"url": "cosqa-train-14056", "docstring_tokens": ["construct", "the", "model", "matrix", "columns", "for", "the", "term"], "code": "def build_columns(self, X, verbose=False):\n        \"\"\"construct the model matrix columns for the term\n\n        Parameters\n        ----------\n        X : array-like\n            Input dataset with n rows\n\n        verbose : bool\n            whether to show warnings\n\n        Returns\n        -------\n        scipy sparse array with n rows\n        \"\"\"\n        return sp.sparse.csc_matrix(X[:, self.feature][:, np.newaxis])", "code_tokens": ["def", "build_columns", "(", "self", ",", "X", ",", "verbose", "=", "False", ")", ":", "return", "sp", ".", "sparse", ".", "csc_matrix", "(", "X", "[", ":", ",", "self", ".", "feature", "]", "[", ":", ",", "np", ".", "newaxis", "]", ")"], "idx": 5103}
{"url": "cosqa-train-2483", "docstring_tokens": ["Support", "instance", "methods"], "code": "def __get__(self, obj, objtype):\n        \"\"\" Support instance methods \"\"\"\n        import functools\n        return functools.partial(self.__call__, obj)", "code_tokens": ["def", "__get__", "(", "self", ",", "obj", ",", "objtype", ")", ":", "import", "functools", "return", "functools", ".", "partial", "(", "self", ".", "__call__", ",", "obj", ")"], "idx": 1889}
{"url": "cosqa-train-12420", "docstring_tokens": ["New", "event", "for", "light", "."], "code": "def async_update(self, event):\n        \"\"\"New event for light.\n\n        Check that state is part of event.\n        Signal that light has updated state.\n        \"\"\"\n        self.update_attr(event.get('state', {}))\n        super().async_update(event)", "code_tokens": ["def", "async_update", "(", "self", ",", "event", ")", ":", "self", ".", "update_attr", "(", "event", ".", "get", "(", "'state'", ",", "{", "}", ")", ")", "super", "(", ")", ".", "async_update", "(", "event", ")"], "idx": 4822}
{"url": "cosqa-train-14688", "docstring_tokens": ["must", "be", "a", "float"], "code": "def is_float(value):\n    \"\"\"must be a float\"\"\"\n    return isinstance(value, float) or isinstance(value, int) or isinstance(value, np.float64), float(value)", "code_tokens": ["def", "is_float", "(", "value", ")", ":", "return", "isinstance", "(", "value", ",", "float", ")", "or", "isinstance", "(", "value", ",", "int", ")", "or", "isinstance", "(", "value", ",", "np", ".", "float64", ")", ",", "float", "(", "value", ")"], "idx": 772}
{"url": "cosqa-train-10097", "docstring_tokens": ["Return", "maximum", "nesting", "depth"], "code": "def maxlevel(lst):\n    \"\"\"Return maximum nesting depth\"\"\"\n    maxlev = 0\n    def f(lst, level):\n        nonlocal maxlev\n        if isinstance(lst, list):\n            level += 1\n            maxlev = max(level, maxlev)\n            for item in lst:\n                f(item, level)\n    f(lst, 0)\n    return maxlev", "code_tokens": ["def", "maxlevel", "(", "lst", ")", ":", "maxlev", "=", "0", "def", "f", "(", "lst", ",", "level", ")", ":", "nonlocal", "maxlev", "if", "isinstance", "(", "lst", ",", "list", ")", ":", "level", "+=", "1", "maxlev", "=", "max", "(", "level", ",", "maxlev", ")", "for", "item", "in", "lst", ":", "f", "(", "item", ",", "level", ")", "f", "(", "lst", ",", "0", ")", "return", "maxlev"], "idx": 3040}
{"url": "cosqa-train-12491", "docstring_tokens": ["Returns", "a", "boolean", "indicating", "if", "the", "code", "is", "executed", "inside", "softimage", "."], "code": "def inside_softimage():\n    \"\"\"Returns a boolean indicating if the code is executed inside softimage.\"\"\"\n    try:\n        import maya\n        return False\n    except ImportError:\n        pass\n    try:\n        from win32com.client import Dispatch as disp\n        disp('XSI.Application')\n        return True\n    except:\n        return False", "code_tokens": ["def", "inside_softimage", "(", ")", ":", "try", ":", "import", "maya", "return", "False", "except", "ImportError", ":", "pass", "try", ":", "from", "win32com", ".", "client", "import", "Dispatch", "as", "disp", "disp", "(", "'XSI.Application'", ")", "return", "True", "except", ":", "return", "False"], "idx": 1617}
{"url": "cosqa-train-894", "docstring_tokens": ["Visible", "width", "of", "a", "potentially", "multiline", "content", "."], "code": "def _multiline_width(multiline_s, line_width_fn=len):\n    \"\"\"Visible width of a potentially multiline content.\"\"\"\n    return max(map(line_width_fn, re.split(\"[\\r\\n]\", multiline_s)))", "code_tokens": ["def", "_multiline_width", "(", "multiline_s", ",", "line_width_fn", "=", "len", ")", ":", "return", "max", "(", "map", "(", "line_width_fn", ",", "re", ".", "split", "(", "\"[\\r\\n]\"", ",", "multiline_s", ")", ")", ")"], "idx": 733}
{"url": "cosqa-train-13783", "docstring_tokens": ["Sends", "multiple", "non", "-", "blocking", "requests", ".", "Returns", "a", "list", "of", "responses", "."], "code": "def _async_requests(urls):\n    \"\"\"\n    Sends multiple non-blocking requests. Returns\n    a list of responses.\n\n    :param urls:\n        List of urls\n    \"\"\"\n    session = FuturesSession(max_workers=30)\n    futures = [\n        session.get(url)\n        for url in urls\n    ]\n    return [ future.result() for future in futures ]", "code_tokens": ["def", "_async_requests", "(", "urls", ")", ":", "session", "=", "FuturesSession", "(", "max_workers", "=", "30", ")", "futures", "=", "[", "session", ".", "get", "(", "url", ")", "for", "url", "in", "urls", "]", "return", "[", "future", ".", "result", "(", ")", "for", "future", "in", "futures", "]"], "idx": 5055}
{"url": "cosqa-train-9543", "docstring_tokens": ["Linspace", "op", "."], "code": "def LinSpace(start, stop, num):\n    \"\"\"\n    Linspace op.\n    \"\"\"\n    return np.linspace(start, stop, num=num, dtype=np.float32),", "code_tokens": ["def", "LinSpace", "(", "start", ",", "stop", ",", "num", ")", ":", "return", "np", ".", "linspace", "(", "start", ",", "stop", ",", "num", "=", "num", ",", "dtype", "=", "np", ".", "float32", ")", ","], "idx": 3124}
{"url": "cosqa-train-4634", "docstring_tokens": ["Get", "the", "last", "object", "in", "file", "."], "code": "def last(self):\n        \"\"\"Get the last object in file.\"\"\"\n        # End of file\n        self.__file.seek(0, 2)\n\n        # Get the last struct\n        data = self.get(self.length - 1)\n\n        return data", "code_tokens": ["def", "last", "(", "self", ")", ":", "#", "End", "of", "file", "self", ".", "__file", ".", "seek", "(", "0", ",", "2", ")", "#", "Get", "the", "last", "struct", "data", "=", "self", ".", "get", "(", "self", ".", "length", "-", "1", ")", "return", "data"], "idx": 585}
{"url": "cosqa-train-2994", "docstring_tokens": ["Logout", "from", "the", "remote", "server", "."], "code": "def logout(self):\n        \"\"\"\n            Logout from the remote server.\n        \"\"\"\n        self.client.write('exit\\r\\n')\n        self.client.read_all()\n        self.client.close()", "code_tokens": ["def", "logout", "(", "self", ")", ":", "self", ".", "client", ".", "write", "(", "'exit\\r\\n'", ")", "self", ".", "client", ".", "read_all", "(", ")", "self", ".", "client", ".", "close", "(", ")"], "idx": 2148}
{"url": "cosqa-train-806", "docstring_tokens": ["Get", "from", "a", "list", "with", "an", "optional", "default", "value", "."], "code": "def list_get(l, idx, default=None):\n    \"\"\"\n    Get from a list with an optional default value.\n    \"\"\"\n    try:\n        if l[idx]:\n            return l[idx]\n        else:\n            return default\n    except IndexError:\n        return default", "code_tokens": ["def", "list_get", "(", "l", ",", "idx", ",", "default", "=", "None", ")", ":", "try", ":", "if", "l", "[", "idx", "]", ":", "return", "l", "[", "idx", "]", "else", ":", "return", "default", "except", "IndexError", ":", "return", "default"], "idx": 719}
{"url": "cosqa-train-12002", "docstring_tokens": ["Has", "a", "50", "/", "50", "chance", "of", "calling", "a", "function"], "code": "def sometimesish(fn):\n    \"\"\"\n    Has a 50/50 chance of calling a function\n    \"\"\"\n    def wrapped(*args, **kwargs):\n        if random.randint(1, 2) == 1:\n            return fn(*args, **kwargs)\n\n    return wrapped", "code_tokens": ["def", "sometimesish", "(", "fn", ")", ":", "def", "wrapped", "(", "*", "args", ",", "*", "*", "kwargs", ")", ":", "if", "random", ".", "randint", "(", "1", ",", "2", ")", "==", "1", ":", "return", "fn", "(", "*", "args", ",", "*", "*", "kwargs", ")", "return", "wrapped"], "idx": 1398}
{"url": "cosqa-train-16219", "docstring_tokens": ["Returns", "a", "StrictRedis", "connection", "instance", "."], "code": "def get_connection(self, host, port, db):\n        \"\"\"\n        Returns a ``StrictRedis`` connection instance.\n        \"\"\"\n        return redis.StrictRedis(\n            host=host,\n            port=port,\n            db=db,\n            decode_responses=True\n        )", "code_tokens": ["def", "get_connection", "(", "self", ",", "host", ",", "port", ",", "db", ")", ":", "return", "redis", ".", "StrictRedis", "(", "host", "=", "host", ",", "port", "=", "port", ",", "db", "=", "db", ",", "decode_responses", "=", "True", ")"], "idx": 5420}
{"url": "cosqa-train-8635", "docstring_tokens": ["Turn", "dict", "keys", "and", "values", "into", "native", "strings", "."], "code": "def stringify_dict_contents(dct):\n    \"\"\"Turn dict keys and values into native strings.\"\"\"\n    return {\n        str_if_nested_or_str(k): str_if_nested_or_str(v)\n        for k, v in dct.items()\n    }", "code_tokens": ["def", "stringify_dict_contents", "(", "dct", ")", ":", "return", "{", "str_if_nested_or_str", "(", "k", ")", ":", "str_if_nested_or_str", "(", "v", ")", "for", "k", ",", "v", "in", "dct", ".", "items", "(", ")", "}"], "idx": 1389}
{"url": "cosqa-dev-474", "docstring_tokens": ["Load", "a", "javascript", "file", "and", "minify", "."], "code": "def minify(path):\n    \"\"\"\n    Load a javascript file and minify.\n\n    Parameters\n    ------------\n    path: str, path of resource\n    \"\"\"\n\n    if 'http' in path:\n        data = requests.get(path).content.decode(\n            'ascii', errors='ignore')\n    else:\n        with open(path, 'rb') as f:\n            # some of these assholes use unicode spaces -_-\n            data = f.read().decode('ascii',\n                                   errors='ignore')\n    # don't re- minify\n    if '.min.' in path:\n        return data\n\n    try:\n        return jsmin.jsmin(data)\n    except BaseException:\n        return data", "code_tokens": ["def", "minify", "(", "path", ")", ":", "if", "'http'", "in", "path", ":", "data", "=", "requests", ".", "get", "(", "path", ")", ".", "content", ".", "decode", "(", "'ascii'", ",", "errors", "=", "'ignore'", ")", "else", ":", "with", "open", "(", "path", ",", "'rb'", ")", "as", "f", ":", "#", "some", "of", "these", "assholes", "use", "unicode", "spaces", "-_-", "data", "=", "f", ".", "read", "(", ")", ".", "decode", "(", "'ascii'", ",", "errors", "=", "'ignore'", ")", "#", "don't", "re-", "minify", "if", "'.min.'", "in", "path", ":", "return", "data", "try", ":", "return", "jsmin", ".", "jsmin", "(", "data", ")", "except", "BaseException", ":", "return", "data"], "idx": 4779}
{"url": "cosqa-train-13641", "docstring_tokens": ["Earth", "orientation", "as", "a", "rotating", "matrix"], "code": "def earth_orientation(date):\n    \"\"\"Earth orientation as a rotating matrix\n    \"\"\"\n\n    x_p, y_p, s_prime = np.deg2rad(_earth_orientation(date))\n    return rot3(-s_prime) @ rot2(x_p) @ rot1(y_p)", "code_tokens": ["def", "earth_orientation", "(", "date", ")", ":", "x_p", ",", "y_p", ",", "s_prime", "=", "np", ".", "deg2rad", "(", "_earth_orientation", "(", "date", ")", ")", "return", "rot3", "(", "-", "s_prime", ")", "@", "rot2", "(", "x_p", ")", "@", "rot1", "(", "y_p", ")"], "idx": 5040}
{"url": "cosqa-train-6704", "docstring_tokens": ["Find", "the", "RMS", "of", "the", "audio"], "code": "def calc_volume(self, sample: np.ndarray):\n        \"\"\"Find the RMS of the audio\"\"\"\n        return sqrt(np.mean(np.square(sample)))", "code_tokens": ["def", "calc_volume", "(", "self", ",", "sample", ":", "np", ".", "ndarray", ")", ":", "return", "sqrt", "(", "np", ".", "mean", "(", "np", ".", "square", "(", "sample", ")", ")", ")"], "idx": 1914}
{"url": "cosqa-train-9805", "docstring_tokens": ["Split", "a", "text", "into", "separate", "words", "."], "code": "def tokenize_list(self, text):\n        \"\"\"\n        Split a text into separate words.\n        \"\"\"\n        return [self.get_record_token(record) for record in self.analyze(text)]", "code_tokens": ["def", "tokenize_list", "(", "self", ",", "text", ")", ":", "return", "[", "self", ".", "get_record_token", "(", "record", ")", "for", "record", "in", "self", ".", "analyze", "(", "text", ")", "]"], "idx": 1576}
{"url": "cosqa-train-8973", "docstring_tokens": ["must", "be", "a", "float"], "code": "def is_float(value):\n    \"\"\"must be a float\"\"\"\n    return isinstance(value, float) or isinstance(value, int) or isinstance(value, np.float64), float(value)", "code_tokens": ["def", "is_float", "(", "value", ")", ":", "return", "isinstance", "(", "value", ",", "float", ")", "or", "isinstance", "(", "value", ",", "int", ")", "or", "isinstance", "(", "value", ",", "np", ".", "float64", ")", ",", "float", "(", "value", ")"], "idx": 772}
{"url": "cosqa-train-14810", "docstring_tokens": ["Colorize", "text", "with", "given", "color", "."], "code": "def _write_color_colorama (fp, text, color):\n    \"\"\"Colorize text with given color.\"\"\"\n    foreground, background, style = get_win_color(color)\n    colorama.set_console(foreground=foreground, background=background,\n      style=style)\n    fp.write(text)\n    colorama.reset_console()", "code_tokens": ["def", "_write_color_colorama", "(", "fp", ",", "text", ",", "color", ")", ":", "foreground", ",", "background", ",", "style", "=", "get_win_color", "(", "color", ")", "colorama", ".", "set_console", "(", "foreground", "=", "foreground", ",", "background", "=", "background", ",", "style", "=", "style", ")", "fp", ".", "write", "(", "text", ")", "colorama", ".", "reset_console", "(", ")"], "idx": 1347}
{"url": "cosqa-train-15315", "docstring_tokens": ["Gets", "the", "user", "enter", "max", "and", "min", "values", "of", "where", "the", "raster", "points", "should", "appear", "on", "the", "y", "-", "axis"], "code": "def values(self):\n        \"\"\"Gets the user enter max and min values of where the \n        raster points should appear on the y-axis\n\n        :returns: (float, float) -- (min, max) y-values to bound the raster plot by\n        \"\"\"\n        lower = float(self.lowerSpnbx.value())\n        upper = float(self.upperSpnbx.value())\n        return (lower, upper)", "code_tokens": ["def", "values", "(", "self", ")", ":", "lower", "=", "float", "(", "self", ".", "lowerSpnbx", ".", "value", "(", ")", ")", "upper", "=", "float", "(", "self", ".", "upperSpnbx", ".", "value", "(", ")", ")", "return", "(", "lower", ",", "upper", ")"], "idx": 314}
{"url": "cosqa-train-8953", "docstring_tokens": ["A", "basic", "document", "feature", "extractor", "that", "returns", "a", "dict", "of", "words", "that", "the", "document", "contains", "."], "code": "def contains_extractor(document):\n    \"\"\"A basic document feature extractor that returns a dict of words that the\n    document contains.\"\"\"\n    tokens = _get_document_tokens(document)\n    features = dict((u'contains({0})'.format(w), True) for w in tokens)\n    return features", "code_tokens": ["def", "contains_extractor", "(", "document", ")", ":", "tokens", "=", "_get_document_tokens", "(", "document", ")", "features", "=", "dict", "(", "(", "u'contains({0})'", ".", "format", "(", "w", ")", ",", "True", ")", "for", "w", "in", "tokens", ")", "return", "features"], "idx": 1969}
{"url": "cosqa-train-10594", "docstring_tokens": ["This", "is", "the", "same", "functionality", "as", "int", ".", "from_bytes", "in", "python", "3"], "code": "def _from_bytes(bytes, byteorder=\"big\", signed=False):\n    \"\"\"This is the same functionality as ``int.from_bytes`` in python 3\"\"\"\n    return int.from_bytes(bytes, byteorder=byteorder, signed=signed)", "code_tokens": ["def", "_from_bytes", "(", "bytes", ",", "byteorder", "=", "\"big\"", ",", "signed", "=", "False", ")", ":", "return", "int", ".", "from_bytes", "(", "bytes", ",", "byteorder", "=", "byteorder", ",", "signed", "=", "signed", ")"], "idx": 1205}
{"url": "cosqa-dev-311", "docstring_tokens": ["Return", "the", "index", "of", "an", "element", "in", "the", "list", "."], "code": "def get_list_index(lst, index_or_name):\n    \"\"\"\n    Return the index of an element in the list.\n\n    Args:\n        lst (list): The list.\n        index_or_name (int or str): The value of the reference element, or directly its numeric index.\n\n    Returns:\n        (int) The index of the element in the list.\n    \"\"\"\n    if isinstance(index_or_name, six.integer_types):\n        return index_or_name\n\n    return lst.index(index_or_name)", "code_tokens": ["def", "get_list_index", "(", "lst", ",", "index_or_name", ")", ":", "if", "isinstance", "(", "index_or_name", ",", "six", ".", "integer_types", ")", ":", "return", "index_or_name", "return", "lst", ".", "index", "(", "index_or_name", ")"], "idx": 456}
{"url": "cosqa-train-10017", "docstring_tokens": ["The", "l2", "norm", "of", "an", "array", "is", "is", "defined", "as", ":", "sqrt", "(", "||x||", ")", "where", "||x||", "is", "the", "dot", "product", "of", "the", "vector", "."], "code": "def l2_norm(arr):\n    \"\"\"\n    The l2 norm of an array is is defined as: sqrt(||x||), where ||x|| is the\n    dot product of the vector.\n    \"\"\"\n    arr = np.asarray(arr)\n    return np.sqrt(np.dot(arr.ravel().squeeze(), arr.ravel().squeeze()))", "code_tokens": ["def", "l2_norm", "(", "arr", ")", ":", "arr", "=", "np", ".", "asarray", "(", "arr", ")", "return", "np", ".", "sqrt", "(", "np", ".", "dot", "(", "arr", ".", "ravel", "(", ")", ".", "squeeze", "(", ")", ",", "arr", ".", "ravel", "(", ")", ".", "squeeze", "(", ")", ")", ")"], "idx": 2471}
{"url": "cosqa-train-7309", "docstring_tokens": ["Register", "the", "reporter", "classes", "with", "the", "linter", "."], "code": "def register(linter):\n    \"\"\"Register the reporter classes with the linter.\"\"\"\n    linter.register_reporter(TextReporter)\n    linter.register_reporter(ParseableTextReporter)\n    linter.register_reporter(VSTextReporter)\n    linter.register_reporter(ColorizedTextReporter)", "code_tokens": ["def", "register", "(", "linter", ")", ":", "linter", ".", "register_reporter", "(", "TextReporter", ")", "linter", ".", "register_reporter", "(", "ParseableTextReporter", ")", "linter", ".", "register_reporter", "(", "VSTextReporter", ")", "linter", ".", "register_reporter", "(", "ColorizedTextReporter", ")"], "idx": 3726}
{"url": "cosqa-train-18031", "docstring_tokens": ["Is", "the", "SQLAlchemy", "column", "type", "one", "that", "inherits", "from", ":", "class", ":", "Numeric", "such", "as", ":", "class", ":", "Float", ":", "class", ":", "Decimal", "?"], "code": "def is_sqlatype_numeric(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type one that inherits from :class:`Numeric`,\n    such as :class:`Float`, :class:`Decimal`?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.Numeric)", "code_tokens": ["def", "is_sqlatype_numeric", "(", "coltype", ":", "Union", "[", "TypeEngine", ",", "VisitableType", "]", ")", "->", "bool", ":", "coltype", "=", "_coltype_to_typeengine", "(", "coltype", ")", "return", "isinstance", "(", "coltype", ",", "sqltypes", ".", "Numeric", ")"], "idx": 5933}
{"url": "cosqa-train-11241", "docstring_tokens": ["A", "basic", "check", "of", "if", "the", "program", "is", "running", "in", "interactive", "mode"], "code": "def isInteractive():\n    \"\"\"\n    A basic check of if the program is running in interactive mode\n    \"\"\"\n    if sys.stdout.isatty() and os.name != 'nt':\n        #Hopefully everything but ms supports '\\r'\n        try:\n            import threading\n        except ImportError:\n            return False\n        else:\n            return True\n    else:\n        return False", "code_tokens": ["def", "isInteractive", "(", ")", ":", "if", "sys", ".", "stdout", ".", "isatty", "(", ")", "and", "os", ".", "name", "!=", "'nt'", ":", "#Hopefully", "everything", "but", "ms", "supports", "'\\r'", "try", ":", "import", "threading", "except", "ImportError", ":", "return", "False", "else", ":", "return", "True", "else", ":", "return", "False"], "idx": 133}
{"url": "cosqa-train-13064", "docstring_tokens": ["Return", "a", "new", "datetime", ".", "datetime", "object", "with", "values", "that", "represent", "a", "start", "of", "a", "month", ".", ":", "param", "val", ":", "Date", "to", "...", ":", "type", "val", ":", "datetime", ".", "datetime", "|", "datetime", ".", "date", ":", "rtype", ":", "datetime", ".", "datetime"], "code": "def start_of_month(val):\n    \"\"\"\n    Return a new datetime.datetime object with values that represent\n    a start of a month.\n    :param val: Date to ...\n    :type val: datetime.datetime | datetime.date\n    :rtype: datetime.datetime\n    \"\"\"\n    if type(val) == date:\n        val = datetime.fromordinal(val.toordinal())\n    return start_of_day(val).replace(day=1)", "code_tokens": ["def", "start_of_month", "(", "val", ")", ":", "if", "type", "(", "val", ")", "==", "date", ":", "val", "=", "datetime", ".", "fromordinal", "(", "val", ".", "toordinal", "(", ")", ")", "return", "start_of_day", "(", "val", ")", ".", "replace", "(", "day", "=", "1", ")"], "idx": 113}
{"url": "cosqa-dev-487", "docstring_tokens": ["Compute", "Pearson", "correlation", "coefficient", "."], "code": "def cor(y_true, y_pred):\n    \"\"\"Compute Pearson correlation coefficient.\n    \"\"\"\n    y_true, y_pred = _mask_nan(y_true, y_pred)\n    return np.corrcoef(y_true, y_pred)[0, 1]", "code_tokens": ["def", "cor", "(", "y_true", ",", "y_pred", ")", ":", "y_true", ",", "y_pred", "=", "_mask_nan", "(", "y_true", ",", "y_pred", ")", "return", "np", ".", "corrcoef", "(", "y_true", ",", "y_pred", ")", "[", "0", ",", "1", "]"], "idx": 2560}
{"url": "cosqa-train-11248", "docstring_tokens": ["Return", "a", "context", "manager", "that", "hides", "the", "cursor", "while", "inside", "it", "and", "makes", "it", "visible", "on", "leaving", "."], "code": "def hidden_cursor(self):\n        \"\"\"Return a context manager that hides the cursor while inside it and\n        makes it visible on leaving.\"\"\"\n        self.stream.write(self.hide_cursor)\n        try:\n            yield\n        finally:\n            self.stream.write(self.normal_cursor)", "code_tokens": ["def", "hidden_cursor", "(", "self", ")", ":", "self", ".", "stream", ".", "write", "(", "self", ".", "hide_cursor", ")", "try", ":", "yield", "finally", ":", "self", ".", "stream", ".", "write", "(", "self", ".", "normal_cursor", ")"], "idx": 241}
{"url": "cosqa-train-10454", "docstring_tokens": ["Return", "the", "amount", "of", "characters", "in", "this", "token", "list", "."], "code": "def token_list_len(tokenlist):\n    \"\"\"\n    Return the amount of characters in this token list.\n\n    :param tokenlist: List of (token, text) or (token, text, mouse_handler)\n                      tuples.\n    \"\"\"\n    ZeroWidthEscape = Token.ZeroWidthEscape\n    return sum(len(item[1]) for item in tokenlist if item[0] != ZeroWidthEscape)", "code_tokens": ["def", "token_list_len", "(", "tokenlist", ")", ":", "ZeroWidthEscape", "=", "Token", ".", "ZeroWidthEscape", "return", "sum", "(", "len", "(", "item", "[", "1", "]", ")", "for", "item", "in", "tokenlist", "if", "item", "[", "0", "]", "!=", "ZeroWidthEscape", ")"], "idx": 4479}
{"url": "cosqa-train-6061", "docstring_tokens": ["Converts", "query", "strings", "into", "native", "Python", "objects"], "code": "def urlencoded(body, charset='ascii', **kwargs):\n    \"\"\"Converts query strings into native Python objects\"\"\"\n    return parse_query_string(text(body, charset=charset), False)", "code_tokens": ["def", "urlencoded", "(", "body", ",", "charset", "=", "'ascii'", ",", "*", "*", "kwargs", ")", ":", "return", "parse_query_string", "(", "text", "(", "body", ",", "charset", "=", "charset", ")", ",", "False", ")"], "idx": 2540}
{"url": "cosqa-train-16146", "docstring_tokens": ["Install", "or", "upgrade", "setuptools", "and", "EasyInstall"], "code": "def main(argv, version=DEFAULT_VERSION):\n    \"\"\"Install or upgrade setuptools and EasyInstall\"\"\"\n    tarball = download_setuptools()\n    _install(tarball, _build_install_args(argv))", "code_tokens": ["def", "main", "(", "argv", ",", "version", "=", "DEFAULT_VERSION", ")", ":", "tarball", "=", "download_setuptools", "(", ")", "_install", "(", "tarball", ",", "_build_install_args", "(", "argv", ")", ")"], "idx": 3203}
{"url": "cosqa-train-8518", "docstring_tokens": ["Get", "targets", "for", "loadable", "modules", "."], "code": "def _windowsLdmodTargets(target, source, env, for_signature):\n    \"\"\"Get targets for loadable modules.\"\"\"\n    return _dllTargets(target, source, env, for_signature, 'LDMODULE')", "code_tokens": ["def", "_windowsLdmodTargets", "(", "target", ",", "source", ",", "env", ",", "for_signature", ")", ":", "return", "_dllTargets", "(", "target", ",", "source", ",", "env", ",", "for_signature", ",", "'LDMODULE'", ")"], "idx": 4052}
{"url": "cosqa-train-18790", "docstring_tokens": ["Converts", "a", "list", "into", "a", "space", "-", "separated", "string", "and", "puts", "it", "in", "a", "dictionary"], "code": "def encode_list(key, list_):\n    # type: (str, Iterable) -> Dict[str, str]\n    \"\"\"\n    Converts a list into a space-separated string and puts it in a dictionary\n\n    :param key: Dictionary key to store the list\n    :param list_: A list of objects\n    :return: A dictionary key->string or an empty dictionary\n    \"\"\"\n    if not list_:\n        return {}\n    return {key: \" \".join(str(i) for i in list_)}", "code_tokens": ["def", "encode_list", "(", "key", ",", "list_", ")", ":", "#", "type:", "(str,", "Iterable)", "->", "Dict[str,", "str]", "if", "not", "list_", ":", "return", "{", "}", "return", "{", "key", ":", "\"", "\"", ".", "join", "(", "str", "(", "i", ")", "for", "i", "in", "list_", ")", "}"], "idx": 5769}
{"url": "cosqa-train-6682", "docstring_tokens": ["image", "resize", "function", "used", "by", "quite", "a", "few", "image", "problems", "."], "code": "def resize_by_area(img, size):\n  \"\"\"image resize function used by quite a few image problems.\"\"\"\n  return tf.to_int64(\n      tf.image.resize_images(img, [size, size], tf.image.ResizeMethod.AREA))", "code_tokens": ["def", "resize_by_area", "(", "img", ",", "size", ")", ":", "return", "tf", ".", "to_int64", "(", "tf", ".", "image", ".", "resize_images", "(", "img", ",", "[", "size", ",", "size", "]", ",", "tf", ".", "image", ".", "ResizeMethod", ".", "AREA", ")", ")"], "idx": 1466}
{"url": "cosqa-train-15174", "docstring_tokens": ["Fill", "missing", "values", "in", "pandas", "objects", "and", "numpy", "arrays", "."], "code": "def fillna(series_or_arr, missing_value=0.0):\n    \"\"\"Fill missing values in pandas objects and numpy arrays.\n\n    Arguments\n    ---------\n    series_or_arr : pandas.Series, numpy.ndarray\n        The numpy array or pandas series for which the missing values\n        need to be replaced.\n    missing_value : float, int, str\n        The value to replace the missing value with. Default 0.0.\n\n    Returns\n    -------\n    pandas.Series, numpy.ndarray\n        The numpy array or pandas series with the missing values\n        filled.\n    \"\"\"\n\n    if pandas.notnull(missing_value):\n        if isinstance(series_or_arr, (numpy.ndarray)):\n            series_or_arr[numpy.isnan(series_or_arr)] = missing_value\n        else:\n            series_or_arr.fillna(missing_value, inplace=True)\n\n    return series_or_arr", "code_tokens": ["def", "fillna", "(", "series_or_arr", ",", "missing_value", "=", "0.0", ")", ":", "if", "pandas", ".", "notnull", "(", "missing_value", ")", ":", "if", "isinstance", "(", "series_or_arr", ",", "(", "numpy", ".", "ndarray", ")", ")", ":", "series_or_arr", "[", "numpy", ".", "isnan", "(", "series_or_arr", ")", "]", "=", "missing_value", "else", ":", "series_or_arr", ".", "fillna", "(", "missing_value", ",", "inplace", "=", "True", ")", "return", "series_or_arr"], "idx": 4722}
{"url": "cosqa-train-7243", "docstring_tokens": ["Compute", "the", "total", "size", "of", "all", "elements", "in", "objects", "."], "code": "def get_size(objects):\n    \"\"\"Compute the total size of all elements in objects.\"\"\"\n    res = 0\n    for o in objects:\n        try:\n            res += _getsizeof(o)\n        except AttributeError:\n            print(\"IGNORING: type=%s; o=%s\" % (str(type(o)), str(o)))\n    return res", "code_tokens": ["def", "get_size", "(", "objects", ")", ":", "res", "=", "0", "for", "o", "in", "objects", ":", "try", ":", "res", "+=", "_getsizeof", "(", "o", ")", "except", "AttributeError", ":", "print", "(", "\"IGNORING:", "type=%s;", "o=%s\"", "%", "(", "str", "(", "type", "(", "o", ")", ")", ",", "str", "(", "o", ")", ")", ")", "return", "res"], "idx": 713}
{"url": "cosqa-train-10565", "docstring_tokens": ["Show", "help", "on", "all", "commands", "."], "code": "def do_help(self, arg):\n        \"\"\"\n        Show help on all commands.\n        \"\"\"\n        print(self.response_prompt, file=self.stdout)\n        return cmd.Cmd.do_help(self, arg)", "code_tokens": ["def", "do_help", "(", "self", ",", "arg", ")", ":", "print", "(", "self", ".", "response_prompt", ",", "file", "=", "self", ".", "stdout", ")", "return", "cmd", ".", "Cmd", ".", "do_help", "(", "self", ",", "arg", ")"], "idx": 4504}
{"url": "cosqa-train-2927", "docstring_tokens": ["Convert", "an", "OrderedDict", "containing", "C", "values", "to", "a", "1D", "array", "."], "code": "def C_dict2array(C):\n    \"\"\"Convert an OrderedDict containing C values to a 1D array.\"\"\"\n    return np.hstack([np.asarray(C[k]).ravel() for k in C_keys])", "code_tokens": ["def", "C_dict2array", "(", "C", ")", ":", "return", "np", ".", "hstack", "(", "[", "np", ".", "asarray", "(", "C", "[", "k", "]", ")", ".", "ravel", "(", ")", "for", "k", "in", "C_keys", "]", ")"], "idx": 879}
